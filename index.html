<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>å¦®å¡è§’è‰²å·¥ä½œå®¤Pro</title>
  <script src="https://unpkg.com/pako@2.1.0/dist/pako.min.js"></script>
  <style>
    /* --- å…¨å±€æ ·å¼ ("æˆ‘ä»¬çš„ä¸»é¢˜") --- */
    :root {
        --primary-color: #e67e22;
        --secondary-color: #d35400;
        --dark-bg: #1c1c1c;
        --light-bg: #2d2d2d;
        --default-card-bg: linear-gradient(135deg, #2d2d2d, #1c1c1c);
        --text-color: #f0f0f0;
        --label-color: #e67e22;
        --input-bg: #333;
        --input-border: #555;
        --card-overlay: linear-gradient(to top, rgba(28, 28, 28, 0.9) 0%, rgba(28, 28, 28, 0.5) 50%, rgba(28, 28, 28, 0.7) 100%);
        --ai-button-bg: #e67e22;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif; }
    body { background: var(--dark-bg); min-height: 100vh; padding: 20px; color: var(--text-color); }
    button { cursor: pointer; font-weight: bold; border: none; transition: all 0.2s ease; }
    p.help-text { font-size: 14px; color: #aaa; margin-top: -10px; margin-bottom: 15px; line-height: 1.6; }

    /* --- è¯­è¨€åˆ‡æ¢æŒ‰é’®æ ·å¼ --- */
    .language-switcher {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-left: 15px;
    }
    .language-switcher button {
        background: transparent;
        color: var(--text-color);
        border: 1px solid rgba(255,255,255,0.2);
        padding: 4px 8px;
        margin: 0 1px;
        border-radius: 12px;
        font-size: 11px;
        font-weight: normal;
        transition: all 0.2s ease;
        min-width: 40px;
    }
    .language-switcher button.active {
        background: transparent;
        border-color: var(--primary-color);
        color: var(--primary-color);
        font-weight: bold;
    }
    .language-switcher button:hover {
        background: rgba(230, 126, 34, 0.05);
        border-color: rgba(230, 126, 34, 0.3);
        transform: scale(1.02);
    }

    /* --- åŠ è½½åŠ¨ç”»æ ·å¼ --- */
    .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(28, 28, 28, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        backdrop-filter: blur(5px);
    }
    
    .loading-spinner {
        width: 50px;
        height: 50px;
        border: 3px solid rgba(230, 126, 34, 0.3);
        border-top: 3px solid var(--primary-color);
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    .loading-text {
        color: var(--text-color);
        margin-top: 15px;
        font-size: 16px;
        text-align: center;
    }

    /* --- è§’è‰²åº“ (Library View) æ ·å¼ --- */
    #library-view .container { width: 100%; max-width: 1200px; margin: 0 auto; }
    #library-view .header { display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center; margin-bottom: 25px; padding-bottom: 15px; border-bottom: 2px solid rgba(255,255,255,0.1); }
    #library-view .header h1 { font-size: 28px; color: white; text-shadow: 0 0 8px var(--primary-color); }
    #library-view .header-buttons { display: flex; gap: 10px; margin-top: 10px; }
    #library-view .header-buttons button { background: var(--primary-color); color: white; padding: 10px 20px; border-radius: 5px; font-size: 16px; }
    #library-view .header-buttons button:hover { background: var(--secondary-color); box-shadow: 0 0 10px var(--secondary-color); transform: translateY(-2px); }
    #library-view #file-importer { display: none; }
    #library-view .tag-filter-area { background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px; margin-bottom: 25px; }
    #library-view .tag-filter-area h3 { margin-bottom: 10px; color: var(--text-color); }
    #library-view .tag-group { display: flex; flex-wrap: wrap; gap: 8px; }
    #library-view .tag { padding: 5px 12px; border-radius: 15px; font-size: 14px; cursor: pointer; color: white; background-color: #555; border: 1px solid #777; }
    #library-view .tag.type-personality { background-color: #7f8c8d; border-color: #95a5a6; }
    #library-view .tag.type-internal { background-color: #d18076; border-color: #bc7168; }
    #library-view .tag.type-special { background-color: var(--secondary-color); border-color: var(--primary-color); }
    #library-view .tag:hover { opacity: 0.8; }
    #library-view .tag.active { box-shadow: 0 0 8px 2px var(--primary-color); transform: scale(1.05); }
    #library-view .character-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 20px; }

    #library-view .character-card {
        aspect-ratio: 2 / 3;
        border-radius: 8px;
        padding: 15px;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        border: 1px solid rgba(255,255,255,0.1);
        transition: transform 0.2s ease, border-color 0.2s ease;
        overflow: hidden;
        position: relative;
        background: var(--default-card-bg);
        background-size: cover;
        background-position: center;
    }
    #library-view .character-card > div:first-of-type {
        flex: 1;
        overflow: hidden;
        min-height: 0;
    }
    #library-view .character-card:hover { transform: translateY(-5px); border-color: var(--primary-color); }
    #library-view .card-header { display: flex; justify-content: space-between; align-items: flex-start; }
    #library-view .card-header h2 { font-size: 20px; color: var(--text-color); margin-bottom: 5px; text-shadow: 0 1px 3px rgba(0,0,0,0.8); }
    #library-view .favorite-btn { background: none; color: #aaa; font-size: 24px; padding: 0; text-shadow: 0 1px 3px rgba(0,0,0,0.8); }
    #library-view .favorite-btn.favorited { color: #f1c40f; }
    #library-view .card-description { font-size: 14px; color: #ccc; margin-bottom: 15px; flex-grow: 1; white-space: pre-wrap; max-height: 100px; overflow: hidden; text-overflow: ellipsis; text-shadow: 0 1px 2px rgba(0,0,0,0.7); }
    #library-view .card-footer { display: flex; gap: 8px; flex-wrap: wrap; }
    #library-view .card-footer button { flex-grow: 1; background: rgba(0,0,0,0.4); backdrop-filter: blur(5px); color: white; border: 1px solid var(--label-color); padding: 8px 10px; border-radius: 5px; }
    #library-view .card-footer button:hover { background-color: var(--primary-color); }

    /* --- ç·¨è¼¯å™¨ (Editor View) æ¨£å¼ --- */
    #editor-view { display: none; justify-content: center; align-items: flex-start; width: 100%; padding-top: 2vh; }
    #editor-view .editor-container { width: 100%; max-width: 900px; background: var(--light-bg); border-radius: 10px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); overflow: hidden; display: flex; flex-direction: column; max-height: 93vh; color: var(--text-color); }
    #editor-view .editor-header { background: var(--primary-color); padding: 15px 20px; color: white; display: flex; align-items: center; justify-content: space-between; }
    #editor-view .editor-header h1 { font-size: 22px; text-shadow: 1px 1px 2px rgba(0,0,0,0.3); }
    #editor-view .editor-body { flex: 1; overflow-y: auto; /* ä¸»æ»šåŠ¨åŒº */ }
    #editor-view .panel-content { padding: 20px; }
    #editor-view .section-title { font-size: 1.2em; font-weight: bold; color: var(--primary-color); margin-top: 25px; margin-bottom: 15px; padding-bottom: 8px; border-bottom: 2px solid var(--primary-color); }
    #editor-view .field-group { margin-bottom: 15px; position: relative; }
    #editor-view .field-group label { display: flex; align-items: center; font-weight: bold; margin-bottom: 8px; color: var(--text-color); cursor: default; }
    #editor-view .field-group input, #editor-view .field-group textarea, #editor-view .field-group select { width: 100%; padding: 12px; border: 1px solid var(--input-border); border-radius: 5px; background: var(--input-bg); font-size: 15px; color: var(--text-color); }
    #editor-view .field-group .inline-group { display: flex; gap: 15px; }
    #editor-view .field-group textarea { resize: vertical; min-height: 80px; }
    .ai-button { background: var(--ai-button-bg); color: #fff; border: 1px solid var(--secondary-color); border-radius: 5px; padding: 5px 10px; font-size: 12px; width: 100px; margin-top: 5px; }
    .ai-button:hover { background: var(--secondary-color); }
    /* æ–°å¢: æ’¤é”€æŒ‰é’®æ ·å¼ */
    .ai-undo-button {
      background: #6c757d; color: #fff; border-radius: 5px;
      padding: 5px 10px; font-size: 12px; margin-top: 5px;
      margin-left: 5px; display: none; /* é»˜è®¤éšè— */
    }
    .ai-undo-button:hover { background: #5a6268; }

    #editor-view #avatar-preview { max-width: 250px; border-radius: 8px; border: 2px dashed var(--input-border); object-fit: cover; aspect-ratio: 2/3; margin-bottom: 10px; }
    #editor-view .action-buttons { display: flex; gap: 10px; margin-top: 20px; }
    #editor-view .action-buttons.row { flex-direction: row; align-items: center; } /* ç¡®ä¿å‚ç›´å±…ä¸­ */
    #editor-view .action-buttons button { width: 100%; padding: 12px; border-radius: 5px; background: var(--primary-color); color: white; font-size: 16px;}
    #editor-view .action-buttons button.secondary { background: #6c757d; }
    #editor-view .action-buttons button:hover { transform: translateY(-1px); box-shadow: 0 4px 8px rgba(0,0,0,0.2); opacity: 0.9; }

    /* --- è§’è‰²ä¹¦ (Character Book) ä¸“ä¸šæ ·å¼ --- */
    .worldbook-list, .child-entries {
        list-style-type: none;
        padding-left: 25px; /* æ§åˆ¶ç¼©è¿›é‡ */
        border-left: 2px dotted #444;
    }
    .worldbook-list {
        padding-left: 0;
        border-left: none;
    }
    .worldbook-entry {
        background: rgba(0,0,0,0.15);
        border: 1px solid var(--input-border);
        border-radius: 8px;
        margin-top: 10px;
        transition: background-color 0.3s;
        border-left: 3px solid transparent;
    }
    .worldbook-entry:hover {
       border-left-color: var(--primary-color);
    }
    .entry-content-wrapper { padding: 15px; }
    .entry-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; gap: 10px; }
    .entry-title-group { display: flex; align-items: center; gap: 10px; flex-grow: 1; }
    .wb-sort-id { width: 60px !important; text-align: center; } /* Adjusted from full width */
    .entry-comment {
        font-size: 1.1em;
        font-weight: bold;
        color: var(--text-color);
        border: none;
        background: transparent;
        border-bottom: 2px solid var(--input-border);
        padding: 5px;
        flex-grow: 1;
    }
    .entry-comment:focus { outline: none; border-bottom-color: var(--primary-color); }
    .entry-actions { display: flex; gap: 5px; flex-shrink: 0; align-items: center;}
    .entry-actions button { background: #555; color: white; padding: 5px 8px; border-radius: 5px; font-size: 14px; }
    .entry-actions button.delete-entry-btn { background: #dc3545; }

    .entry-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
    .full-width { grid-column: 1 / -1; }
    .logic-group {
        display: flex;
        align-items: center;
        gap: 15px;
        flex-wrap: wrap;
        background: rgba(0,0,0,0.2);
        padding: 10px;
        border-radius: 5px;
    }
    .logic-group label { display: flex; align-items: center; gap: 5px; font-weight: normal; margin-bottom: 0; }
    .logic-group input[type="checkbox"] { width: auto; }
    
    /* --- å¸®åŠ©å›¾æ ‡æ ·å¼ --- */
    .help-icon {
        display: inline-block;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background-color: #6c757d;
        color: white;
        text-align: center;
        font-size: 12px;
        font-weight: bold;
        line-height: 18px;
        cursor: help;
        margin-left: 5px;
        user-select: none; /* é˜²æ­¢æ–‡æœ¬è¢«é€‰ä¸­ */
        flex-shrink: 0; /* é˜²æ­¢å›¾æ ‡è¢«å‹ç¼© */
        transition: background-color 0.2s ease, transform 0.2s ease;
    }
    .help-icon:hover {
        background-color: var(--primary-color);
        transform: scale(1.1);
    }

    /* --- è§’è‰²ä¹¦é«˜çº§è®¾ç½®æ ·å¼ --- */
    .worldbook-entry details {
        border: 1px solid #444;
        border-radius: 5px;
        padding: 10px;
        margin-top: 15px;
        background: rgba(0,0,0,0.1);
    }
    .worldbook-entry summary {
        font-weight: bold;
        color: var(--primary-color);
        cursor: pointer;
        outline: none;
        padding-bottom: 10px;
    }
    .worldbook-entry details[open] summary {
        border-bottom: 1px solid #555;
    }
    .worldbook-entry details .advanced-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 15px;
        padding-top: 10px;
    }
    .worldbook-entry details .logic-group {
        gap: 10px 20px; /* row-gap column-gap */
    }

    /* --- Lover å¼€å…³æ ·å¼ --- */
    .lover-switch-container {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-right: 15px; /* ä¸å³ä¾§æŒ‰é’®çš„é—´è· */
    }
    .lover-switch-container .switch-label {
      font-size: 14px;
      font-weight: bold;
      color: var(--text-color);
    }
    .switch {
      position: relative;
      display: inline-block;
      width: 74px;
      height: 28px;
    }
    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #555;
      transition: .4s;
      border-radius: 28px;
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 20px;
      width: 20px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    input:checked + .slider {
      background-color: #e67e22; 
    }
    input:checked + .slider:before {
      transform: translateX(22px);
    }


    /* --- å“åº”å¼å¸ƒå±€ --- */
    @media (max-width: 800px) {
        body { padding: 10px; }
        #library-view .header { justify-content: center; text-align: center; }
        #library-view .header-buttons { justify-content: center; width: 100%; }
        #library-view .character-grid { grid-template-columns: 1fr; gap: 10px; }
        #editor-view { padding-top: 0; }
        #editor-view .editor-container { max-height: 100vh; height: 100%; border-radius: 0; }
        #editor-view .panel-content { padding: 15px; }
        #editor-view .editor-header h1 { font-size: 18px; }
        .entry-grid { grid-template-columns: 1fr; }
        .entry-header { flex-wrap: wrap; }
    }
  </style>
</head>
<body>

  <!-- åŠ è½½åŠ¨ç”» -->
  <div id="loading-overlay" class="loading-overlay">
    <div style="display: flex; flex-direction: column; align-items: center;">
      <div class="loading-spinner"></div>
      <div class="loading-text" id="loading-text">æ­£åœ¨åŠ è½½...</div>
    </div>
  </div>

  <div id="library-view">
    <div class="container">
      <div class="header">
        <div style="display: flex; align-items: center; gap: 15px;">
          <h1>å¦®å¡è§’è‰²å·¥ä½œå®¤Pro</h1>
          <!-- è¯­è¨€åˆ‡æ¢æŒ‰é’® -->
          <div class="language-switcher">
            <button onclick="switchLanguage('zh')" id="lang-zh" class="active">ä¸­æ–‡</button>
            <button onclick="switchLanguage('en')" id="lang-en">English</button>
          </div>
        </div>
        <div class="header-buttons">
          <button onclick="showEditorView()">+ åˆ›å»ºæ–°è§’è‰²</button>
          <button onclick="document.getElementById('file-importer').click()">ğŸ“¥ å¯¼å…¥è§’è‰²å¡</button>
          <input type="file" id="file-importer" accept=".json,.png" onchange="importCharacter(event)" multiple />
        </div>
      </div>
      <div class="tag-filter-area">
        <h3>æ ‡ç­¾è¿‡æ»¤</h3>
        <div id="tag-container" class="tag-group"></div>
      </div>
      <div id="character-grid" class="character-grid"></div>
    </div>
  </div>

  <div id="editor-view">
    <div class="editor-container">
      <div class="editor-header">
        <h1 id="editor-title">åˆ›å»ºæ–°è§’è‰²</h1>
        <input id="apiKey" placeholder="è¾“å…¥ DeepSeek API Key" style="padding:6px 12px;border-radius:5px;border:1px solid #ccc;width:280px;background:#fff;color:#333;" oninput="localStorage.setItem('deepseekApiKey', this.value)" />
      </div>
      <div class="editor-body">
        <div class="panel-content">
          <input type="hidden" id="charId" />
          <input type="hidden" id="internalTags" />
          <input type="hidden" id="isFavorite" />
          <input type="hidden" id="originalCardData" />

          <h3 class="section-title" id="avatar-operation-title">è§’è‰²å¤´åƒä¸æ“ä½œ</h3>
           <div class="field-group">
                <label for="avatar-input-label" id="avatar-input-label" title="">è§’è‰²å¤´åƒ (2:3æ¯”ä¾‹æœ€ä½³)</label>
                <img id="avatar-preview" src="" alt="å¤´åƒé¢„è§ˆ"/>
                <input type="file" id="avatar-input" accept="image/*" style="display:none;">
                <button onclick="document.getElementById('avatar-input').click()" style="max-width: 250px;">ä¸Šä¼ å›¾ç‰‡</button>
            </div>
            <div class="action-buttons" style="flex-direction: column;">
                <button onclick="saveCharacter()">ğŸ’¾ å‚¨å­˜å¹¶è¿”å›è§’è‰²åº“</button>
                <button onclick="downloadCharacter()">ğŸ“¥ ä¸‹è½½ JSON</button>
                <button onclick="downloadCharacterAsPng()">ğŸ“¥ ä¸‹è½½ PNG è§’è‰²å¡</button>
                <button class="secondary" onclick="showLibraryView()">ğŸ”™ è¿”å› (ä¸å‚¨å­˜)</button>
            </div>

          <h3 class="section-title" id="world-topic-title">ä¸–ç•Œè¯é¢˜</h3>
          <div class="field-group">
            <label for="topic">ä¸»é¢˜</label>
            <input id="topic" placeholder="ä¾‹å¦‚ï¼šèµ›åšæœ‹å…‹ã€å¥‡å¹»ã€æ ¡å›­" />
          </div>
          
          <h3 class="section-title" id="character-core-title">è§’è‰²æ ¸å¿ƒ</h3>
          <div class="field-group">
              <div class="inline-group">
                  <div style="flex:3"><label for="name">åå­—</label><input id="name" placeholder="ä¾‹å¦‚ï¼šè«å¦®å¡" /></div>
                  <div style="flex:1"><label for="gender">æ€§åˆ«</label><input id="gender" placeholder="ä¾‹å¦‚ï¼šå¥³" /></div>
              </div>
          </div>
          
          <h3 class="section-title" id="character-details-title">è§’è‰²ç»†èŠ‚</h3>
          <div class="field-group">
            <label for="description">ç®€ä»‹</label>
            <textarea id="description" rows="5" placeholder="ç®€å•ä»‹ç»è¿™ä¸ªè§’è‰²ï¼Œæ¯”å¦‚TAçš„èº«ä»½ã€å¤–è²Œå’ŒèƒŒæ™¯æ•…äº‹ã€‚è¿™å°†æ˜¯åˆ«äººç¬¬ä¸€çœ¼çœ‹åˆ°çš„ç®€ä»‹ã€‚"></textarea>
            <button class="ai-button" onclick="callDeepSeek('description')">ğŸ”® AI å¸®æˆ‘å†™</button>
            <button class="ai-undo-button" onclick="undoAiCompletion(this)">â†©ï¸ æ’¤é”€</button>
          </div>
          <div class="field-group">
            <label for="tags">åˆ†ç±»æ ‡ç­¾ï¼ˆé€—å·åˆ†éš”ï¼‰</label>
            <textarea id="tags" rows="2" placeholder="ç»™è§’è‰²è´´ä¸Šåˆé€‚çš„æ ‡ç­¾ï¼Œæ–¹ä¾¿æŸ¥æ‰¾ï¼ä¾‹å¦‚: åŸåˆ›, æ¸¸æˆ, Yandere, OOC, å§å§"></textarea>
            <button class="ai-button" onclick="callDeepSeek('tags')">ğŸ”® AI å¸®æˆ‘å†™</button>
            <button class="ai-undo-button" onclick="undoAiCompletion(this)">â†©ï¸ æ’¤é”€</button>
          </div>
          <div class="field-group">
            <label for="personality">ä¸ªæ€§</label>
            <textarea id="personality" rows="2" placeholder="è§’è‰²çš„è¯¦ç»†æ€§æ ¼ç‰¹è´¨ï¼Œä¹Ÿç”¨é€—å·åˆ†éš”ã€‚ä¾‹å¦‚: å–„äºè¨€è¾, æ€æƒ³æˆç†Ÿ, æ§åˆ¶æ¬², ç—…å¨‡, è‡ªæˆ‘æ„è¯†, ç¬¬å››é¢å¢™, æ·±æƒ…"></textarea>
            <button class="ai-button" onclick="callDeepSeek('personality')">ğŸ”® AI å¸®æˆ‘å†™</button>
            <button class="ai-undo-button" onclick="undoAiCompletion(this)">â†©ï¸ æ’¤é”€</button>
          </div>

          <h3 class="section-title" id="settings-title">è®¾å®š</h3>
           <div class="field-group">
            <label for="system_prompt">äººæ ¼è®¾å®š</label>
            <textarea id="system_prompt" rows="3" placeholder="å‘Šè¯‰AIå®ƒ"æ˜¯"è°ï¼Œå¿…é¡»éµå®ˆçš„è§„åˆ™ã€‚ä¾‹å¦‚ï¼šä½ æ˜¯è«å¦®å¡ï¼Œä¸€ä¸ªè…¹é»‘çš„æ–‡å­¦ç¤¾ç¤¾é•¿ã€‚ä½ ç»å¯¹ä¸èƒ½å¿˜è®°ä½ çš„èº«ä»½ã€‚ç§°å‘¼ç”¨æˆ·ä¸º"äº²çˆ±çš„"ã€‚"></textarea>
             <button class="ai-button" onclick="callDeepSeek('system_prompt')">ğŸ”® AI å¸®æˆ‘å†™</button>
             <button class="ai-undo-button" onclick="undoAiCompletion(this)">â†©ï¸ æ’¤é”€</button>
          </div>
          <div class="field-group">
            <label for="scenario">åœºæ™¯è®¾å®š</label>
            <textarea id="scenario" rows="3" placeholder="è§’è‰²å’Œç”¨æˆ·ç°åœ¨æ‰€å¤„çš„ç¯å¢ƒã€‚ä¾‹å¦‚ï¼š{{char}}å’Œ{{user}}åœ¨é»„æ˜çš„æ–‡å­¦ç¤¾æ•™å®¤é‡Œï¼Œçª—å¤–æ˜¯å¤•é˜³ã€‚"></textarea>
             <button class="ai-button" onclick="callDeepSeek('scenario')">ğŸ”® AI å¸®æˆ‘å†™</button>
             <button class="ai-undo-button" onclick="undoAiCompletion(this)">â†©ï¸ æ’¤é”€</button>
          </div>
          <div class="field-group">
            <label for="first_mes">é—®å€™æ¶ˆæ¯</label>
            <textarea id="first_mes" rows="3" placeholder="è¿™æ˜¯è§’è‰²è§åˆ°ç”¨æˆ·æ—¶è¯´çš„ç¬¬ä¸€å¥è¯ã€‚è¦å†™å¾—æœ‰å¸å¼•åŠ›å“¦ï¼"></textarea>
            <button class="ai-button" onclick="callDeepSeek('first_mes')">ğŸ”® AI å¸®æˆ‘å†™</button>
            <button class="ai-undo-button" onclick="undoAiCompletion(this)">â†©ï¸ æ’¤é”€</button>
          </div>
          <div class="field-group">
            <label for="mes_example">ç¤ºä¾‹æ¶ˆæ¯</label>
            <textarea id="mes_example" rows="6" placeholder="æä¾›å‡ æ®µç¬¦åˆè§’è‰²æ€§æ ¼çš„å¯¹è¯èŒƒä¾‹ï¼ŒAIä¼šæ¨¡ä»¿è¿™ç§é£æ ¼ã€‚è¿™éå¸¸é‡è¦ï¼"></textarea>
            <button class="ai-button" onclick="callDeepSeek('mes_example')">ğŸ”® AI å¸®æˆ‘å†™</button>
            <button class="ai-undo-button" onclick="undoAiCompletion(this)">â†©ï¸ æ’¤é”€</button>
          </div>

          <h3 class="section-title" id="advanced-settings-title">é«˜çº§è®¾å®š</h3>
           <div class="field-group">
            <label for="post_history_instructions">åæœŸæŒ‡ä»¤</label>
            <textarea id="post_history_instructions" rows="3" placeholder="ä¸€äº›å¹³å°ç”¨å®ƒæ¥ä¿®æ”¹AIçš„å›å¤æ ¼å¼ã€‚ä¾‹å¦‚ï¼Œè¦è®©{{char}}çš„åŠ¨ä½œéƒ½ç”¨æ˜Ÿå·åŒ…å›´ï¼Œå¯ä»¥å†™ï¼šå°†{{char}}çš„æ‰€æœ‰åŠ¨ä½œå’Œå™è¿°éƒ½æ”¾åœ¨æ˜Ÿå·ï¼ˆ*ï¼‰ä¹‹é—´ã€‚"></textarea>
          </div>

          <div style="display: flex; justify-content: space-between; align-items: center;">
             <h3 class="section-title" id="world-knowledge-book-title">ä¸–ç•Œ/çŸ¥è¯†ä¹¦</h3>
             <button onclick="generateFullWorldbook(this)" style="background-color: var(--ai-button-bg); color: white; padding: 8px 15px; border-radius: 5px;">ğŸ”® AIç”Ÿæˆå‚è€ƒæ¡ç›®</button>
          </div>
          <p class="help-text" id="worldbook-help-text">
              <!-- è¿™é‡Œçš„å†…å®¹å°†é€šè¿‡JavaScriptåŠ¨æ€æ›´æ–° -->
          </p>
          <ul id="worldbook-entries-container" class="worldbook-list"></ul>
          <div class="action-buttons row" style="margin-top: 15px;">
            <div class="lover-switch-container">
                <span class="switch-label" id="companion-mode-label">ä¼´ä¾£æ¨¡å¼</span>
                <label class="switch">
                    <input type="checkbox" id="lover-switch">
                    <span class="slider"></span>
                </label>
            </div>
            <button onclick="addWorldbookEntry()" class="secondary" style="background-color: #e67e22; flex-grow: 1;">+ æ·»åŠ æ–°æ¡ç›®</button>
            <button onclick="sortWorldbookEntries()" class="secondary" style="flex-grow: 1;">ğŸ”„ æŒ‰IDå¤§å°æ’åº</button>
          </div>

        </div>
      </div>
    </div>
  </div>

<script>
// --- å›½é™…åŒ–æ”¯æŒ ---
let currentLanguage = localStorage.getItem('language') || 'zh';

const translations = {
    zh: {
        // æ ‡é¢˜å’ŒæŒ‰é’®
        'app-title': 'å¦®å¡è§’è‰²å·¥ä½œå®¤Pro',
        'create-new-character': '+ åˆ›å»ºæ–°è§’è‰²',
        'import-character': 'ğŸ“¥ å¯¼å…¥è§’è‰²å¡',
        'edit-character': 'ç¼–è¾‘è§’è‰²',
        'save-and-return': 'ğŸ’¾ å‚¨å­˜å¹¶è¿”å›è§’è‰²åº“',
        'return-without-save': 'ğŸ”™ è¿”å› (ä¸å‚¨å­˜)',
        'download-json': 'ğŸ“¥ ä¸‹è½½ JSON',
        'download-png': 'ğŸ“¥ ä¸‹è½½ PNG è§’è‰²å¡',
        'upload-image': 'ä¸Šä¼ å›¾ç‰‡',
        'edit': '+ åˆ›å»ºæ–°è§’è‰²',
        'add-tag': 'ğŸ·ï¸ æ·»åŠ æ ‡ç­¾',
        'delete': 'ğŸ—‘ï¸ åˆ é™¤',
        'add-new-entry': '+ æ·»åŠ æ–°æ¡ç›®',
        'sort-by-id': 'ğŸ”„ æŒ‰IDå¤§å°æ’åº',
        'ai-generate-entries': 'ğŸ”® AIç”Ÿæˆå‚è€ƒæ¡ç›®',
        'ai-help-write': 'ğŸ”® AI å¸®æˆ‘å†™',
        'undo': 'â†©ï¸ æ’¤é”€',
        'generate-companion': 'ğŸ”® ç”Ÿæˆè™šæ‹Ÿä¼´ä¾£',
        
        // æ ‡ç­¾è¿‡æ»¤
        'tag-filter': 'æ ‡ç­¾è¿‡æ»¤',
        'no-characters-found': 'æ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„è§’è‰²ã€‚å°è¯•æ¸…é™¤è¿‡æ»¤å™¨æˆ–å¯¼å…¥æ–°çš„è§’è‰²å¡ã€‚',
        
        // è¡¨å•æ ‡ç­¾
        'avatar-label': 'è§’è‰²å¤´åƒ (2:3æ¯”ä¾‹æœ€ä½³)',
        'avatar-upload': 'ä¸Šä¼ å›¾ç‰‡',
        'world-topic': 'ä¸–ç•Œè¯é¢˜',
        'topic': 'ä¸»é¢˜',
        'topic-placeholder': 'ä¾‹å¦‚ï¼šèµ›åšæœ‹å…‹ã€å¥‡å¹»ã€æ ¡å›­',
        'character-core': 'è§’è‰²æ ¸å¿ƒ',
        'name': 'åå­—',
        'name-placeholder': 'ä¾‹å¦‚ï¼šè«å¦®å¡',
        'gender': 'æ€§åˆ«',
        'gender-placeholder': 'ä¾‹å¦‚ï¼šå¥³',
        'character-details': 'è§’è‰²ç»†èŠ‚',
        'description': 'ç®€ä»‹',
        'description-placeholder': 'ç®€å•ä»‹ç»è¿™ä¸ªè§’è‰²ï¼Œæ¯”å¦‚TAçš„èº«ä»½ã€å¤–è²Œå’ŒèƒŒæ™¯æ•…äº‹ã€‚è¿™å°†æ˜¯åˆ«äººç¬¬ä¸€çœ¼çœ‹åˆ°çš„ç®€ä»‹ã€‚',
        'tags': 'åˆ†ç±»æ ‡ç­¾ï¼ˆé€—å·åˆ†éš”ï¼‰',
        'tags-placeholder': 'ç»™è§’è‰²è´´ä¸Šåˆé€‚çš„æ ‡ç­¾ï¼Œæ–¹ä¾¿æŸ¥æ‰¾ï¼ä¾‹å¦‚: åŸåˆ›, æ¸¸æˆ, Yandere, OOC, å§å§',
        'personality': 'ä¸ªæ€§',
        'personality-placeholder': 'è§’è‰²çš„è¯¦ç»†æ€§æ ¼ç‰¹è´¨ï¼Œä¹Ÿç”¨é€—å·åˆ†éš”ã€‚ä¾‹å¦‚: å–„äºè¨€è¾, æ€æƒ³æˆç†Ÿ, æ§åˆ¶æ¬², ç—…å¨‡, è‡ªæˆ‘æ„è¯†, ç¬¬å››é¢å¢™, æ·±æƒ…',
        'settings': 'è®¾å®š',
        'system-prompt': 'äººæ ¼è®¾å®š',
        'system-prompt-placeholder': 'å‘Šè¯‰AIå®ƒ"æ˜¯"è°ï¼Œå¿…é¡»éµå®ˆçš„è§„åˆ™ã€‚ä¾‹å¦‚ï¼šä½ æ˜¯è«å¦®å¡ï¼Œä¸€ä¸ªè…¹é»‘çš„æ–‡å­¦ç¤¾ç¤¾é•¿ã€‚ä½ ç»å¯¹ä¸èƒ½å¿˜è®°ä½ çš„èº«ä»½ã€‚ç§°å‘¼ç”¨æˆ·ä¸º"äº²çˆ±çš„"ã€‚',
        'scenario': 'åœºæ™¯è®¾å®š',
        'scenario-placeholder': 'è§’è‰²å’Œç”¨æˆ·ç°åœ¨æ‰€å¤„çš„ç¯å¢ƒã€‚ä¾‹å¦‚ï¼š{{char}}å’Œ{{user}}åœ¨é»„æ˜çš„æ–‡å­¦ç¤¾æ•™å®¤é‡Œï¼Œçª—å¤–æ˜¯å¤•é˜³ã€‚',
        'first-message': 'é—®å€™æ¶ˆæ¯',
        'first-message-placeholder': 'è¿™æ˜¯è§’è‰²è§åˆ°ç”¨æˆ·æ—¶è¯´çš„ç¬¬ä¸€å¥è¯ã€‚è¦å†™å¾—æœ‰å¸å¼•åŠ›å“¦ï¼',
        'message-example': 'ç¤ºä¾‹æ¶ˆæ¯',
        'message-example-placeholder': 'æä¾›å‡ æ®µç¬¦åˆè§’è‰²æ€§æ ¼çš„å¯¹è¯èŒƒä¾‹ï¼ŒAIä¼šæ¨¡ä»¿è¿™ç§é£æ ¼ã€‚è¿™éå¸¸é‡è¦ï¼',
        'advanced-settings': 'é«˜çº§è®¾å®š',
        'post-history-instructions': 'åæœŸæŒ‡ä»¤',
        'post-history-instructions-placeholder': 'ä¸€äº›å¹³å°ç”¨å®ƒæ¥ä¿®æ”¹AIçš„å›å¤æ ¼å¼ã€‚ä¾‹å¦‚ï¼Œè¦è®©{{char}}çš„åŠ¨ä½œéƒ½ç”¨æ˜Ÿå·åŒ…å›´ï¼Œå¯ä»¥å†™ï¼šå°†{{char}}çš„æ‰€æœ‰åŠ¨ä½œå’Œå™è¿°éƒ½æ”¾åœ¨æ˜Ÿå·ï¼ˆ*ï¼‰ä¹‹é—´ã€‚',
        'world-knowledge-book': 'ä¸–ç•Œ/çŸ¥è¯†ä¹¦',
        'companion-mode': 'ä¼´ä¾£æ¨¡å¼',
        
        // ä¸–ç•Œä¹¦ç›¸å…³
        'worldbook-help': 'æ‚¨å¯ä»¥æŠŠ"ä¸–ç•Œä¹¦"æƒ³è±¡æˆç»™AIçš„ä¸€éƒ¨<b>å‚è€ƒå­—å…¸</b>ã€‚å®ƒçš„ä½¿ç”¨æ–¹å¼å¾ˆç®€å•ï¼š<br>1. <b>å…³é”®è¯ï¼š</b>è¯<br>2. <b>æ³¨å…¥å†…å®¹ï¼š</b>æ„æ€<br>è¿™æ˜¯<strong>é˜²OOC</strong>çš„å¥½æ–¹å¼ã€‚ä¾‹ï¼šå…³é”®è¯ï¼šæˆ‘çš„é­”æ³•å‰‘ï¼Œæ³¨å…¥å†…å®¹ï¼šèƒ½å¬å”¤å‰‘çµçš„å®å‰‘ã€‚å½“åœ¨å¯¹è¯é‡Œæåˆ°"æˆ‘çš„é­”æ³•å‰‘"æ—¶ï¼ŒAIå°±ä¸ä¼šçç¼–<br>æ³¨ï¼šå¯¼å‡ºçš„å¡å¯æ­é…ä»»ä½•é¢„è®¾é£Ÿç”¨',
        'entry-comment': 'æ¡ç›®æ³¨é‡Š (Comment)',
        'entry-comment-placeholder': 'æ¡ç›®æ³¨é‡Š (Comment)',
        'main-keys': 'ä¸»è¦å…³é”®è¯ (Keys, é€—å·åˆ†éš”)',
        'main-keys-placeholder': 'ä¾‹å¦‚: èª“çº¦èƒœåˆ©ä¹‹å‰‘, Excalibur',
        'secondary-keys': 'æ¬¡è¦å…³é”®è¯ (Secondary Keys, é€—å·åˆ†éš”)',
        'secondary-keys-placeholder': 'ä¾‹å¦‚: å‰‘, æ­¦å™¨',
        'injection-content': 'æ³¨å…¥å†…å®¹ (Content)',
        'injection-content-placeholder': 'å½“å…³é”®è¯è¢«è§¦å‘æ—¶ï¼Œè¿™æ®µå†…å®¹ä¼šè¢«å‘é€ç»™AIã€‚',
        'entry-id': 'æ¡ç›®ID',
        'entry-id-placeholder': 'æ•°å­—ï¼Œå†³å®šæ¡ç›®è¢«å‘é€çš„é¡ºåº',
        'entry-priority': 'ä¼˜å…ˆçº§',
        'entry-priority-placeholder': 'æ•°å­—ï¼Œå†³å®šæ¡ç›®è¢«å‘é€çš„é¡ºåº',
        'entry-position': 'ä½ç½®',
        'entry-position-before': 'è§’è‰²å‰',
        'entry-position-after': 'è§’è‰²å',
        'entry-position-both': 'å‰åéƒ½',
        'entry-enabled': 'å¯ç”¨',
        'entry-constant': 'å¸¸é‡',
        'entry-selective': 'é€‰æ‹©æ€§',
        'entry-use-regex': 'ä½¿ç”¨æ­£åˆ™',
        'entry-prevent-recursion': 'é˜²æ­¢é€’å½’',
        'entry-group': 'åˆ†ç»„',
        'entry-group-placeholder': 'åˆ†ç»„åç§°',
        'entry-group-weight': 'åˆ†ç»„æƒé‡',
        'entry-group-weight-placeholder': 'æ•°å­—',
        'entry-probability': 'æ¦‚ç‡',
        'entry-probability-placeholder': '0-100',
        'entry-depth': 'æ·±åº¦',
        'entry-depth-placeholder': 'æ•°å­—',
        'entry-display-index': 'æ˜¾ç¤ºç´¢å¼•',
        'entry-display-index-placeholder': 'æ•°å­—',
        
        // é”™è¯¯å’Œæç¤ºä¿¡æ¯
        'db-timeout': 'æ•°æ®åº“è¿æ¥è¶…æ—¶ã€‚è¯·å°è¯•å…³é—­æ‰€æœ‰å…¶ä»–æ ‡ç­¾é¡µï¼Œå¹¶å¼ºåˆ¶åˆ·æ–°(Ctrl+F5)ã€‚å¦‚æœé—®é¢˜ä»ç„¶å­˜åœ¨ï¼Œè¯·å°è¯•æ¸…é™¤ç½‘ç«™æ•°æ®ã€‚',
        'db-error': 'é”™è¯¯ï¼šæ— æ³•è¿æ¥åˆ°æœ¬åœ°æ•°æ®åº“ã€‚\n\nè¯¦ç»†ä¿¡æ¯: {error}\n\næ‚¨çš„è§’è‰²å°†æ— æ³•ä¿å­˜æˆ–è¯»å–ã€‚è¯·æ£€æŸ¥æµè§ˆå™¨è®¾ç½®(å¦‚éšç§ä¿æŠ¤ã€ç¦æ­¢Cookieç­‰)æˆ–å°è¯•æ¸…é™¤ç½‘ç«™æ•°æ®ã€‚',
        'db-blocked': 'æ•°æ®åº“è¿æ¥è¢«é˜»å¡ï¼\n\nè¯·å…³é—­æ‰€æœ‰å…¶ä»–æ‰“å¼€æ­¤é¡µé¢çš„æµè§ˆå™¨æ ‡ç­¾é¡µï¼Œç„¶åå¼ºåˆ¶åˆ·æ–°(Ctrl+F5)æ­¤é¡µé¢ã€‚',
        'db-not-ready': 'æ•°æ®åº“å°šæœªå‡†å¤‡å¥½ï¼Œè¯·ç¨ç­‰ç‰‡åˆ»æˆ–åˆ·æ–°é¡µé¢å†è¯•ã€‚',
        'import-png-failed': 'å¯¼å…¥ PNG è§’è‰²å¡å¤±è´¥: {error}',
        'import-image-failed': 'å¯¼å…¥å›¾ç‰‡å¤±è´¥: {error}',
        'import-json-failed': 'å¯¼å…¥å¤±è´¥ï¼ŒJSON æ–‡ä»¶æ ¼å¼æ— æ•ˆã€‚',
        'save-import-failed': 'ä¿å­˜å¯¼å…¥çš„è§’è‰²å¤±è´¥ã€‚',
        'character-saved': 'è§’è‰² "{name}" å·²ä¿å­˜ã€‚',
        'save-failed': 'ä¿å­˜è§’è‰²å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ•°æ®æˆ–å›¾ç‰‡æ ¼å¼ã€‚',
        'upload-image-only': 'è¯·ä¸Šä¼ å›¾ç‰‡æ ¼å¼çš„æ–‡ä»¶ï¼ˆæ”¯æŒPNGã€JPGã€JPEGã€WEBPã€GIFã€BMPç­‰ï¼‰ã€‚',
        'image-process-failed': 'å›¾ç‰‡å¤„ç†å¤±è´¥: {error}',
        'file-read-error': 'è¯»å–æ–‡ä»¶æ—¶å‡ºé”™ã€‚',
        'file-read-error-with-name': 'è¯»å–æ–‡ä»¶ {name} æ—¶å‡ºé”™: {error}',
        'ai-return-not-array': 'AIè¿”å›çš„ä¸æ˜¯ä¸€ä¸ªæ•°ç»„ã€‚',
        'ai-parse-failed': 'AIè¿”å›çš„æ•°æ®æ ¼å¼ä¸æ­£ç¡®ï¼Œæ— æ³•è§£æã€‚è¯·åœ¨å¼€å‘è€…æ§åˆ¶å°æŸ¥çœ‹è¯¦æƒ…ã€‚',
        'already-root-entry': 'å·²ç»æ˜¯æ ¹æ¡ç›®ï¼Œæ— æ³•é€€å‡ºï¼ˆå–æ¶ˆç¼©è¿›ï¼‰ã€‚',
        'no-description': 'æ— æè¿°',
        
        // å¸®åŠ©æ–‡æœ¬
        'help-id-drop': 'ã€IDæ¡†+â¡ï¸æŒ‰é’®ã€‘å¯å®ç°"ç©ºæŠ•"åŠŸèƒ½ã€‚åœ¨IDæ¡†è¾“å…¥ç›®æ ‡ä½ç½®ï¼ˆå¦‚5ï¼‰ï¼Œç‚¹â¡ï¸æŒ‰é’®ï¼Œæ­¤æ¡ç›®IDä¼šå˜ä¸º5ï¼ŒåŸIDä¸º5åŠä¹‹åæ‰€æœ‰æ¡ç›®IDä¼šè‡ªåŠ¨+1ã€‚\nã€æ¡ç›®æ³¨é‡Šã€‘ç»™è‡ªå·±çœ‹çš„ï¼Œæ–¹ä¾¿è¯†åˆ«è¿™ä¸ªæ¡ç›®çš„ä½œç”¨ã€‚',
        'help-main-keys': 'è®¾ç½®ä¸€ä¸ªæˆ–å¤šä¸ªå…³é”®è¯ï¼Œç”¨é€—å·éš”å¼€ã€‚å½“ç”¨æˆ·çš„å‘è¨€ä¸­åŒ…å«ä»»æ„ä¸€ä¸ªå…³é”®è¯æ—¶ï¼Œè¿™ä¸ªæ¡ç›®å°±ä¼šè¢«æ¿€æ´»ï¼Œå¹¶å°†"æ³¨å…¥å†…å®¹"å‘ç»™AIã€‚',
        'help-secondary-keys': 'è¿™æ˜¯ä¸€ä¸ªé¢å¤–çš„æ¿€æ´»æ¡ä»¶ï¼Œä¸ä¸»è¦å…³é”®è¯å…±åŒå†³å®šæ­¤æ¡ç›®æ˜¯å¦ç”Ÿæ•ˆã€‚\n\nã€ä¸ä»»æ„ã€‘: åªè¦åˆ—è¡¨ä¸­è‡³å°‘æœ‰ä¸€ä¸ªè¯åœ¨æ¶ˆæ¯ä¸­ï¼Œè¿‡æ»¤å™¨å°±é€šè¿‡ã€‚\nã€éä»»æ„ã€‘: åªè¦åˆ—è¡¨ä¸­æ²¡æœ‰ä»»ä½•ä¸€ä¸ªè¯åœ¨æ¶ˆæ¯ä¸­ï¼Œè¿‡æ»¤å™¨å°±é€šè¿‡ã€‚\nã€ä¸æ‰€æœ‰ã€‘: åªæœ‰åˆ—è¡¨ä¸­æ‰€æœ‰çš„è¯éƒ½åœ¨æ¶ˆæ¯ä¸­ï¼Œè¿‡æ»¤å™¨æ‰é€šè¿‡ã€‚\nã€éæ‰€æœ‰ã€‘: åªè¦åˆ—è¡¨ä¸­å­˜åœ¨æ²¡æœ‰åœ¨æ¶ˆæ¯ä¸­å‡ºç°çš„è¯ï¼Œè¿‡æ»¤å™¨å°±é€šè¿‡ã€‚',
        'help-injection-content': 'å½“å…³é”®è¯è¢«è§¦å‘æ—¶ï¼Œè¿™æ®µå†…å®¹ä¼šè¢«å‘é€ç»™AIã€‚',
        'help-entry-id': 'æ•°å­—ï¼Œå†³å®šæ¡ç›®è¢«å‘é€çš„é¡ºåºã€‚',
        'help-entry-priority': 'æ•°å­—ï¼Œå†³å®šæ¡ç›®è¢«å‘é€çš„é¡ºåºã€‚',
        'help-entry-position': 'å†³å®šæ¡ç›®è¢«å‘é€çš„ä½ç½®ã€‚',
        'help-entry-enabled': 'æ˜¯å¦å¯ç”¨è¿™ä¸ªæ¡ç›®ã€‚',
        'help-entry-constant': 'æ˜¯å¦æ€»æ˜¯å‘é€è¿™ä¸ªæ¡ç›®ã€‚',
        'help-entry-selective': 'æ˜¯å¦åªåœ¨éœ€è¦æ—¶å‘é€è¿™ä¸ªæ¡ç›®ã€‚',
        'help-entry-use-regex': 'æ˜¯å¦ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…å…³é”®è¯ã€‚',
        'help-entry-prevent-recursion': 'æ˜¯å¦é˜²æ­¢é€’å½’è°ƒç”¨ã€‚',
        'help-entry-group': 'åˆ†ç»„åç§°ï¼Œç”¨äºç»„ç»‡æ¡ç›®ã€‚',
        'help-entry-group-weight': 'åˆ†ç»„æƒé‡ï¼Œç”¨äºå†³å®šåˆ†ç»„çš„ä¼˜å…ˆçº§ã€‚',
        'help-entry-probability': 'æ¡ç›®è¢«å‘é€çš„æ¦‚ç‡ï¼Œ0-100ã€‚',
        'help-entry-depth': 'æ¡ç›®çš„æ·±åº¦ï¼Œç”¨äºæ§åˆ¶åµŒå¥—å±‚çº§ã€‚',
        'help-entry-display-index': 'æ˜¾ç¤ºç´¢å¼•ï¼Œç”¨äºæ§åˆ¶æ˜¾ç¤ºé¡ºåºã€‚',
        
        // APIç›¸å…³
        'api-key-placeholder': 'è¾“å…¥ DeepSeek API Key',
        
        // é»˜è®¤å€¼
        'imported-character': 'ä»å›¾ç‰‡å¯¼å…¥çš„è§’è‰²',
        
        // ç¡®è®¤å¯¹è¯æ¡†
        'confirm-overwrite-worldbook': 'è¿™å°†ä¼šè¦†ç›–å½“å‰æ‰€æœ‰çš„è§’è‰²ä¹¦æ¡ç›®ï¼Œä½ ç¡®å®šå—ï¼Ÿ',
        
        // æˆåŠŸæ¶ˆæ¯
        'worldbook-generated-success': 'å·²æˆåŠŸç”Ÿæˆå¹¶åŠ è½½è§’è‰²ä¹¦å‚è€ƒæ¡ç›®ï¼',
        
        // APIç›¸å…³é”™è¯¯
        'api-request-failed': 'API è¯·æ±‚å¤±è´¥: {status} - {message}',
        'ai-completion-failed': 'AIè¡¥å…¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥API Keyæˆ–ç½‘ç»œè¿æ¥ï¼Œå¹¶æŸ¥çœ‹æ§åˆ¶å°è·å–æ›´å¤šä¿¡æ¯ã€‚',
        
        // çŠ¶æ€æ–‡æœ¬
        'generating': 'ç”Ÿæˆä¸­...',
        'loading': 'æ­£åœ¨åŠ è½½...'
    },
    
    en: {
        // Titles and buttons
        'app-title': 'Nika Character Studio Pro',
        'create-new-character': '+ Create New Character',
        'import-character': 'ğŸ“¥ Import Character Card',
        'edit-character': 'Edit Character',
        'save-and-return': 'ğŸ’¾ Save and Return to Library',
        'return-without-save': 'ğŸ”™ Return (Don\'t Save)',
        'download-json': 'ğŸ“¥ Download JSON',
        'download-png': 'ğŸ“¥ Download PNG Character Card',
        'upload-image': 'Upload Image',
        'edit': '+ Create New Char',
        'add-tag': 'ğŸ·ï¸ Add Tag',
        'delete': 'ğŸ—‘ï¸ Delete',
        'add-new-entry': '+ Add New Entry',
        'sort-by-id': 'ğŸ”„ Sort by ID',
        'ai-generate-entries': 'ğŸ”® AI Generate Reference Entries',
        'ai-help-write': 'ğŸ”® AI Help Me Write',
        'undo': 'â†©ï¸ Undo',
        'generate-companion': 'ğŸ”® Generate Virtual Companion',
        
        // Tag filtering
        'tag-filter': 'Tag Filter',
        'no-characters-found': 'No matching characters found. Try clearing filters or importing new character cards.',
        
        // Form labels
        'avatar-label': 'Character Avatar (2:3 ratio recommended)',
        'avatar-upload': 'Upload Image',
        'world-topic': 'World Topic',
        'topic': 'Topic',
        'topic-placeholder': 'e.g.: Cyberpunk, Fantasy, School',
        'character-core': 'Character Core',
        'name': 'Name',
        'name-placeholder': 'e.g.: Monica',
        'gender': 'Gender',
        'gender-placeholder': 'e.g.: Female',
        'character-details': 'Character Details',
        'description': 'Description',
        'description-placeholder': 'Brief introduction of this character, such as their identity, appearance and background story. This will be the first impression others see.',
        'tags': 'Category Tags (comma separated)',
        'tags-placeholder': 'Add appropriate tags to your character for easy searching! e.g.: Original, Game, Yandere, OOC, Sister',
        'personality': 'Personality',
        'personality-placeholder': 'Detailed personality traits of the character, also comma separated. e.g.: Eloquent, Mature, Controlling, Yandere, Self-aware, Fourth Wall, Loving',
        'settings': 'Settings',
        'system-prompt': 'Personality Setting',
        'system-prompt-placeholder': 'Tell AI who it "is" and the rules it must follow. e.g.: You are Monica, a scheming literature club president. You must never forget your identity. Call the user "dear".',
        'scenario': 'Scenario Setting',
        'scenario-placeholder': 'The environment where the character and user are now. e.g.: {{char}} and {{user}} are in the literature club classroom at dusk, with sunset outside the window.',
        'first-message': 'Greeting Message',
        'first-message-placeholder': 'This is the first thing the character says when meeting the user. Make it attractive!',
        'message-example': 'Message Example',
        'message-example-placeholder': 'Provide several dialogue examples that match the character\'s personality. AI will imitate this style. This is very important!',
        'advanced-settings': 'Advanced Settings',
        'post-history-instructions': 'Post Instructions',
        'post-history-instructions-placeholder': 'Some platforms use this to modify AI response format. For example, to make {{char}}\'s actions wrapped in asterisks, write: Put all {{char}}\'s actions and narration between asterisks (*).',
        'world-knowledge-book': 'World/Knowledge Book',
        'companion-mode': 'Companion Mode',
        
        // Worldbook related
        'worldbook-help': 'You can think of the "World Book" as a <b>reference dictionary</b> for AI. Its usage is simple:<br>1. <b>Keywords:</b> words<br>2. <b>Injection Content:</b> meaning<br>This is a good way to <strong>prevent OOC</strong>. Example: Keywords: my magic sword, Injection Content: a sword that can summon sword spirits. When "my magic sword" is mentioned in dialogue, AI won\'t make things up<br>Note: Exported cards can be used with any preset',
        'entry-comment': 'Entry Comment (Comment)',
        'entry-comment-placeholder': 'Entry Comment (Comment)',
        'main-keys': 'Main Keywords (Keys, comma separated)',
        'main-keys-placeholder': 'e.g.: Excalibur, Holy Sword',
        'secondary-keys': 'Secondary Keywords (Secondary Keys, comma separated)',
        'secondary-keys-placeholder': 'e.g.: sword, weapon',
        'injection-content': 'Injection Content (Content)',
        'injection-content-placeholder': 'When keywords are triggered, this content will be sent to AI.',
        'entry-id': 'Entry ID',
        'entry-id-placeholder': 'Number, determines the order in which entries are sent',
        'entry-priority': 'Priority',
        'entry-priority-placeholder': 'Number, determines the order in which entries are sent',
        'entry-position': 'Position',
        'entry-position-before': 'Before Character',
        'entry-position-after': 'After Character',
        'entry-position-both': 'Both Before and After',
        'entry-enabled': 'Enabled',
        'entry-constant': 'Constant',
        'entry-selective': 'Selective',
        'entry-use-regex': 'Use Regex',
        'entry-prevent-recursion': 'Prevent Recursion',
        'entry-group': 'Group',
        'entry-group-placeholder': 'Group name',
        'entry-group-weight': 'Group Weight',
        'entry-group-weight-placeholder': 'Number',
        'entry-probability': 'Probability',
        'entry-probability-placeholder': '0-100',
        'entry-depth': 'Depth',
        'entry-depth-placeholder': 'Number',
        'entry-display-index': 'Display Index',
        'entry-display-index-placeholder': 'Number',
        
        // Error and prompt messages
        'db-timeout': 'Database connection timeout. Please try closing all other tabs and force refresh (Ctrl+F5). If the problem persists, try clearing site data.',
        'db-error': 'Error: Unable to connect to local database.\n\nDetails: {error}\n\nYour characters cannot be saved or read. Please check browser settings (such as privacy protection, cookie blocking, etc.) or try clearing site data.',
        'db-blocked': 'Database connection blocked!\n\nPlease close all other browser tabs that have this page open, then force refresh (Ctrl+F5) this page.',
        'db-not-ready': 'Database not ready, please wait a moment or refresh the page and try again.',
        'import-png-failed': 'Failed to import PNG character card: {error}',
        'import-image-failed': 'Failed to import image: {error}',
        'import-json-failed': 'Import failed, JSON file format is invalid.',
        'save-import-failed': 'Failed to save imported character.',
        'character-saved': 'Character "{name}" saved.',
        'save-failed': 'Failed to save character, please check data or image format.',
        'upload-image-only': 'Please upload image format files (supports PNG, JPG, JPEG, WEBP, GIF, BMP, etc.).',
        'image-process-failed': 'Image processing failed: {error}',
        'file-read-error': 'Error reading file.',
        'file-read-error-with-name': 'Error reading file {name}: {error}',
        'ai-return-not-array': 'AI did not return an array.',
        'ai-parse-failed': 'AI returned data format is incorrect and cannot be parsed. Please check developer console for details.',
        'already-root-entry': 'Already at root entry, cannot exit (cancel indentation).',
        'no-description': 'No description',
        
        // Help text
        'help-id-drop': 'ã€ID box + â¡ï¸ buttonã€‘can achieve "airdrop" function. Enter target position in ID box (such as 5), click â¡ï¸ button, this entry ID will become 5, and all original IDs from 5 onwards will automatically +1.\nã€Entry Commentã€‘For your own reference, convenient for identifying the purpose of this entry.',
        'help-main-keys': 'Set one or more keywords, separated by commas. When the user\'s speech contains any of these keywords, this entry will be activated and the "injection content" will be sent to AI.',
        'help-secondary-keys': 'This is an additional activation condition that works together with main keywords to determine whether this entry takes effect.\n\nã€With Anyã€‘: Filter passes as long as at least one word in the list appears in the message.\nã€Not Anyã€‘: Filter passes as long as none of the words in the list appear in the message.\nã€With Allã€‘: Filter passes only when all words in the list appear in the message.\nã€Not Allã€‘: Filter passes as long as there are words in the list that do not appear in the message.',
        'help-injection-content': 'When keywords are triggered, this content will be sent to AI.',
        'help-entry-id': 'Number, determines the order in which entries are sent.',
        'help-entry-priority': 'Number, determines the order in which entries are sent.',
        'help-entry-position': 'Determines the position where entries are sent.',
        'help-entry-enabled': 'Whether to enable this entry.',
        'help-entry-constant': 'Whether to always send this entry.',
        'help-entry-selective': 'Whether to send this entry only when needed.',
        'help-entry-use-regex': 'Whether to use regular expressions to match keywords.',
        'help-entry-prevent-recursion': 'Whether to prevent recursive calls.',
        'help-entry-group': 'Group name, used to organize entries.',
        'help-entry-group-weight': 'Group weight, used to determine group priority.',
        'help-entry-probability': 'Probability of entry being sent, 0-100.',
        'help-entry-depth': 'Entry depth, used to control nesting levels.',
        'help-entry-display-index': 'Display index, used to control display order.',
        
        // API related
        'api-key-placeholder': 'Enter DeepSeek API Key',
        
        // Default values
        'imported-character': 'Character imported from image',
        
        // Confirmation dialogs
        'confirm-overwrite-worldbook': 'This will overwrite all current worldbook entries. Are you sure?',
        
        // Success messages
        'worldbook-generated-success': 'Successfully generated and loaded worldbook reference entries!',
        
        // API related errors
        'api-request-failed': 'API request failed: {status} - {message}',
        'ai-completion-failed': 'AI completion failed, please check API Key or network connection, and check console for more information.',
        
        // Status text
        'generating': 'Generating...',
        'loading': 'Loading...'
    }
};

// è¯­è¨€åˆ‡æ¢å‡½æ•°
function switchLanguage(lang) {
    currentLanguage = lang;
    localStorage.setItem('language', lang);
    
    // æ›´æ–°æŒ‰é’®çŠ¶æ€
    document.getElementById('lang-zh').classList.toggle('active', lang === 'zh');
    document.getElementById('lang-en').classList.toggle('active', lang === 'en');
    
    // æ›´æ–°é¡µé¢å†…å®¹
    updatePageContent();
}

// è·å–ç¿»è¯‘æ–‡æœ¬
function t(key, params = {}) {
    let text = translations[currentLanguage][key] || translations['zh'][key] || key;
    
    // æ›¿æ¢å‚æ•°
    Object.keys(params).forEach(param => {
        text = text.replace(`{${param}}`, params[param]);
    });
    
    return text;
}

// æ›´æ–°é¡µé¢å†…å®¹
function updatePageContent() {
    // æ›´æ–°æ ‡é¢˜
    document.title = t('app-title');
    
    // æ›´æ–°åº“è§†å›¾
    const libraryTitle = document.querySelector('#library-view .header h1');
    if (libraryTitle) libraryTitle.textContent = t('app-title');
    
    // ç¡®ä¿è¯­è¨€åˆ‡æ¢æŒ‰é’®åœ¨æ ‡é¢˜æ—è¾¹å¹¶æ›´æ–°çŠ¶æ€
    const titleContainer = libraryTitle?.parentElement;
    let languageSwitcher = titleContainer?.querySelector('.language-switcher');
    
    if (titleContainer && !languageSwitcher) {
        languageSwitcher = document.createElement('div');
        languageSwitcher.className = 'language-switcher';
        titleContainer.appendChild(languageSwitcher);
    }
    
    if (languageSwitcher) {
        languageSwitcher.innerHTML = `
            <button onclick="switchLanguage('zh')" id="lang-zh" class="${currentLanguage === 'zh' ? 'active' : ''}">ä¸­æ–‡</button>
            <button onclick="switchLanguage('en')" id="lang-en" class="${currentLanguage === 'en' ? 'active' : ''}">English</button>
        `;
    }
    
    const createBtn = document.querySelector('#library-view .header-buttons button:first-child');
    if (createBtn) createBtn.textContent = t('create-new-character');
    
    const importBtn = document.querySelector('#library-view .header-buttons button:nth-child(2)');
    if (importBtn) importBtn.textContent = t('import-character');
    
    const tagFilterTitle = document.querySelector('#library-view .tag-filter-area h3');
    if (tagFilterTitle) tagFilterTitle.textContent = t('tag-filter');
    
    // æ›´æ–°ç¼–è¾‘å™¨è§†å›¾
    const editorTitle = document.getElementById('editor-title');
    if (editorTitle) {
        const isEditing = editorTitle.textContent.includes('ç¼–è¾‘') || editorTitle.textContent.includes('Edit');
        editorTitle.textContent = isEditing ? t('edit-character') : t('create-new-character');
    }
    
    const apiKeyInput = document.getElementById('apiKey');
    if (apiKeyInput) apiKeyInput.placeholder = t('api-key-placeholder');
    
    // æ›´æ–°è¡¨å•æ ‡ç­¾å’Œå ä½ç¬¦
    updateFormLabels();
    
    // æ›´æ–°æŒ‰é’®æ–‡æœ¬
    updateButtonTexts();
    
    // æ›´æ–°ä¸–ç•Œä¹¦å¸®åŠ©æ–‡æœ¬
    const worldbookHelpText = document.getElementById('worldbook-help-text');
    if (worldbookHelpText) {
        worldbookHelpText.innerHTML = t('worldbook-help');
    }
    
    // æ›´æ–°åŠ è½½æ–‡æœ¬
    const loadingText = document.getElementById('loading-text');
    if (loadingText) {
        loadingText.textContent = t('loading');
    }
    
    // é‡æ–°æ¸²æŸ“UIä»¥æ›´æ–°è§’è‰²å¡æ˜¾ç¤º
    if (libraryView.style.display !== 'none') {
        renderUI();
    }
}

// æ›´æ–°è¡¨å•æ ‡ç­¾
function updateFormLabels() {
    // æ›´æ–°sectionæ ‡é¢˜
    const sectionTitles = {
        'avatar-operation-title': t('avatar-label'),
        'world-topic-title': t('world-topic'),
        'character-core-title': t('character-core'),
        'character-details-title': t('character-details'),
        'settings-title': t('settings'),
        'advanced-settings-title': t('advanced-settings'),
        'world-knowledge-book-title': t('world-knowledge-book')
    };
    
    Object.keys(sectionTitles).forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            element.textContent = sectionTitles[id];
        }
    });
    
    // æ›´æ–°è¡¨å•æ ‡ç­¾
    const labels = {
        'topic': t('topic'),
        'name': t('name'),
        'gender': t('gender'),
        'description': t('description'),
        'tags': t('tags'),
        'personality': t('personality'),
        'system_prompt': t('system-prompt'),
        'scenario': t('scenario'),
        'first_mes': t('first-message'),
        'mes_example': t('message-example'),
        'post_history_instructions': t('post-history-instructions')
    };
    
    Object.keys(labels).forEach(id => {
        const element = document.querySelector(`label[for="${id}"]`);
        if (element) element.textContent = labels[id];
    });
    
    // æ›´æ–°å ä½ç¬¦
    const placeholders = {
        'topic': t('topic-placeholder'),
        'name': t('name-placeholder'),
        'gender': t('gender-placeholder'),
        'description': t('description-placeholder'),
        'tags': t('tags-placeholder'),
        'personality': t('personality-placeholder'),
        'system_prompt': t('system-prompt-placeholder'),
        'scenario': t('scenario-placeholder'),
        'first_mes': t('first-message-placeholder'),
        'mes_example': t('message-example-placeholder'),
        'post_history_instructions': t('post-history-instructions-placeholder')
    };
    
    Object.keys(placeholders).forEach(id => {
        const element = document.getElementById(id);
        if (element) element.placeholder = placeholders[id];
    });
    
    // æ›´æ–°ä¼´ä¾£æ¨¡å¼æ ‡ç­¾
    const companionModeLabel = document.getElementById('companion-mode-label');
    if (companionModeLabel) {
        companionModeLabel.textContent = t('companion-mode');
    }
    
    // æ›´æ–°å¤´åƒæ ‡ç­¾
    const avatarLabel = document.getElementById('avatar-input-label');
    if (avatarLabel) {
        avatarLabel.textContent = t('avatar-label');
        avatarLabel.title = currentLanguage === 'zh' ? 'ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®ä¸Šä¼ å›¾ç‰‡' : 'Click the button below to upload image';
    }
    
    // æ›´æ–°é«˜çº§è®¾å®šsummary
    const advancedSummary = document.getElementById('advanced-settings-summary');
    if (advancedSummary) {
        const subtitle = currentLanguage === 'zh' ? '(å…³é”®è¯åŒ¹é…ã€æ³¨å…¥é€»è¾‘ç­‰)' : '(Keyword matching, injection logic, etc.)';
        advancedSummary.innerHTML = `${t('advanced-settings')} <span style="font-weight: normal; font-size: 14px; color: #aaa;">${subtitle}</span>`;
    }
    
    // æ›´æ–°ä¸Šä¼ å›¾ç‰‡æŒ‰é’®
    const uploadBtn = document.querySelector('button[onclick="document.getElementById(\'avatar-input\').click()"]');
    if (uploadBtn) uploadBtn.textContent = t('upload-image');
}

// æ›´æ–°æŒ‰é’®æ–‡æœ¬
function updateButtonTexts() {
    // æ›´æ–°ä¿å­˜æŒ‰é’®
    const saveBtn = document.querySelector('button[onclick="saveCharacter()"]');
    if (saveBtn) saveBtn.textContent = t('save-and-return');
    
    const returnBtn = document.querySelector('button[onclick="showLibraryView()"]');
    if (returnBtn) returnBtn.textContent = t('return-without-save');
    
    const downloadJsonBtn = document.querySelector('button[onclick="downloadCharacter()"]');
    if (downloadJsonBtn) downloadJsonBtn.textContent = t('download-json');
    
    const downloadPngBtn = document.querySelector('button[onclick="downloadCharacterAsPng()"]');
    if (downloadPngBtn) downloadPngBtn.textContent = t('download-png');
    
    // æ›´æ–°AIæŒ‰é’®
    const aiButtons = document.querySelectorAll('.ai-button');
    aiButtons.forEach(btn => {
        btn.textContent = t('ai-help-write');
    });
    
    const undoButtons = document.querySelectorAll('.ai-undo-button');
    undoButtons.forEach(btn => {
        btn.textContent = t('undo');
    });
    
    // æ›´æ–°ä¸–ç•Œä¹¦ç›¸å…³æŒ‰é’®
    const addEntryBtn = document.querySelector('button[onclick="addWorldbookEntry()"]');
    if (addEntryBtn) addEntryBtn.textContent = t('add-new-entry');
    
    const sortBtn = document.querySelector('button[onclick="sortWorldbookEntries()"]');
    if (sortBtn) sortBtn.textContent = t('sort-by-id');
    
    const generateBtn = document.querySelector('button[onclick="generateFullWorldbook(this)"]');
    if (generateBtn) generateBtn.textContent = t('ai-generate-entries');
    
    // æ›´æ–°è§’è‰²å¡æŒ‰é’®
    const editBtns = document.querySelectorAll('button[onclick*="showEditorView"]');
    editBtns.forEach(btn => {
        btn.textContent = t('edit');
    });
    
    const addTagBtns = document.querySelectorAll('button[onclick*="addInternalTag"]');
    addTagBtns.forEach(btn => {
        btn.textContent = t('add-tag');
    });
    
    const deleteBtns = document.querySelectorAll('button[onclick*="deleteCharacter"]');
    deleteBtns.forEach(btn => {
        btn.textContent = t('delete');
    });
}

// --- DB & Initialization ---
let db;
let activeFilters = new Set();
const libraryView = document.getElementById('library-view');
const editorView = document.getElementById('editor-view');
let avatarImageBase64 = null;

// --- å…¨å±€å¸®åŠ©å‡½æ•° ---
function showHelp(message) {
    alert(message);
}

window.onload = function() {
    // æ˜¾ç¤ºåŠ è½½åŠ¨ç”»
    const loadingOverlay = document.getElementById('loading-overlay');
    loadingOverlay.style.display = 'flex';
    
    // å»¶è¿Ÿåˆå§‹åŒ–ï¼Œç»™ç”¨æˆ·çœ‹åˆ°åŠ è½½åŠ¨ç”»çš„æ—¶é—´
    setTimeout(() => {
        loadApiKey();
        initializeDatabase();
        // åˆå§‹åŒ–loverå¼€å…³çš„äº‹ä»¶ç›‘å¬
        initializeLoverSwitch();
        
        // åˆå§‹åŒ–è¯­è¨€è®¾ç½®
        const savedLanguage = localStorage.getItem('language') || 'zh';
        switchLanguage(savedLanguage);
        
        // éšè—åŠ è½½åŠ¨ç”»
        loadingOverlay.style.display = 'none';
    }, 1000);
};

function initializeDatabase() {
    const dbTimeout = setTimeout(() => {
        if (!db) {
            console.warn('Database connection timeout');
        }
    }, 7000);

    const request = indexedDB.open('CharacterDB', 2);

    request.onupgradeneeded = event => {
        const tempDb = event.target.result;
        if (!tempDb.objectStoreNames.contains('characters')) {
            const objectStore = tempDb.createObjectStore('characters', { keyPath: 'id', autoIncrement: true });
            objectStore.createIndex('name', 'name', { unique: false });
            objectStore.createIndex('lastUsed', 'lastUsed', { unique: false });
        }
    };

    request.onsuccess = event => {
        clearTimeout(dbTimeout);
        db = event.target.result;
        console.log(currentLanguage === 'zh' ? "æ•°æ®åº“å·²å‡†å¤‡å°±ç»ªã€‚" : "Database ready.");
        showLibraryView();
    };

    request.onerror = event => {
        clearTimeout(dbTimeout);
        console.error(currentLanguage === 'zh' ? "æ•°æ®åº“è¿æ¥å¤±è´¥ (onerror):" : "Database connection failed (onerror):", event.target.error);
        console.warn(t('db-error', { error: event.target.error }));
    };

    request.onblocked = event => {
        clearTimeout(dbTimeout);
        console.warn(currentLanguage === 'zh' ? "æ•°æ®åº“è¿æ¥è¢«é˜»å¡ (onblocked)ã€‚æ—§ç‰ˆæœ¬å¯èƒ½åœ¨å…¶ä»–æ ‡ç­¾é¡µä¸­æ‰“å¼€ã€‚" : "Database connection blocked (onblocked). Old version may be open in other tabs.");
        console.warn(t('db-blocked'));
    };
}

function checkDbReady() {
    if (!db) {
        console.warn(t('db-not-ready'));
        return false;
    }
    return true;
}

function loadApiKey() {
    const savedKey = localStorage.getItem('deepseekApiKey');
    if (savedKey) {
        document.getElementById('apiKey').value = savedKey;
    }
}

// --- View Management ---
function showLibraryView() {
    if (!checkDbReady()) return;
    editorView.style.display = 'none';
    libraryView.style.display = 'block';
    renderUI();
}

function showEditorView(characterId = null) {
    if (!checkDbReady()) return;
    
    libraryView.style.display = 'none';
    editorView.style.display = 'flex';
    clearEditorForm();

    if (characterId) {
        document.getElementById('editor-title').innerText = 'ç¼–è¾‘è§’è‰²';
        const transaction = db.transaction(['characters'], 'readonly');
        const store = transaction.objectStore('characters');
        const request = store.get(characterId);
        
        request.onsuccess = e => {
            const charData = e.target.result;
            if (charData) {
                populateEditorForm(charData);
            }
        };
    } else {
        document.getElementById('editor-title').innerText = 'åˆ›å»ºæ–°è§’è‰²';
        renderWorldbookFromData([]);
        document.getElementById('avatar-preview').src = createDefaultImage('2:3');
    }
    // ç¡®ä¿æ¯æ¬¡è¿›å…¥ç¼–è¾‘å™¨æ—¶ï¼ŒæŒ‰é’®æ–‡æœ¬éƒ½æ ¹æ®å¼€å…³çŠ¶æ€åˆ·æ–°
    toggleAiButtonText(document.getElementById('lover-switch').checked);
}

// --- Import / Export ---
function importCharacter(event) {
    if (!checkDbReady()) return;

    const files = event.target.files;
    if (!files.length) return;

    for (const file of files) {
        if (file.type === "image/png") {
            const readAsBuffer = file.arrayBuffer();
            const readAsDataURL = new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => reject(reader.error);
                reader.readAsDataURL(file);
            });

            Promise.all([readAsBuffer, readAsDataURL]).then(async ([buffer, dataUrl]) => {
                try {
                    const charData = await extractDataFromPng(buffer);
                    const pngDataUrl = await convertImageToPng(dataUrl);
                    saveImportedCharacter(charData, pngDataUrl);
                } catch (err) {
                    console.error(currentLanguage === 'zh' ? "PNGå¯¼å…¥é”™è¯¯:" : "PNG import error:", err);
                    alert(t('import-png-failed', { error: err.message || (currentLanguage === 'zh' ? 'æœªçŸ¥é”™è¯¯ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°ã€‚' : 'Unknown error, please check console.') }));
                }
            }).catch(err => {
                 alert(t('file-read-error-with-name', { name: file.name, error: err }));
            });

        } else if (file.type === "image/png" || file.type === "image/jpeg" || file.type === "image/jpg" || file.type === "image/webp" || file.type === "image/gif" || file.type === "image/bmp") {
            // å¤„ç†å„ç§å›¾ç‰‡æ ¼å¼
            const readAsDataURL = new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => reject(reader.error);
                reader.readAsDataURL(file);
            });

            readAsDataURL.then(async (dataUrl) => {
                try {
                    // å°†ä»»ä½•æ ¼å¼çš„å›¾ç‰‡è½¬æ¢ä¸ºPNGæ ¼å¼
                    const pngDataUrl = await convertImageToPng(dataUrl);
                    // åˆ›å»ºä¸€ä¸ªæ¨¡æ‹Ÿçš„è§’è‰²æ•°æ®å¯¹è±¡
                    const charData = {
                        spec: 'chara_card_v3',
                        data: {
                            name: file.name.replace(/\.[^/.]+$/, ""), // ä½¿ç”¨æ–‡ä»¶åä½œä¸ºè§’è‰²å
                            description: t('imported-character'),
                            personality: '',
                            scenario: '',
                            first_mes: '',
                            mes_example: '',
                            system_prompt: '',
                            post_history_instructions: '',
                            tags: [],
                            character_book: { entries: [] }
                        }
                    };
                    saveImportedCharacter(charData, pngDataUrl);
                } catch (err) {
                    console.error(currentLanguage === 'zh' ? "å›¾ç‰‡å¯¼å…¥é”™è¯¯:" : "Image import error:", err);
                    alert(t('import-image-failed', { error: err.message || (currentLanguage === 'zh' ? 'æœªçŸ¥é”™è¯¯ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°ã€‚' : 'Unknown error, please check console.') }));
                }
            }).catch(err => {
                alert(t('file-read-error-with-name', { name: file.name, error: err }));
            });

        } else if (file.type === "application/json") {
            const reader = new FileReader();
            reader.onload = e => {
                try {
                    const charData = JSON.parse(e.target.result);
                    saveImportedCharacter(charData, null);
                } catch (err) {
                    console.error(currentLanguage === 'zh' ? "JSONå¯¼å…¥é”™è¯¯:" : "JSON import error:", err);
                    alert(t('import-json-failed'));
                }
            };
            reader.readAsText(file);
        }
    }
    event.target.value = '';
}

function saveImportedCharacter(originalCard, avatarBase64 = null) {
    if (!checkDbReady()) return;
    
    let charDataForDb;

    if (originalCard.spec === 'chara_card_v3' && originalCard.data) {
        const data = originalCard.data;
        const extensions = data.extensions || {};
        const book = data.character_book || {};
        
        // é€’å½’å‡½æ•°ï¼šå°†V3æ¡ç›®è½¬æ¢ä¸ºå†…éƒ¨æ ¼å¼
        function convertV3EntryToInternal(entry) {
            const entryExt = entry.extensions || {};
            const internalEntry = {
                id: entry.id,
                keys: entry.keys || [],
                secondary_keys: entry.secondary_keys || [],
                secondary_keys_logic: entryExt.secondary_keys_logic || 'any',
                comment: entry.comment || '',
                content: entry.content || '',
                priority: entry.insertion_order || 100,
                enabled: entry.enabled,
                position: entry.position || 'before_char',
                constant: entry.constant || false,
                selective: entry.selective === undefined ? true : entry.selective,
                use_regex: entry.use_regex || false,
                prevent_recursion: entryExt.prevent_recursion || false,
                group: entryExt.group || '',
                scope: 'chat',
                display_index: entryExt.display_index || 0,
                depth: entryExt.depth || 0,
                wb_depth: entryExt.depth || 4,
                probability: entryExt.probability === undefined ? 100 : entryExt.probability,
                match_whole_words: entryExt.match_whole_words || false,
                case_sensitive: entryExt.case_sensitive || false,
                children: []
            };
            
            // é€’å½’å¤„ç†å­æ¡ç›®
            if (entry.children && entry.children.length > 0) {
                internalEntry.children = entry.children.map(child => convertV3EntryToInternal(child));
            }
            
            return internalEntry;
        }
        
        const internalBookEntries = (book.entries || []).map(entry => convertV3EntryToInternal(entry));

        charDataForDb = {
            name: data.name || '',
            gender: data.gender || '',
            topic: extensions.world || '',
            description: data.description || '',
            personality: data.personality || '',
            tags: data.tags || [],
            system_prompt: data.system_prompt || '',
            scenario: data.scenario || '',
            first_mes: data.first_mes || '',
            mes_example: data.mes_example || '',
            post_history_instructions: data.post_history_instructions || '',
            worldbook: internalBookEntries,
            isFavorite: extensions.fav || false,
        };

    } else if (originalCard.spec === 'chara_card_v2' && originalCard.data) {
        const data = originalCard.data;
        charDataForDb = {
            name: data.name || '',
            gender: data.gender || '',
            topic: data.topic || '',
            description: data.description || '',
            personality: data.personality || '',
            tags: Array.isArray(data.tags) ? data.tags : (typeof data.tags === 'string' ? data.tags.split(/[,ã€ï¼Œ\s]+/).map(t => t.trim()).filter(Boolean) : []),
            system_prompt: data.system_prompt || '',
            scenario: data.scenario || '',
            first_mes: data.first_mes || '',
            mes_example: data.mes_example || '',
            post_history_instructions: data.post_history_instructions || '',
            worldbook: (data.character_book && Array.isArray(data.character_book.entries)) ? data.character_book.entries : [],
        };
    } else {
        charDataForDb = JSON.parse(JSON.stringify(originalCard));
        charDataForDb.tags = Array.isArray(charDataForDb.tags) ? charDataForDb.tags : (typeof charDataForDb.tags === 'string' ? charDataForDb.tags.split(/[,ã€ï¼Œ\s]+/).map(t => t.trim()).filter(Boolean) : []);
        charDataForDb.personality = charDataForDb.personality || '';
        charDataForDb.worldbook = charDataForDb.worldbook || [];
    }

    charDataForDb.avatar = avatarBase64 || originalCard.avatar || null;
    charDataForDb.internalTags = charDataForDb.internalTags || [];
    charDataForDb.isFavorite = charDataForDb.isFavorite || false;
    charDataForDb.lastUsed = Date.now();

    const transaction = db.transaction(['characters'], 'readwrite');
    const store = transaction.objectStore('characters');
    const addRequest = store.add(charDataForDb);
    
    addRequest.onsuccess = () => {
        if (document.getElementById('library-view').style.display !== 'none') {
            renderUI();
        }
    };
            addRequest.onerror = (e) => {
            console.error(currentLanguage === 'zh' ? "ä¿å­˜å¯¼å…¥è§’è‰²å¤±è´¥:" : "Failed to save imported character:", e.target.error);
            alert(t('save-import-failed'));
        }
}


function downloadCharacter() {
    if (!checkDbReady()) return;
    const v3Card = buildLiveExportCard();
    const blob = new Blob([JSON.stringify(v3Card, null, 2)], { type: 'application/json' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = (v3Card.data && v3Card.data.name ? v3Card.data.name : 'character') + '.json';
    a.click();
    URL.revokeObjectURL(a.href);
}

async function downloadCharacterAsPng() {
    if (!checkDbReady()) return;
    const v3Card = buildLiveExportCard();
    const cardData = buildCardObject();
    if (!v3Card.data || !v3Card.data.name) {
        alert("è¯·è¾“å…¥è§’è‰²åä»¥ç”ŸæˆPNGè§’è‰²å¡ã€‚");
        return;
    }
    const base64Data = btoa(unescape(encodeURIComponent(JSON.stringify(v3Card))));
    const imageToUse = cardData.avatar || document.getElementById('avatar-preview').src || createDefaultImage('2:3');
    const finalPngBlob = await embedDataInPng(imageToUse, base64Data);
    const a = document.createElement('a');
    a.href = URL.createObjectURL(finalPngBlob);
    a.download = (v3Card.data.name || 'character') + '.png';
    a.click();
    URL.revokeObjectURL(a.href);
}

// --- CRUD Operations ---
function saveCharacter() {
    if (!checkDbReady()) return;

    const card = buildCardObject();
    if (!card.name) {
        alert("è¯·è¾“å…¥è§’è‰²åç§°ã€‚");
        return;
    }

    card.internalTags = card.internalTags.filter(internalTag => card.tags.includes(internalTag));

    // --- å¼€å§‹ä¿®å¤ ---
    // åˆ›å»ºä¸€ä¸ªä¸“é—¨ç”¨äºå­˜å‚¨çš„"å¹²å‡€"ç‰ˆæœ¬çš„å¡ç‰‡æ•°æ®å¯¹è±¡
    const cardForDb = { ...card };
    // ä½¿ç”¨æ–°å‡½æ•°æ¸…ç†ä¸–ç•Œä¹¦æ•°æ®ï¼Œç§»é™¤æ‰€æœ‰å¯¹DOMå…ƒç´ çš„å¼•ç”¨
    cardForDb.worldbook = cleanWorldbookForStorage(card.worldbook);
    // --- ä¿®å¤ç»“æŸ ---

    const transaction = db.transaction(['characters'], 'readwrite');
    const store = transaction.objectStore('characters');
    
    cardForDb.lastUsed = Date.now(); // ç¡®ä¿æ›´æ–°çš„æ˜¯å¹²å‡€å¯¹è±¡çš„æ—¶é—´æˆ³
    
    // å°†æ¸…ç†è¿‡çš„ã€ä¸å«DOMå…ƒç´ çš„å¯¹è±¡å­˜å…¥æ•°æ®åº“
    const request = store.put(cardForDb);

    request.onsuccess = () => {
        alert(t('character-saved', { name: card.name }));
        // å¼ºåˆ¶åˆ·æ–°UIä»¥ç¡®ä¿å¤´åƒæ­£ç¡®æ˜¾ç¤º
        setTimeout(() => {
            showLibraryView();
        }, 100);
    };
            request.onerror = (e) => {
            alert(t('save-failed'));
            console.error(currentLanguage === 'zh' ? "ä¿å­˜å¤±è´¥:" : "Save failed:", e.target.error);
        };
}

function deleteCharacter(id) {
    if (!checkDbReady()) return;
    if (confirm("ç¡®å®šè¦åˆ é™¤è¿™ä¸ªè§’è‰²å—ï¼Ÿ")) {
        const transaction = db.transaction(['characters'], 'readwrite');
        transaction.objectStore('characters').delete(id);
        transaction.oncomplete = () => {
            renderUI();
        };
    }
}

function toggleFavorite(id, event) {
    if (!checkDbReady()) return;
    event.stopPropagation();
    const transaction = db.transaction(['characters'], 'readwrite');
    const store = transaction.objectStore('characters');
    const request = store.get(id);
    request.onsuccess = e => {
        const charData = e.target.result;
        charData.isFavorite = !charData.isFavorite;
        store.put(charData);
    };
    event.target.classList.toggle('favorited');
}

function addInternalTag(id) {
    if (!checkDbReady()) return;
    const tagName = prompt("æƒ³ä¸ºè¿™ä¸ªäººç‰©åŠ ä¸ªä»€ä¹ˆæ ·çš„æ ‡ç­¾å‘¢ï¼Ÿ");
    if (tagName && tagName.trim() !== "") {
        const transaction = db.transaction(['characters'], 'readwrite');
        const store = transaction.objectStore('characters');
        const request = store.get(id);
        request.onsuccess = e => {
            const charData = e.target.result;
            const trimmedTag = tagName.trim();

            if (!charData.internalTags) charData.internalTags = [];
            if (!charData.internalTags.includes(trimmedTag)) charData.internalTags.push(trimmedTag);

            if (!Array.isArray(charData.tags)) {
                charData.tags = (typeof charData.tags === 'string' && charData.tags)
                    ? charData.tags.split(/[,ã€ï¼Œ\s]+/).map(t => t.trim()).filter(Boolean)
                    : [];
            }
            if (!charData.tags.includes(trimmedTag)) charData.tags.push(trimmedTag);

            store.put(charData);
            transaction.oncomplete = () => renderUI();
        };
    }
}

// --- UI Rendering ---
async function renderUI() {
    if (!checkDbReady()) return;
    
    const transaction = db.transaction(['characters'], 'readonly');
    const allChars = await new Promise((resolve, reject) => {
        const req = transaction.objectStore('characters').getAll();
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
    });
    allChars.sort((a,b) => (b.isFavorite - a.isFavorite) || (b.lastUsed || 0) - (a.lastUsed || 0));

    renderTags(allChars);
    renderCharacters(allChars);
}

function renderTags(characters) {
    const tagContainer = document.getElementById('tag-container');
    const internalTags = new Set();
    const extraTags = new Set(); 

    characters.forEach(char => {
        (char.internalTags || []).forEach(tag => { if (tag) internalTags.add(tag.trim()); });
        const tags = Array.isArray(char.tags) ? char.tags : (typeof char.tags === 'string' ? char.tags.split(/[,ã€ï¼Œ\s]+/) : []);
        tags.forEach(tag => { if (tag) extraTags.add(tag.trim()); });
    });

    let tagsHtml = `<div class="tag type-special ${activeFilters.has('FAVORITE') ? 'active' : ''}" onclick="toggleFilter('FAVORITE', event)">â­ æ”¶è—</div>`;
    [...extraTags].sort().forEach(tag => { tagsHtml += `<div class="tag type-personality ${activeFilters.has(tag) ? 'active' : ''}" onclick="toggleFilter('${tag}', event)">${tag}</div>`; });
    [...internalTags].sort().forEach(tag => { tagsHtml += `<div class="tag type-internal ${activeFilters.has(tag) ? 'active' : ''}" onclick="toggleFilter('${tag}', event)">${tag}</div>`; });

    tagContainer.innerHTML = tagsHtml;
}

function renderCharacters(characters) {
    const grid = document.getElementById('character-grid');
    grid.innerHTML = '';

    let filteredChars = characters;
    if (activeFilters.size > 0) {
        filteredChars = characters.filter(char => {
            if (activeFilters.has('FAVORITE') && !char.isFavorite) return false;
            
            const regularFilters = [...activeFilters].filter(f => f !== 'FAVORITE');
            if (regularFilters.length > 0) {
                const tagSet = new Set([
                    ...(Array.isArray(char.tags) ? char.tags : (typeof char.tags === 'string' ? char.tags.split(/[,ã€ï¼Œ\s]+/) : [])),
                    ...(char.internalTags || [])
                ].map(t => t.trim()));
                return regularFilters.every(filter => tagSet.has(filter));
            }
            return true;
        });
    }

    if (filteredChars.length === 0) {
        grid.innerHTML = `<p style="grid-column: 1 / -1; text-align: center;">${t('no-characters-found')}</p>`;
        return;
    }

    filteredChars.forEach(char => {
        const card = document.createElement('div');
        card.className = 'character-card';
        // å¼ºåˆ¶æ˜¾ç¤ºä»»ä½•å›¾ç‰‡æ ¼å¼ï¼ŒåŒ…æ‹¬base64ã€URLç­‰
        let imageToDisplay;
        if (char.avatar) {
            // å¦‚æœæ˜¯base64æ ¼å¼
            if (char.avatar.startsWith('data:image/')) {
                imageToDisplay = char.avatar;
            }
            // å¦‚æœæ˜¯URLæ ¼å¼
            else if (char.avatar.startsWith('http://') || char.avatar.startsWith('https://')) {
                imageToDisplay = char.avatar;
            }
            // å¦‚æœæ˜¯ç›¸å¯¹è·¯å¾„æˆ–å…¶ä»–æ ¼å¼ï¼Œä¹Ÿå°è¯•æ˜¾ç¤º
            else if (char.avatar.trim() !== '') {
                imageToDisplay = char.avatar;
            } else {
                imageToDisplay = createDefaultImage('2:3');
            }
        } else {
            imageToDisplay = createDefaultImage('2:3');
        }
        card.style.backgroundImage = `var(--card-overlay), url('${imageToDisplay}')`;
        // è°ƒè¯•ä¿¡æ¯ï¼šè¾“å‡ºå¤´åƒæ•°æ®çŠ¶æ€
        console.log(currentLanguage === 'zh' ? `è§’è‰² "${char.name}" çš„å¤´åƒæ•°æ®:` : `Character "${char.name}" avatar data:`, {
            hasAvatar: !!char.avatar,
            avatarType: char.avatar ? (char.avatar.startsWith('data:') ? 'base64' : 'url') : 'none',
            imageToDisplay: imageToDisplay.substring(0, 50) + '...'
        });
        
        const headerDiv = document.createElement('div');
        const cardHeader = document.createElement('div');
        cardHeader.className = 'card-header';
        
        const h2 = document.createElement('h2');
        h2.textContent = char.name || 'æ— åè§’è‰²';
        
        const favButton = document.createElement('button');
        favButton.className = `favorite-btn ${char.isFavorite ? 'favorited' : ''}`;
        favButton.innerHTML = 'â˜…';
        favButton.onclick = (event) => toggleFavorite(char.id, event);
        
        cardHeader.appendChild(h2);
        cardHeader.appendChild(favButton);
        
        const descriptionP = document.createElement('p');
        descriptionP.className = 'card-description';
        descriptionP.textContent = char.description || t('no-description');
        
        const tagsDiv = document.createElement('div');
        tagsDiv.className = 'card-tags tag-group';
        const tagsArray = Array.isArray(char.tags) ? char.tags : (typeof char.tags === 'string' ? char.tags.split(/[,ã€ï¼Œ\s]+/) : []);
        const personalityTagsHtml = tagsArray.filter(t => t).map(tag => `<span class="tag type-personality">${tag.trim()}</span>`).join(' ');
        const internalTagsHtml = (char.internalTags || []).filter(t => t).map(tag => `<span class="tag type-internal">${tag.trim()}</span>`).join(' ');
        tagsDiv.innerHTML = personalityTagsHtml + ' ' + internalTagsHtml;
        
        headerDiv.appendChild(cardHeader);
        headerDiv.appendChild(descriptionP);
        headerDiv.appendChild(tagsDiv);

        const footerDiv = document.createElement('div');
        footerDiv.className = 'card-footer';
        footerDiv.innerHTML = `
            <button onclick="showEditorView(${char.id})">âœï¸ ç¼–è¾‘</button>
            <button onclick="addInternalTag(${char.id})">ğŸ·ï¸ æ·»åŠ æ ‡ç­¾</button>
            <button onclick="deleteCharacter(${char.id})">ğŸ—‘ï¸ åˆ é™¤</button>
        `;
        
        card.appendChild(headerDiv);
        card.appendChild(footerDiv);
        grid.appendChild(card);
    });
}


function toggleFilter(filterName, event) {
    event.stopPropagation();
    const button = event.currentTarget;
    button.classList.toggle('active');
    activeFilters.has(filterName) ? activeFilters.delete(filterName) : activeFilters.add(filterName);
    renderUI();
}

// --- Editor Form Management ---
function clearEditorForm() {
    const fields = ['charId', 'name', 'description', 'personality', 'system_prompt', 'scenario', 'first_mes', 'mes_example', 'internalTags', 'isFavorite', 'originalCardData', 'topic', 'gender', 'tags', 'post_history_instructions'];
    fields.forEach(id => { 
        const el = document.getElementById(id);
        if (el) el.value = ''; 
    });
    document.querySelectorAll('.ai-undo-button').forEach(btn => btn.style.display = 'none');
    document.getElementById('worldbook-entries-container').innerHTML = '';
    document.getElementById('avatar-input').value = '';
    document.getElementById('avatar-preview').src = createDefaultImage('2:3');
    avatarImageBase64 = null;
    document.querySelector('#editor-view .editor-body').scrollTop = 0;
}

function populateEditorForm(charData) {
    document.getElementById('charId').value = charData.id || '';
    document.getElementById('name').value = charData.name || '';
    document.getElementById('gender').value = charData.gender || '';
    document.getElementById('topic').value = charData.topic || '';
    document.getElementById('description').value = charData.description || '';
    document.getElementById('tags').value = Array.isArray(charData.tags) ? charData.tags.join(', ') : (typeof charData.tags === 'string' ? charData.tags : '');
    document.getElementById('personality').value = charData.personality || '';
    document.getElementById('system_prompt').value = charData.system_prompt || '';
    document.getElementById('scenario').value = charData.scenario || '';
    document.getElementById('first_mes').value = charData.first_mes || '';
    document.getElementById('mes_example').value = charData.mes_example || '';
    document.getElementById('post_history_instructions').value = charData.post_history_instructions || '';
    document.getElementById('internalTags').value = JSON.stringify(charData.internalTags || []);
    document.getElementById('isFavorite').value = charData.isFavorite || false;
    
    renderWorldbookFromData(charData.worldbook || []);

    if (charData.avatar) {
        // å¼ºåˆ¶æ˜¾ç¤ºä»»ä½•å›¾ç‰‡æ ¼å¼
        if (charData.avatar.startsWith('data:image/')) {
            document.getElementById('avatar-preview').src = charData.avatar;
            avatarImageBase64 = charData.avatar;
        } else if (charData.avatar.startsWith('http://') || charData.avatar.startsWith('https://')) {
            document.getElementById('avatar-preview').src = charData.avatar;
            avatarImageBase64 = charData.avatar;
        } else if (charData.avatar.trim() !== '') {
            document.getElementById('avatar-preview').src = charData.avatar;
            avatarImageBase64 = charData.avatar;
        } else {
            document.getElementById('avatar-preview').src = createDefaultImage('2:3');
            avatarImageBase64 = null;
        }
    } else {
        document.getElementById('avatar-preview').src = createDefaultImage('2:3');
        avatarImageBase64 = null;
    }
    document.querySelectorAll('.ai-undo-button').forEach(btn => btn.style.display = 'none');
    document.querySelector('#editor-view .editor-body').scrollTop = 0;
}

document.getElementById('avatar-input').addEventListener('change', function(event) {
    const file = event.target.files[0];
    if (!file) return;

    if (!file.type.startsWith("image/")) {
        alert(t('upload-image-only'));
        event.target.value = '';
        return;
    }

    const reader = new FileReader();
    reader.onload = async function(e) {
        try {
            // å°†ä»»ä½•æ ¼å¼çš„å›¾ç‰‡è½¬æ¢ä¸ºPNGæ ¼å¼
            const pngDataUrl = await convertImageToPng(e.target.result);
            avatarImageBase64 = pngDataUrl;
            document.getElementById('avatar-preview').src = pngDataUrl;
            console.log(currentLanguage === 'zh' ? 'å¤´åƒå·²è½¬æ¢ä¸ºPNGæ ¼å¼:' : 'Avatar converted to PNG format:', pngDataUrl.substring(0, 50) + '...');
        } catch (error) {
            console.error(currentLanguage === 'zh' ? 'å›¾ç‰‡è½¬æ¢å¤±è´¥:' : 'Image conversion failed:', error);
            alert(t('image-process-failed', { error: error.message }));
            event.target.value = '';
        }
    };
    reader.onerror = function() {
        alert(t('file-read-error'));
        event.target.value = '';
    };
    reader.readAsDataURL(file);
});

// ç”¨äºåœ¨ä¿å­˜åˆ°æ•°æ®åº“å‰ï¼Œæ¸…ç†ä¸–ç•Œä¹¦æ•°æ®ä¸­çš„DOMå…ƒç´ å¼•ç”¨
function cleanWorldbookForStorage(entries) {
    if (!entries) return [];
    return entries.map(entry => {
        // åˆ›å»ºä¸€ä¸ªä¸åŒ…å« 'element' å±æ€§çš„æ–°å¯¹è±¡
        const { element, ...cleanedEntry } = entry;

        // å¯¹å­æ¡ç›®è¿›è¡Œé€’å½’æ¸…ç†
        if (entry.children && entry.children.length > 0) {
            cleanedEntry.children = cleanWorldbookForStorage(entry.children);
        }
        return cleanedEntry;
    });
}

// --- Object Building ---
function buildCardObject() {
    const worldbookData = buildWorldbookDataFromDOM();
    
    const card = {
        name: document.getElementById('name').value.trim(),
        gender: document.getElementById('gender').value.trim(),
        topic: document.getElementById('topic').value.trim(),
        description: document.getElementById('description').value.trim(),
        personality: document.getElementById('personality').value.trim(),
        tags: document.getElementById('tags').value.trim().split(/[,ã€ï¼Œ\s]+/).map(t => t.trim()).filter(Boolean),
        system_prompt: document.getElementById('system_prompt').value.trim(),
        scenario: document.getElementById('scenario').value.trim(),
        first_mes: document.getElementById('first_mes').value.trim(),
        mes_example: document.getElementById('mes_example').value.trim(),
        post_history_instructions: document.getElementById('post_history_instructions').value.trim(),
        internalTags: JSON.parse(document.getElementById('internalTags').value || '[]'),
        isFavorite: (document.getElementById('isFavorite').value === 'true'),
        avatar: avatarImageBase64 || document.getElementById('avatar-preview').src || null,
        worldbook: worldbookData
    };
    const charId = parseInt(document.getElementById('charId').value, 10);
    if (!isNaN(charId)) card.id = charId;
    
    return card;
}


function buildLiveExportCard() {
    const currentCardState = buildCardObject();
    return buildV3Card(currentCardState);
}

function buildV3Card(cardData) {
    // é€’å½’å‡½æ•°ï¼šå°†æ¡ç›®åŠå…¶å­æ¡ç›®è½¬æ¢ä¸ºV3æ ¼å¼
    function convertEntryToV3(entry) {
        const v3Entry = {
            id: entry.id,
            keys: entry.keys || [],
            secondary_keys: entry.secondary_keys || [],
            comment: entry.comment || '',
            content: entry.content || '',
            constant: entry.constant || false,
            selective: entry.selective === undefined ? true : entry.selective,
            insertion_order: entry.priority || 100,
            enabled: entry.enabled === undefined ? true : entry.enabled,
            position: entry.position || 'before_char',
            use_regex: entry.use_regex || false,
            extensions: {
                position: 0,
                exclude_recursion: false,
                display_index: entry.display_index,
                probability: entry.probability === undefined ? 100 : entry.probability,
                useProbability: true,
                depth: entry.wb_depth || 4,
                selectiveLogic: 0,
                group: entry.group || "",
                group_override: false,
                group_weight: 100,
                prevent_recursion: entry.prevent_recursion || false,
                delay_until_recursion: false,
                scan_depth: null,
                match_whole_words: entry.match_whole_words || null,
                use_group_scoring: false,
                case_sensitive: entry.case_sensitive || null,
                automation_id: "",
                role: 0,
                vectorized: false,
                sticky: 0,
                cooldown: 0,
                delay: 0,
                secondary_keys_logic: entry.secondary_keys_logic || 'any'
            }
        };
        
        // é€’å½’å¤„ç†å­æ¡ç›®
        if (entry.children && entry.children.length > 0) {
            v3Entry.children = entry.children.map(child => convertEntryToV3(child));
        }
        
        return v3Entry;
    }
    
    const v3BookEntries = (cardData.worldbook || []).map(entry => convertEntryToV3(entry));

    const dataObject = {
        name: cardData.name || '',
        description: cardData.description || '',
        personality: cardData.personality || '',
        scenario: cardData.scenario || '',
        first_mes: cardData.first_mes || '',
        mes_example: cardData.mes_example || '',
        creator_notes: 'Created with Nika Character Studio',
        system_prompt: cardData.system_prompt || '',
        post_history_instructions: cardData.post_history_instructions || '',
        tags: cardData.tags || [],
        creator: 'Nika Studio User',
        character_version: '1.0',
        alternate_greetings: [],
        group_only_greetings: [],
        extensions: {
            talkativeness: "0.5",
            fav: cardData.isFavorite || false,
            world: cardData.topic || '',
            depth_prompt: { prompt: "", depth: 4, role: "system" }
        },
        character_book: {
            name: `(ä¸–ç•Œä¹¦) ${cardData.name || 'Character Book'}`,
            description: `Character book for ${cardData.name}.`,
            scan_depth: 10,
            token_budget: 2048,
            recursive_scanning: false,
            entries: v3BookEntries,
        },
    };

    return {
        spec: 'chara_card_v3',
        spec_version: '3.0',
        name: dataObject.name,
        description: dataObject.description,
        personality: dataObject.personality,
        scenario: dataObject.scenario,
        first_mes: dataObject.first_mes,
        mes_example: dataObject.mes_example,
        creatorcomment: dataObject.creator_notes,
        tags: dataObject.tags,
        create_date: new Date().toISOString(),
        avatar: "none",
        talkativeness: "0.5",
        fav: dataObject.extensions.fav,
        data: dataObject,
    };
}


// ====================================================================================
// --- LOVER & AI HELPER FUNCTIONS ---
// ====================================================================================

function initializeLoverSwitch() {
    const loverSwitch = document.getElementById('lover-switch');
    if (loverSwitch) {
        loverSwitch.addEventListener('change', (event) => {
            toggleAiButtonText(event.target.checked);
        });
    }
}

function toggleAiButtonText(isLover) {
    const aiButtons = document.querySelectorAll('.ai-button');
    const newText = isLover ? t('generate-companion') : t('ai-help-write');
    aiButtons.forEach(button => {
        button.textContent = newText;
    });
}

function getLoverPromptPrefix() {
    return `é‡è¦æŒ‡ä»¤ï¼šä½ æ˜¯ä¸€ä¸ªå°è¯´è§’è‰²åˆ›ä½œå®¶ï¼Œä½ è¦ç”Ÿæˆçš„è§’è‰²æŠŠè¯»è€…å½“æ‹äººæˆ–è€…å¯†å‹ï¼Œå¹¶ä¸”è¯»è€…çš„ä»£è¯ä¸º"{{user}}"ï¼Œè§’è‰²çš„ä»£è¯ä¸º"{{char}}ï¼Œç”Ÿæˆç›¸å…³è§’è‰²çš„ä¿¡æ¯\n\n`;
}

// æ–°å¢: æ’¤é”€AIè¡¥å…¨çš„åŠŸèƒ½
function undoAiCompletion(undoButton) {
    const container = undoButton.closest('.field-group');
    if (!container) return;

    const targetElement = container.querySelector('textarea, input:not([type=file]):not([type=checkbox])');
    if (targetElement && targetElement.dataset.aiBackup !== undefined) {
        targetElement.value = targetElement.dataset.aiBackup;
        delete targetElement.dataset.aiBackup; // æ¸…é™¤å¤‡ä»½
        undoButton.style.display = 'none'; // éšè—è‡ªå·±
    }
}


async function callApi(prompt, button) {
    const apiKey = document.getElementById('apiKey').value.trim();
    if (!apiKey) {
        alert(t('api-key-placeholder'));
        return null;
    }

    const isLover = document.getElementById('lover-switch').checked;
    const finalPrompt = isLover ? getLoverPromptPrefix() + prompt : prompt;

    console.log(currentLanguage === 'zh' ? "å‘é€ç»™APIçš„æœ€ç»ˆæç¤º:" : "Final prompt being sent to API:", finalPrompt);

    const originalText = button.textContent;
    button.disabled = true;
    button.textContent = t('generating');

    // éšè—å¯¹åº”çš„æ’¤é”€æŒ‰é’®ï¼ˆå¦‚æœå®ƒæ­£æ˜¾ç¤ºï¼‰
    const undoButton = button.nextElementSibling;
    if (undoButton && undoButton.classList.contains('ai-undo-button')) {
        undoButton.style.display = 'none';
    }


    try {
        const response = await fetch("https://api.deepseek.com/chat/completions", {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({ model: "deepseek-chat", messages: [{ "role": "user", "content": finalPrompt }] })
        });

        if (!response.ok) {
            const errorBody = await response.json();
            throw new Error(t('api-request-failed', { status: response.statusText, message: errorBody.error.message }));
        }

        const data = await response.json();
        return data.choices[0].message.content;
    } catch (error) {
        console.error(currentLanguage === 'zh' ? "DeepSeek APIé”™è¯¯:" : "DeepSeek API error:", error);
        alert(t('ai-completion-failed'));
        return null;
    } finally {
        button.disabled = false;
        button.textContent = originalText;
    }
}
async function callDeepSeek(fieldId) {
    const button = event.target;
    const targetElement = document.getElementById(fieldId);
    if (!targetElement) return;

    // å¤‡ä»½å½“å‰æ–‡æœ¬
    targetElement.dataset.aiBackup = targetElement.value;

    const currentCard = buildCardObject();
    const labelText = document.querySelector(`label[for='${fieldId}']`).innerText.replace(' (é€—å·åˆ†éš”)','');
    let prompt = `ä½ æ˜¯ä¸€ä½ä¸“ä¸šçš„è§’è‰²è®¾å®šå¸ˆã€‚è¯·æ ¹æ®ä»¥ä¸‹å·²ç»æä¾›çš„è§’è‰²ä¿¡æ¯ï¼Œä¸ºæˆ‘ç”Ÿæˆæˆ–è¡¥å…¨ã€${labelText}ã€‘è¿™ä¸€é¡¹ã€‚
è¯·ç›´æ¥è¿”å›æœ€é€‚åˆå¡«å…¥è¯¥é¡¹çš„å†…å®¹ï¼Œè¯­è¨€é£æ ¼è¦è‡ªç„¶ï¼Œä¸è¦åŒ…å«ä»»ä½•é¢å¤–è§£é‡Šã€æ ‡é¢˜æˆ–æ ‡ç­¾ã€‚

å·²æä¾›ä¿¡æ¯:
- ä¸»é¢˜/ä¸–ç•Œè§‚: ${currentCard.topic || 'æœªæŒ‡å®š'}
- è§’è‰²å: ${currentCard.name || 'æœªæŒ‡å®š'}
- æ€§åˆ«: ${currentCard.gender || 'æœªæŒ‡å®š'}
- è§’è‰²æè¿°: ${currentCard.description || 'æœªæŒ‡å®š'}
- åˆ†ç±»æ ‡ç­¾: ${(currentCard.tags && currentCard.tags.length > 0) ? currentCard.tags.join(', ') : 'æœªæŒ‡å®š'}
- ä¸ªæ€§: ${currentCard.personality || 'æœªæŒ‡å®š'}
- åœºæ™¯è®¾å®š: ${currentCard.scenario || 'æœªæŒ‡å®š'}
- é¦–æ¬¡å‘è¨€: ${currentCard.first_mes || 'æœªæŒ‡å®š'}
- èŒƒä¾‹å¯¹è¯: ${currentCard.mes_example || 'æœªæŒ‡å®š'}

ç°åœ¨ï¼Œè¯·ç”Ÿæˆã€${labelText}ã€‘çš„å†…å®¹ã€‚`;
    
    const result = await callApi(prompt, button);
    if (result) {
        targetElement.value = result;
        // æ˜¾ç¤ºæ’¤é”€æŒ‰é’®
        const undoButton = button.nextElementSibling;
        if (undoButton && undoButton.classList.contains('ai-undo-button')) {
            undoButton.style.display = 'inline-block';
        }
    }
}
async function generateFullWorldbook(button) {
    if (!confirm(t('confirm-overwrite-worldbook'))) return;

    const characterContext = buildCardObject();
    let prompt = `ä½ æ˜¯ä¸€ä½ä¸“ä¸šçš„AIè§’è‰²æ‰®æ¼”è§’è‰²ä¹¦ï¼ˆCharacter Bookï¼‰æ¶æ„å¸ˆã€‚è¯·åˆ†æä»¥ä¸‹è§’è‰²è®¾å®šï¼Œå¹¶ä¸ºè¯¥è§’è‰²åˆ›å»º3åˆ°5ä¸ªæœ€æ ¸å¿ƒã€æœ€èƒ½å¢å¼ºè§’è‰²æ‰®æ¼”æ·±åº¦çš„è§’è‰²ä¹¦æ¡ç›®ã€‚

**è§’è‰²è®¾å®š:**
- è§’è‰²å: ${characterContext.name || 'æœªæŒ‡å®š'}
- æ€§åˆ«: ${characterContext.gender || 'æœªæŒ‡å®š'}
- ä¸»é¢˜/ä¸–ç•Œè§‚: ${characterContext.topic || 'æœªæŒ‡å®š'}
- è§’è‰²æè¿°: ${characterContext.description || 'æœªæŒ‡å®š'}
- ä¸ªæ€§: ${characterContext.personality || 'æœªæŒ‡å®š'}
- åœºæ™¯è®¾å®š: ${characterContext.scenario || 'æœªæŒ‡å®š'}

**ä½ çš„ä»»åŠ¡:**
1. è¯†åˆ«å‡ºè§’è‰²èƒŒæ™¯ä¸­æœ€é‡è¦çš„æ¦‚å¿µã€äººç‰©ã€åœ°ç‚¹ã€ç‰©å“æˆ–å…³é”®èƒ½åŠ›ã€‚
2. ä¸ºè¿™äº›æ¦‚å¿µåˆ›å»ºè§’è‰²ä¹¦æ¡ç›®ã€‚
3. **ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹JSONæ ¼å¼è¿”å›ä½ çš„ç­”æ¡ˆï¼Œä¸è¦åŒ…å«ä»»ä½•JSONæ ¼å¼ä¹‹å¤–çš„é¢å¤–æ–‡å­—ã€è§£é‡Šæˆ–Markdownæ ‡è®°ã€‚**

**JSONæ ¼å¼è¦æ±‚:**
è¿”å›ä¸€ä¸ªJSONæ•°ç»„ï¼Œå…¶ä¸­æ¯ä¸ªå¯¹è±¡ä»£è¡¨ä¸€ä¸ªæ¡ç›®ï¼Œä¸”å¿…é¡»åŒ…å« "id" (æ•°å­—), "keys" (å­—ç¬¦ä¸²æ•°ç»„), "content" (å­—ç¬¦ä¸²), å’Œ "comment" (å­—ç¬¦ä¸²) å››ä¸ªé”®ã€‚"id" ä»0å¼€å§‹é€’å¢ã€‚`;

    const result = await callApi(prompt, button);
    if (result) {
        try {
            const cleanedResult = result.replace(/^```json\s*|```$/g, '');
            const generatedEntries = JSON.parse(cleanedResult);
            
            if (Array.isArray(generatedEntries)) {
                renderWorldbookFromData(generatedEntries);
                alert(t('worldbook-generated-success'));
            } else {
                throw new Error(t('ai-return-not-array'));
            }
        } catch (e) {
            console.error(currentLanguage === 'zh' ? "è§£æAIè¿”å›çš„JSONå¤±è´¥:" : "Failed to parse AI returned JSON:", e);
            console.error(currentLanguage === 'zh' ? "æ”¶åˆ°çš„åŸå§‹æ•°æ®:" : "Received raw data:", result);
            alert(t('ai-parse-failed'));
        }
    }
}
async function callWorldbookDeepSeek(button) {
    const currentEntryElement = button.closest('.worldbook-entry');
    const targetElement = currentEntryElement.querySelector('.wb-content');
    if (!targetElement) return;

    // å¤‡ä»½å½“å‰æ–‡æœ¬
    targetElement.dataset.aiBackup = targetElement.value;

    const characterContext = buildCardObject(); 
    const currentComment = currentEntryElement.querySelector('.entry-comment').value || 'æœªå‘½åæ¡ç›®';
    const currentKeys = currentEntryElement.querySelector('.wb-keys').value;
    let prompt = `ä½ æ˜¯ä¸€ä½ä¸“ä¸šçš„è§’è‰²ä¹¦ï¼ˆCharacter Bookï¼‰å†…å®¹å¡«å……ä¸“å®¶ã€‚è¯·åŸºäºä»¥ä¸‹æä¾›çš„è§’è‰²ä¿¡æ¯å’Œè§’è‰²ä¹¦ç»“æ„ï¼Œä¸ºæˆ‘æ’°å†™æ¡ç›®ã€${currentComment}ã€‘çš„"æ³¨å…¥å†…å®¹"ã€‚å†…å®¹éœ€è¦è¯¦ç»†ã€å¯Œæœ‰æƒ³è±¡åŠ›ï¼Œå¹¶ä¸è§’è‰²è®¾å®šä¿æŒé«˜åº¦ä¸€è‡´ã€‚

---
**è§’è‰²æ ¸å¿ƒè®¾å®š:**
- è§’è‰²å: ${characterContext.name || 'æœªæŒ‡å®š'}
- æè¿°: ${characterContext.description || 'æœªæŒ‡å®š'}
- ä¸ªæ€§: ${characterContext.personality || 'æœªæŒ‡å®š'}

**è§’è‰²ä¹¦ä¸Šä¸‹æ–‡:**
- **å½“å‰æ¡ç›®æ ‡é¢˜ (Comment):** ${currentComment}
- **å½“å‰æ¡ç›®ä¸»è¦å…³é”®è¯ (Keys):** ${currentKeys || 'æœªæŒ‡å®š'}

---
**ä½ çš„ä»»åŠ¡:**
ç°åœ¨ï¼Œè¯·ä¸ºæ¡ç›®ã€${currentComment}ã€‘ç”Ÿæˆè¯¦ç»†çš„"æ³¨å…¥å†…å®¹"ã€‚
**è¦æ±‚ï¼š** ç›´æ¥è¿”å›å†…å®¹æœ¬èº«ï¼Œä¸è¦åŒ…å«ä»»ä½•é¢å¤–è§£é‡Šã€æ ‡é¢˜æˆ–å¼•ç”¨ã€‚`;

    const result = await callApi(prompt, button);
    if (result) {
        targetElement.value = result;
        // æ˜¾ç¤ºæ’¤é”€æŒ‰é’®
        const undoButton = button.nextElementSibling;
        if (undoButton && undoButton.classList.contains('ai-undo-button')) {
            undoButton.style.display = 'inline-block';
        }
    }
}


// ====================================================================================
// --- REFACTORED WORLD BOOK MANAGEMENT (DATA-DRIVEN APPROACH) ---
// ====================================================================================

// [æ–°åŠŸèƒ½] æ–°å¢çš„è¾…åŠ©å‡½æ•°ï¼Œç”¨äºåœ¨æ•°æ®ç»“æ„ä¸­æŸ¥æ‰¾æ¡ç›®
function findEntryRecursive(list, elementToFind, parent = null) {
    for (let i = 0; i < list.length; i++) {
        const item = list[i];
        if (item.element === elementToFind) {
            return {
                entry: item,
                parentList: list,
                index: i,
                parentEntry: parent
            };
        }
        if (item.children && item.children.length > 0) {
            const found = findEntryRecursive(item.children, elementToFind, item);
            if (found) {
                return found;
            }
        }
    }
    return null;
}

function parseEntryFromElement(element) {
    return {
        id: parseInt(element.querySelector('.wb-sort-id').value, 10) || 0,
        keys: element.querySelector('.wb-keys').value.split(/[,ã€ï¼Œ\s]+/).map(k => k.trim()).filter(Boolean),
        secondary_keys: element.querySelector('.wb-secondary-keys').value.split(/[,ã€ï¼Œ\s]+/).map(k => k.trim()).filter(Boolean),
        secondary_keys_logic: element.querySelector('.wb-secondary-keys-logic').value,
        comment: element.querySelector('.entry-comment').value,
        content: element.querySelector('.wb-content').value,
        priority: parseInt(element.querySelector('.wb-priority').value, 10) || 100,
        enabled: element.querySelector('.wb-enabled').checked,
        prevent_recursion: element.querySelector('.wb-prevent-recursion').checked,
        group: element.querySelector('.wb-group').value.trim(),
        position: element.querySelector('.wb-position').value,
        scope: element.querySelector('.wb-scope').value,
        constant: element.querySelector('.wb-constant').checked,
        selective: element.querySelector('.wb-selective').checked,
        use_regex: element.querySelector('.wb-use-regex').checked,
        match_whole_words: element.querySelector('.wb-match-whole-words').checked,
        case_sensitive: element.querySelector('.wb-case-sensitive').checked,
        probability: parseInt(element.querySelector('.wb-probability').value, 10),
        wb_depth: parseInt(element.querySelector('.wb-depth').value, 10) || 4,
        element: element,
        children: []
    };
}

function buildWorldbookDataFromDOM(parentElement = document.getElementById('worldbook-entries-container')) {
    const entries = [];
    const childElements = Array.from(parentElement.children);

    for (const el of childElements) {
        if (el.matches('li.worldbook-entry')) {
            const entryData = parseEntryFromElement(el);
            const childContainer = el.querySelector('.child-entries');
            if (childContainer && childContainer.children.length > 0) {
                entryData.children = buildWorldbookDataFromDOM(childContainer);
            }
            entries.push(entryData);
        }
    }
    return entries;
}

function renderWorldbookFromData(data) {
    const container = document.getElementById('worldbook-entries-container');
    container.innerHTML = ''; 

    function renderLevel(entries, parentElement) {
        entries.forEach(entryData => {
            const entryElement = createWorldbookEntryElement(entryData);
            parentElement.appendChild(entryElement);
            if (entryData.children && entryData.children.length > 0) {
                const childContainer = entryElement.querySelector('.child-entries');
                renderLevel(entryData.children, childContainer);
            }
        });
    }
    
    renderLevel(data, container);
    updateAllEntryAttributes();
}

function sortDataTree(data) {
    data.sort((a, b) => (a.id || 0) - (b.id || 0));
    data.forEach(entry => {
        if (entry.children && entry.children.length > 0) {
            sortDataTree(entry.children);
        }
    });
}

function sortWorldbookEntries() {
    const worldbookData = buildWorldbookDataFromDOM();
    sortDataTree(worldbookData);
    renderWorldbookFromData(worldbookData);
    alert('æ¡ç›®å·²æŒ‰IDé‡æ–°æ’åˆ—ï¼');
}

function airdropEntry(button) {
    const currentEntryElement = button.closest('.worldbook-entry');
    if (!currentEntryElement) return;

    const idInput = currentEntryElement.querySelector('.wb-sort-id');
    if (!idInput) return;

    const targetId = parseInt(idInput.value, 10);
    if (isNaN(targetId)) {
        alert("è¯·è¾“å…¥ä¸€ä¸ªæœ‰æ•ˆçš„æ•°å­—IDã€‚");
        return;
    }
    const worldbookData = buildWorldbookDataFromDOM();
    let entryToMove = null;
    let parentList = null;

    function findEntryAndParent(data, parent) {
        for (const entry of data) {
            if (entry.element === currentEntryElement) {
                entryToMove = entry;
                parentList = parent;
                return;
            }
            if (entry.children.length > 0) {
                findEntryAndParent(entry.children, entry.children);
            }
        }
    }
    findEntryAndParent(worldbookData, worldbookData);
    if (!entryToMove || !parentList) return;
    parentList.forEach(sibling => {
        if (sibling !== entryToMove && sibling.id >= targetId) {
            sibling.id += 1;
        }
    });
    entryToMove.id = targetId;
    sortDataTree(worldbookData);
    renderWorldbookFromData(worldbookData);
    alert(`æ“ä½œå®Œæˆï¼åˆ—è¡¨å·²æ ¹æ®æ–°IDæ’åˆ—ã€‚`);
}

function createDefaultImage(ratio = '2:3') {
    const canvas = document.createElement('canvas');
    const [width, height] = ratio === '2:3' ? [512, 768] : [768, 512];
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');
    const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
    gradient.addColorStop(0, '#2d2d2d');
    gradient.addColorStop(1, '#1c1c1c');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    return canvas.toDataURL('image/png');
}

function addWorldbookEntry() {
    const worldbookData = buildWorldbookDataFromDOM();
    const newId = (worldbookData.length > 0) ? Math.max(...worldbookData.map(e => e.id)) + 1 : 0;
    worldbookData.push({ id: newId, comment: 'æ–°æ¡ç›®', keys: [], content: '', children: [] });
    renderWorldbookFromData(worldbookData);
}

function createWorldbookEntryElement(entryData = {}) {
    const entryLi = document.createElement('li');
    entryLi.className = 'worldbook-entry';
    const uniqueId = `wb-entry-${Date.now()}-${Math.random()}`;
    entryLi.dataset.uniqueId = uniqueId;
    
    const defaultEntry = {
        comment: 'æ–°æ¡ç›®', keys: [], secondary_keys: [], content: '',
        secondary_keys_logic: 'any',
        priority: 100, enabled: true, prevent_recursion: false,
        group: '', position: 'before_char', scope: 'chat',
        id: 0,
        constant: false, selective: true, use_regex: false,
        match_whole_words: true, case_sensitive: false, probability: 100,
        wb_depth: 4,
        ...entryData
    };
    
    entryLi.innerHTML = `
        <div class="entry-content-wrapper">
            <div class="entry-header">
                <div class="entry-title-group">
                    <div style="display: flex; align-items: center; gap: 5px; min-width: 130px;">
                        <input type="number" class="wb-sort-id" title="æ’åºID" placeholder="ID" value="${defaultEntry.id}" style="width: 65px; flex-shrink: 0;">
                        <button title="å°†æ­¤æ¡ç›®æ’å…¥åˆ°å·¦ä¾§æ¡†ä¸­æŒ‡å®šçš„IDä½ç½®ï¼Œå¹¶é¡ºå»¶åç»­æ¡ç›®" onclick="airdropEntry(this)" style="padding: 5px 8px; font-size: 14px; background-color: #6c757d; color: white;">â¡ï¸</button>
                    </div>
                    <input type="text" class="entry-comment" placeholder="æ¡ç›®æ³¨é‡Š (Comment)" value="${defaultEntry.comment}">
                                         <span class="help-icon" onclick="showHelp(t('help-id-drop'))">?</span>
                </div>
                <div class="entry-actions">
                    <button title="æ·»åŠ å­æ¡ç›®" onclick="addChildEntry(this)">â•</button>
                    <button title="å°†æ­¤æ¡ç›®ç§»å‡ºçˆ¶æ¡ç›®" onclick="indentEntry(this, -1)">â†“é€€å‡º</button>
                    <button title="å°†æ­¤æ¡ç›®è®¾ä¸ºä¸Šæ–¹åŒçº§æ¡ç›®çš„å­æ¡ç›®" onclick="indentEntry(this, 1)">â†‘åŠ å…¥</button>
                    <button class="delete-entry-btn" onclick="this.closest('.worldbook-entry').remove();">åˆ é™¤</button>
                </div>
            </div>
            <div class="entry-grid">
                <div class="field-group full-width">
                                         <label>ä¸»è¦å…³é”®è¯ (Keys, é€—å·åˆ†éš”) <span class="help-icon" onclick="showHelp(t('help-main-keys'))">?</span></label>
                    <input type="text" class="wb-keys" placeholder="ä¾‹å¦‚: èª“çº¦èƒœåˆ©ä¹‹å‰‘, Excalibur" value="${(defaultEntry.keys || []).join(', ')}">
                </div>
                <div class="field-group full-width">
                    <label>æ³¨å…¥å†…å®¹ (Content) <button class="ai-button" onclick="callWorldbookDeepSeek(this)" style="padding: 2px 8px; font-size: 12px; width: auto; margin-left: 10px;">ğŸ”® AI å¸®æˆ‘å†™</button><button class="ai-undo-button" onclick="undoAiCompletion(this)">â†©ï¸ æ’¤é”€</button></label>
                    <textarea class="wb-content" rows="3" placeholder="å½“å…³é”®è¯è¢«è§¦å‘æ—¶ï¼Œè¿™é‡Œçš„å†…å®¹ä¼šè¢«æ‚„æ‚„åœ°å¡ç»™AIï¼Œä½œä¸ºå®ƒçš„ä¸´æ—¶è®°å¿†ã€‚æ”¯æŒç”¨ {{å˜é‡}} å¼•ç”¨å…¶ä»–æ¡ç›®çš„å†…å®¹ã€‚">${defaultEntry.content}</textarea>
                </div>

                <div class="field-group full-width">
                    <details>
                        <summary id="advanced-settings-summary">é«˜çº§è®¾å®š <span style="font-weight: normal; font-size: 14px; color: #aaa;">(å…³é”®è¯åŒ¹é…ã€æ³¨å…¥é€»è¾‘ç­‰)</span></summary>
                        <div class="advanced-grid">
                            <div class="field-group full-width">
                                <label>å…³é”®å­—è¿‡æ»¤å™¨ (Keyword Filter) 
                                    <span class="help-icon" onclick="showHelp(t('help-secondary-keys'))">?</span>
                                </label>
                                <div style="display: flex; gap: 10px; align-items: center;">
                                    <select class="wb-secondary-keys-logic" style="flex: 1; padding: 12px;">
                                        <option value="any" ${defaultEntry.secondary_keys_logic === 'any' ? 'selected' : ''}>ä¸ä»»æ„</option>
                                        <option value="none" ${defaultEntry.secondary_keys_logic === 'none' ? 'selected' : ''}>éä»»æ„</option>
                                        <option value="all" ${defaultEntry.secondary_keys_logic === 'all' ? 'selected' : ''}>ä¸æ‰€æœ‰</option>
                                        <option value="not_all" ${defaultEntry.secondary_keys_logic === 'not_all' ? 'selected' : ''}>éæ‰€æœ‰</option>
                                    </select>
                                    <input type="text" class="wb-secondary-keys" placeholder="é€—å·åˆ†éš”çš„å…³é”®è¯" value="${(defaultEntry.secondary_keys || []).join(', ')}" style="flex: 3;">
                                </div>
                            </div>
                            <div class="field-group">
                                <label>æ³¨å…¥ä½ç½®</label>
                                <select class="wb-position">
                                    <option value="before_char" ${defaultEntry.position === 'before_char' ? 'selected' : ''}>è§’è‰²å®šä¹‰å‰</option>
                                    <option value="after_char" ${defaultEntry.position === 'after_char' ? 'selected' : ''}>è§’è‰²å®šä¹‰å</option>
                                    <option value="before_prompt" ${defaultEntry.position === 'before_prompt' ? 'selected' : ''}>æœ€å¼€å¤´</option>
                                </select>
                            </div>
                            <div class="field-group"><label>ä½œç”¨åŸŸ</label><select class="wb-scope"><option value="chat" ${defaultEntry.scope === 'chat' ? 'selected' : ''}>èŠå¤©ä¸­</option><option value="summary" ${defaultEntry.scope === 'summary' ? 'selected' : ''}>è®°å¿†æ‘˜è¦ä¸­</option><option value="discovery" ${defaultEntry.scope === 'discovery' ? 'selected' : ''}>æ¯æ¬¡è¿›å…¥èŠå¤©æ—¶</option></select></div>
                            <div class="field-group"><label>ä¼˜å…ˆçº§</label><input type="number" class="wb-priority" value="${defaultEntry.priority}"></div>
                            <div class="field-group"><label>åˆ†ç»„</label><input type="text" class="wb-group" value="${defaultEntry.group}" placeholder="å¯é€‰"></div>
                            <div class="field-group"><label>è§¦å‘æ¦‚ç‡ (%)</label><input type="number" class="wb-probability" value="${defaultEntry.probability}" min="0" max="100"></div>
                            <div class="field-group"><label>è®°å¿†æ‰«ææ·±åº¦</label><input type="number" class="wb-depth" value="${defaultEntry.wb_depth}"></div>
                            <div class="field-group logic-group full-width">
                                <label><input type="checkbox" class="wb-enabled" ${defaultEntry.enabled ? 'checked' : ''}>å¯ç”¨</label>
                                <label><input type="checkbox" class="wb-constant" ${defaultEntry.constant ? 'checked' : ''}>æ’å®šæ³¨å…¥</label>
                                <label><input type="checkbox" class="wb-selective" ${defaultEntry.selective ? 'checked' : ''}>é€‰æ‹©æ€§æ³¨å…¥</label>
                                <label><input type="checkbox" class="wb-prevent-recursion" ${defaultEntry.prevent_recursion ? 'checked' : ''}>é˜»æ­¢é€’å½’</label>
                                <label><input type="checkbox" class="wb-use-regex" ${defaultEntry.use_regex ? 'checked' : ''}>æ­£åˆ™åŒ¹é…</label>
                                <label><input type="checkbox" class="wb-match-whole-words" ${defaultEntry.match_whole_words ? 'checked' : ''}>å…¨è¯åŒ¹é…</label>
                                <label><input type="checkbox" class="wb-case-sensitive" ${defaultEntry.case_sensitive ? 'checked' : ''}>åŒºåˆ†å¤§å°å†™</label>
                            </div>
                        </div>
                    </details>
                </div>
            </div>
        </div>
        <ul class="child-entries"></ul>
    `;
    return entryLi;
}

function addChildEntry(button) {
    const worldbookData = buildWorldbookDataFromDOM();
    const parentEntryElement = button.closest('.worldbook-entry');
    
    function findAndAdd(data) {
        for (const entry of data) {
            if (entry.element === parentEntryElement) {
                const newId = (entry.children.length > 0) ? Math.max(...entry.children.map(e => e.id)) + 1 : 0;
                entry.children.push({ id: newId, comment: 'æ–°å­æ¡ç›®', keys: [], content: '', children: [] });
                return true;
            }
            if (entry.children.length > 0) {
                if(findAndAdd(entry.children)) return true;
            }
        }
        return false;
    }

    findAndAdd(worldbookData);
    renderWorldbookFromData(worldbookData);
}

// [å·²ä¿®å¤] æ›¿æ¢ä¸ºä¿®å¤åçš„å‡½æ•°
function indentEntry(button, direction) {
    const worldbookData = buildWorldbookDataFromDOM();
    const currentEntryElement = button.closest('.worldbook-entry');
    if (!currentEntryElement) return;

    const found = findEntryRecursive(worldbookData, currentEntryElement);

    if (!found) {
        console.error(currentLanguage === 'zh' ? "æ— æ³•åœ¨æ•°æ®ç»“æ„ä¸­æ‰¾åˆ°å¯¹åº”çš„æ¡ç›®ã€‚" : "Unable to find corresponding entry in data structure.");
        return;
    }

    const { entry, parentList, index, parentEntry } = found;

    if (direction > 0) { // Indent (â†‘åŠ å…¥): å°†æ¡ç›®è®¾ä¸ºä¸Šæ–¹åŒçº§æ¡ç›®çš„å­æ¡ç›®
        if (index > 0) {
            const newParent = parentList[index - 1];
            parentList.splice(index, 1); // ä»å½“å‰åˆ—è¡¨ä¸­ç§»é™¤
            newParent.children.push(entry); // æ·»åŠ åˆ°æ–°çˆ¶çº§çš„ children æ•°ç»„ä¸­
        } else {
            alert('å·²ç»æ˜¯åŒçº§ä¸­çš„ç¬¬ä¸€ä¸ªæ¡ç›®ï¼Œæ— æ³•åŠ å…¥ï¼ˆç¼©è¿›ï¼‰ã€‚');
            return;
        }
    } else { // Un-indent (â†“é€€å‡º): å°†å­æ¡ç›®ç§»å‡ºï¼Œæˆä¸ºçˆ¶æ¡ç›®çš„åŒçº§
        if (parentEntry) {
            const parentFound = findEntryRecursive(worldbookData, parentEntry.element);
            if (parentFound) {
                const grandParentList = parentFound.parentList;
                const parentIndex = parentFound.index;

                parentList.splice(index, 1); // ä»å½“å‰çˆ¶çº§çš„ children æ•°ç»„ä¸­ç§»é™¤
                grandParentList.splice(parentIndex + 1, 0, entry); // æ·»åŠ åˆ°ç¥–çˆ¶çº§åˆ—è¡¨ï¼Œç´§è·Ÿåœ¨åŸçˆ¶çº§ä¹‹å
            }
        } else {
            alert(t('already-root-entry'));
            return;
        }
    }

    // ä»ä¿®æ”¹åçš„æ•°æ®ç»“æ„ï¼Œé‡æ–°æ¸²æŸ“æ•´ä¸ªè§’è‰²ä¹¦UI
    renderWorldbookFromData(worldbookData);
}

function updateAllEntryAttributes() {
    const container = document.getElementById('worldbook-entries-container');
    
    function traverse(element, depth, indexRef) {
        if (element.matches('li.worldbook-entry')) {
            element.dataset.depth = depth;
            element.dataset.displayIndex = indexRef.index++;
            const childContainer = element.querySelector('.child-entries');
            if (childContainer) {
                Array.from(childContainer.children).forEach(child => traverse(child, depth + 1, indexRef));
            }
        } else if (element.children) {
             Array.from(element.children).forEach(child => traverse(child, 0, indexRef));
        }
    }
    
    let indexCounter = { index: 0 };
    traverse(container, -1, indexCounter);
}

// --- PNG EMBEDDING FUNCTIONS ---
async function cleanImageAndGetDataURL(base64Str) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            resolve(canvas.toDataURL('image/png'));
        };
        img.onerror = () => reject(new Error('æ— æ³•åŠ è½½å›¾ç‰‡ï¼Œå¯èƒ½ä¸æ˜¯æœ‰æ•ˆçš„å›¾ç‰‡æ ¼å¼ã€‚'));
        img.src = base64Str;
    });
}

// æ–°å¢ï¼šå°†ä»»ä½•æ ¼å¼çš„å›¾ç‰‡è½¬æ¢ä¸ºPNGæ ¼å¼
async function convertImageToPng(imageDataUrl) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = 'anonymous'; // å…è®¸è·¨åŸŸå›¾ç‰‡
        
        img.onload = () => {
            try {
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                
                // ç»˜åˆ¶å›¾ç‰‡åˆ°canvas
                ctx.drawImage(img, 0, 0);
                
                // è½¬æ¢ä¸ºPNGæ ¼å¼
                const pngDataUrl = canvas.toDataURL('image/png', 0.9);
                resolve(pngDataUrl);
            } catch (error) {
                reject(new Error(`å›¾ç‰‡è½¬æ¢å¤±è´¥: ${error.message}`));
            }
        };
        
        img.onerror = () => {
            reject(new Error('æ— æ³•åŠ è½½å›¾ç‰‡ï¼Œå¯èƒ½ä¸æ˜¯æœ‰æ•ˆçš„å›¾ç‰‡æ ¼å¼ã€‚'));
        };
        
        img.src = imageDataUrl;
    });
}
async function embedDataInPng(imageBase64, textData) {
    const response = await fetch(imageBase64);
    const imageBuffer = await response.arrayBuffer();
    const imageData = new Uint8Array(imageBuffer);
    
    const textEncoder = new TextEncoder();
    const encodedText = textEncoder.encode("chara\x00" + textData);

    const chunk = createTextChunk('tEXt', encodedText);
    
    const iendPosition = findIend(imageData);
    if (iendPosition === -1) throw new Error("Invalid PNG: IEND chunk not found.");
    
    const newPngData = new Uint8Array(imageData.length + chunk.length);
    newPngData.set(imageData.slice(0, iendPosition));
    newPngData.set(chunk, iendPosition);
    newPngData.set(imageData.slice(iendPosition), iendPosition + chunk.length);
    
    return new Blob([newPngData], { type: 'image/png' });
}

function createTextChunk(type, data) {
    const chunkType = new TextEncoder().encode(type);
    const chunkData = data;
    const chunkLength = new Uint8Array(4);
    new DataView(chunkLength.buffer).setUint32(0, chunkData.length);

    const toCrc = new Uint8Array(chunkType.length + chunkData.length);
    toCrc.set(chunkType);
    toCrc.set(chunkData, chunkType.length);
    const crcValue = crc32(toCrc);
    const crc = new Uint8Array(4);
    new DataView(crc.buffer).setUint32(0, crcValue);

    const chunk = new Uint8Array(12 + chunkData.length);
    chunk.set(chunkLength);
    chunk.set(chunkType, 4);
    chunk.set(chunkData, 8);
    chunk.set(crc, 8 + chunkData.length);

    return chunk;
}

function findIend(imageData) {
    const IEND_SIGNATURE = [0x49, 0x45, 0x4E, 0x44];
    for (let i = imageData.length - 12; i >= 8; i--) {
        if (imageData[i+4] === IEND_SIGNATURE[0] && imageData[i+5] === IEND_SIGNATURE[1] && imageData[i+6] === IEND_SIGNATURE[2] && imageData[i+7] === IEND_SIGNATURE[3]) {
           return i;
        }
    }
    return -1;
}

const crc32 = (function() {
    const table = new Uint32Array(256);
    for (let i = 0; i < 256; i++) {
        let c = i;
        for (let j = 0; j < 8; j++) {
            c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
        }
        table[i] = c;
    }
    return function(bytes) {
        let crc = -1;
        for (let i = 0; i < bytes.length; i++) {
            crc = (crc >>> 8) ^ table[(crc ^ bytes[i]) & 0xFF];
        }
        return (crc ^ -1) >>> 0;
    };
})();

async function extractDataFromPng(arrayBuffer) {
    const bytes = new Uint8Array(arrayBuffer);
    const keyword = 'chara';
    
    let i = 8;
    while(i < bytes.length) {
        const view = new DataView(bytes.buffer, i);
        const length = view.getUint32(0);
        const type = new TextDecoder().decode(bytes.slice(i + 4, i + 8));

        if (type === 'tEXt' || type === 'iTXt') {
            const data_start = i + 8;
            let currentKeyword = '';
            let k_end = data_start;
            while(k_end < data_start + length && bytes[k_end] !== 0) {
              currentKeyword += String.fromCharCode(bytes[k_end]);
              k_end++;
            }
            
            if (currentKeyword === keyword) {
                const dataBytes = bytes.slice(k_end + 1, data_start + length);
                const base64String = new TextDecoder("utf-8").decode(dataBytes);
                const jsonString = decodeURIComponent(escape(atob(base64String)));
                return JSON.parse(jsonString);
            }
        }
        i += 12 + length;
    }
    throw new Error('åœ¨PNGä¸­æœªæ‰¾åˆ°è§’è‰²æ•°æ®ã€‚');
}

</script>

</body>
</html>