<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>å¦®å¡è§’è‰²å·¥ä½œå®¤Pro</title>
  <script src="https://unpkg.com/pako@2.1.0/dist/pako.min.js"></script>
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-7PYFG35VCZ"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-7PYFG35VCZ');
  </script>
 
  <style>
    /* --- å…¨å±€æ ·å¼ ("æˆ‘ä»¬çš„ä¸»é¢˜") --- */
    :root {
        --primary-color: #e67e22;
        --secondary-color: #d35400;
        --dark-bg: #1c1c1c;
        --light-bg: #2d2d2d;
        --default-card-bg: linear-gradient(135deg, #2d2d2d, #1c1c1c);
        --text-color: #f0f0f0;
        --label-color: #e67e22;
        --input-bg: #333;
        --input-border: #555;
        --card-overlay: linear-gradient(to top, rgba(28, 28, 28, 0.9) 0%, rgba(28, 28, 28, 0.5) 50%, rgba(28, 28, 28, 0.7) 100%);
        --ai-button-bg: #e67e22;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif; }
    body { background: var(--dark-bg); min-height: 100vh; padding: 20px; color: var(--text-color); }
    button { cursor: pointer; font-weight: bold; border: none; transition: all 0.2s ease; }
    p.help-text { font-size: 14px; color: #aaa; margin-top: -10px; margin-bottom: 15px; line-height: 1.6; }

    /* --- è¯­è¨€åˆ‡æ¢æŒ‰é’®æ ·å¼ --- */
    .language-switcher {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-left: 15px;
    }
    .language-switcher button {
        background: transparent;
        color: var(--text-color);
        border: 1px solid rgba(255,255,255,0.2);
        padding: 4px 8px;
        margin: 0 1px;
        border-radius: 12px;
        font-size: 11px;
        font-weight: normal;
        transition: all 0.2s ease;
        min-width: 40px;
    }
    .language-switcher button.active {
        background: transparent;
        border-color: var(--primary-color);
        color: var(--primary-color);
        font-weight: bold;
    }
    .language-switcher button:hover {
        background: rgba(230, 126, 34, 0.05);
        border-color: rgba(230, 126, 34, 0.3);
        transform: scale(1.02);
    }

    /* --- åŠ è½½åŠ¨ç”»æ ·å¼ --- */
    .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(28, 28, 28, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        backdrop-filter: blur(5px);
    }
    
    .loading-spinner {
        width: 50px;
        height: 50px;
        border: 3px solid rgba(230, 126, 34, 0.3);
        border-top: 3px solid var(--primary-color);
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    .loading-text {
        color: var(--text-color);
        margin-top: 15px;
        font-size: 16px;
        text-align: center;
    }

    /* --- è§’è‰²åº“ (Library View) æ ·å¼ --- */
    #library-view .container { width: 100%; max-width: 1200px; margin: 0 auto; }
    #library-view .header { display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center; margin-bottom: 25px; padding-bottom: 15px; border-bottom: 2px solid rgba(255,255,255,0.1); }
    #library-view .header h1 { font-size: 28px; color: white; text-shadow: 0 0 8px var(--primary-color); }
    #library-view .header-buttons { display: flex; gap: 10px; margin-top: 10px; }
    #library-view .header-buttons button { background: var(--primary-color); color: white; padding: 10px 20px; border-radius: 5px; font-size: 16px; }
    #library-view .header-buttons button:hover { background: var(--secondary-color); box-shadow: 0 0 10px var(--secondary-color); transform: translateY(-2px); }
    #library-view #file-importer { display: none; }
    #library-view .tag-filter-area { background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px; margin-bottom: 25px; }
    #library-view .tag-filter-area h3 { margin-bottom: 10px; color: var(--text-color); }
    #library-view .tag-group { display: flex; flex-wrap: wrap; gap: 8px; }
    #library-view .tag { padding: 5px 12px; border-radius: 15px; font-size: 14px; cursor: pointer; color: white; background-color: #555; border: 1px solid #777; }
    #library-view .tag.type-personality { background-color: #7f8c8d; border-color: #95a5a6; }
    #library-view .tag.type-internal { background-color: #d18076; border-color: #bc7168; }
    #library-view .tag.type-special { background-color: var(--secondary-color); border-color: var(--primary-color); }
    #library-view .tag:hover { opacity: 0.8; }
    #library-view .tag.active { box-shadow: 0 0 8px 2px var(--primary-color); transform: scale(1.05); }
    #library-view .character-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 20px; }

    #library-view .character-card {
        aspect-ratio: 2 / 3;
        border-radius: 8px;
        padding: 15px;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        border: 1px solid rgba(255,255,255,0.1);
        transition: transform 0.2s ease, border-color 0.2s ease;
        overflow: hidden;
        position: relative;
        background: var(--default-card-bg);
        background-size: cover;
        background-position: center;
    }
    #library-view .character-card > div:first-of-type {
        flex: 1;
        overflow: hidden;
        min-height: 0;
        display: flex;
        flex-direction: column;
    }
    #library-view .character-card:hover { transform: translateY(-5px); border-color: var(--primary-color); }
    #library-view .card-header { display: flex; justify-content: space-between; align-items: flex-start; }
    #library-view .card-header h2 { font-size: 20px; color: var(--text-color); margin-bottom: 5px; text-shadow: 0 1px 3px rgba(0,0,0,0.8); }
    #library-view .favorite-btn { background: none; color: #aaa; font-size: 24px; padding: 0; text-shadow: 0 1px 3px rgba(0,0,0,0.8); }
    #library-view .favorite-btn.favorited { color: #f1c40f; }
    #library-view .card-description {
        font-size: 14px;
        color: #ccc;
        margin-bottom: 15px;
        flex-grow: 1;
        white-space: pre-wrap;
        overflow: hidden;
        text-shadow: 0 1px 2px rgba(0,0,0,0.7);
        display: -webkit-box;
        -webkit-box-orient: vertical;
        -webkit-line-clamp: 4; /* å¯ä»¥è°ƒæ•´è¡Œæ•° */
        line-height: 1.4em;
        max-height: calc(1.4em * 4); /* å…¼å®¹æ€§å›é€€ */
    }
    #library-view .card-footer { display: flex; gap: 8px; flex-wrap: wrap; }
    #library-view .card-footer button { flex-grow: 1; background: rgba(0,0,0,0.4); backdrop-filter: blur(5px); color: white; border: 1px solid var(--label-color); padding: 8px 10px; border-radius: 5px; }
    #library-view .card-footer button:hover { background-color: var(--primary-color); }

    /* --- ç·¨è¼¯å™¨ (Editor View) æ¨£å¼ --- */
    #editor-view { display: none; justify-content: center; align-items: flex-start; width: 100%; padding-top: 2vh; }
    #editor-view .editor-container { width: 100%; max-width: 900px; background: var(--light-bg); border-radius: 10px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); overflow: hidden; display: flex; flex-direction: column; max-height: 93vh; color: var(--text-color); }
    #editor-view .editor-header { background: var(--primary-color); padding: 15px 20px; color: white; display: flex; align-items: center; justify-content: space-between; }
    #editor-view .editor-header h1 { font-size: 22px; text-shadow: 1px 1px 2px rgba(0,0,0,0.3); }
    #editor-view .editor-body { flex: 1; overflow-y: auto; /* ä¸»æ»šåŠ¨åŒº */ }
    #editor-view .panel-content { padding: 20px; }
    #editor-view .section-title { font-size: 1.2em; font-weight: bold; color: var(--primary-color); margin-top: 25px; margin-bottom: 15px; padding-bottom: 8px; border-bottom: 2px solid var(--primary-color); }
    #editor-view .field-group { margin-bottom: 15px; position: relative; }
    #editor-view .field-group label { display: flex; align-items: center; font-weight: bold; margin-bottom: 8px; color: var(--text-color); cursor: default; }
    #editor-view .field-group input, #editor-view .field-group textarea, #editor-view .field-group select { width: 100%; padding: 12px; border: 1px solid var(--input-border); border-radius: 5px; background: var(--input-bg); font-size: 15px; color: var(--text-color); }
    #editor-view .field-group .inline-group { display: flex; gap: 15px; align-items: flex-end; }
    #editor-view .field-group textarea { resize: vertical; min-height: 80px; }
    .ai-button { background: var(--ai-button-bg); color: #fff; border: 1px solid var(--secondary-color); border-radius: 5px; padding: 5px 10px; font-size: 12px; width: 100px; margin-top: 5px; }
    .ai-button:hover { background: var(--secondary-color); }
    /* æ–°å¢: æ’¤é”€æŒ‰é’®æ ·å¼ */
    .ai-undo-button {
      background: #6c757d; color: #fff; border-radius: 5px;
      padding: 5px 10px; font-size: 12px; margin-top: 5px;
      margin-left: 5px; display: none; /* é»˜è®¤éšè— */
    }
    .ai-undo-button:hover { background: #5a6268; }
    /* åå­—ç”Ÿæˆå™¨æŒ‰é’® */
    .name-generator-btn {
        background: none;
        border: none;
        font-size: 22px;
        padding: 0 8px;
        margin-bottom: 5px;
        color: var(--primary-color);
    }
    .name-generator-btn:hover {
        transform: scale(1.1);
        text-shadow: 0 0 5px var(--primary-color);
    }


    #editor-view #avatar-preview { max-width: 250px; border-radius: 8px; border: 2px dashed var(--input-border); object-fit: cover; aspect-ratio: 2/3; margin-bottom: 10px; }
    #editor-view .action-buttons { display: flex; gap: 10px; margin-top: 20px; }
    #editor-view .action-buttons.row { flex-direction: row; align-items: center; } /* ç¡®ä¿å‚ç›´å±…ä¸­ */
    #editor-view .action-buttons button { width: 100%; padding: 12px; border-radius: 5px; background: var(--primary-color); color: white; font-size: 16px;}
    #editor-view .action-buttons button.secondary { background: #6c757d; }
    #editor-view .action-buttons button:hover { transform: translateY(-1px); box-shadow: 0 4px 8px rgba(0,0,0,0.2); opacity: 0.9; }
    #complete-all-btn {
        font-size: 14px;
        padding: 4px 10px;
        margin-left: 15px;
        background-color: var(--ai-button-bg);
        color: white;
        border-radius: 5px;
    }

    #ai-guidance-modal {
    z-index: 10001;
    }

    /* --- è§’è‰²ä¹¦ (Character Book) ä¸“ä¸šæ ·å¼ --- */
    .worldbook-list, .child-entries {
        list-style-type: none;
        padding-left: 25px; /* æ§åˆ¶ç¼©è¿›é‡ */
        border-left: 2px dotted #444;
    }
    .worldbook-list {
        padding-left: 0;
        border-left: none;
    }
    .worldbook-entry {
        background: rgba(0,0,0,0.15);
        border: 1px solid var(--input-border);
        border-radius: 8px;
        margin-top: 10px;
        transition: background-color 0.3s;
        border-left: 3px solid transparent;
    }
    .worldbook-entry:hover {
       border-left-color: var(--primary-color);
    }
    .entry-content-wrapper { padding: 15px; }
    .entry-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; gap: 10px; }
    .entry-title-group { display: flex; align-items: center; gap: 10px; flex-grow: 1; }
    .wb-sort-id { width: 60px !important; text-align: center; } /* Adjusted from full width */
    .entry-comment {
        font-size: 1.1em;
        font-weight: bold;
        color: var(--text-color);
        border: none;
        background: transparent;
        border-bottom: 2px solid var(--input-border);
        padding: 5px;
        flex-grow: 1;
    }
    .entry-comment:focus { outline: none; border-bottom-color: var(--primary-color); }
    .entry-actions { display: flex; gap: 5px; flex-shrink: 0; align-items: center;}
    .entry-actions button { background: #555; color: white; padding: 5px 8px; border-radius: 5px; font-size: 14px; }
    .entry-actions button.delete-entry-btn { background: #dc3545; }

    .entry-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
    .full-width { grid-column: 1 / -1; }
    
    /* --- FIX: é€»è¾‘ç»„ (Logic Group) æ ·å¼é‡æ„ --- */
    .logic-group {
        display: flex;
        flex-wrap: wrap;
        gap: 10px; /* æŒ‰é’®ä¹‹é—´çš„é—´è· */
        background: rgba(0,0,0,0.2);
        padding: 10px;
        border-radius: 5px;
    }
    .logic-group label {
        display: inline-flex; /* å…³é”®ä¿®å¤ï¼šä½¿å…¶è¡¨ç°ä¸ºè¡Œå†…å¼¹æ€§å®¹å™¨ï¼Œä¿è¯å†…éƒ¨å…ƒç´ ä¸åˆ†ç¦» */
        align-items: center;
        background-color: #4a4a4a; /* æŒ‰é’®èƒŒæ™¯è‰² */
        padding: 6px 12px; /* å†…è¾¹è· */
        border-radius: 15px; /* èƒ¶å›Šå½¢çŠ¶ */
        border: 1px solid #666;
        cursor: pointer;
        font-weight: normal;
        margin-bottom: 0;
        transition: all 0.2s ease;
        white-space: nowrap; /* å¼ºåˆ¶æŒ‰é’®å†…çš„æ–‡æœ¬ä¸æ¢è¡Œ */
    }
    .logic-group label:hover {
        background-color: #5a5a5a;
        border-color: #888;
    }
    .logic-group input[type="checkbox"] {
        width: auto;
        margin-right: 8px; /* å¤é€‰æ¡†å’Œæ–‡å­—çš„é—´è· */
        transform: scale(1.2); /* æ”¾å¤§å¤é€‰æ¡†ï¼Œæ–¹ä¾¿ç‚¹å‡» */
    }
    
    /* --- å¸®åŠ©å›¾æ ‡æ ·å¼ --- */
    .help-icon {
        display: inline-block;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background-color: #6c757d;
        color: white;
        text-align: center;
        font-size: 12px;
        font-weight: bold;
        line-height: 18px;
        cursor: help;
        margin-left: 5px;
        user-select: none; /* é˜²æ­¢æ–‡æœ¬è¢«é€‰ä¸­ */
        flex-shrink: 0; /* é˜²æ­¢å›¾æ ‡è¢«å‹ç¼© */
        transition: background-color 0.2s ease, transform 0.2s ease;
    }
    .help-icon:hover {
        background-color: var(--primary-color);
        transform: scale(1.1);
    }

    /* --- è§’è‰²ä¹¦é«˜çº§è®¾ç½®æ ·å¼ --- */
    .worldbook-entry details {
        border: 1px solid #444;
        border-radius: 5px;
        padding: 10px;
        margin-top: 15px;
        background: rgba(0,0,0,0.1);
    }
    .worldbook-entry summary {
        font-weight: bold;
        color: var(--primary-color);
        cursor: pointer;
        outline: none;
        padding-bottom: 10px;
    }
    .worldbook-entry details[open] summary {
        border-bottom: 1px solid #555;
    }
    .worldbook-entry details .advanced-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 15px;
        padding-top: 10px;
    }
    .worldbook-entry details .logic-group {
        gap: 10px 20px; /* row-gap column-gap */
    }
    /* ä¼˜å…ˆçº§å¿«é€Ÿè®¾ç½®æŒ‰é’® */
    .priority-buttons {
        display: flex;
        gap: 5px;
        margin-left: 8px;
    }
    .priority-buttons button {
        padding: 2px 8px;
        font-size: 11px;
        border-radius: 4px;
        background-color: #555;
        color: #fff;
    }
    .priority-buttons button:hover {
        background-color: var(--primary-color);
    }

    /* --- Post History Template Buttons --- */
    .template-buttons {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 8px;
        margin-bottom: 15px;
    }
    .template-buttons button {
        background: #555;
        color: white;
        padding: 5px 12px;
        border-radius: 5px;
        font-size: 13px;
        border: 1px solid #777;
    }
    .template-buttons button:hover {
        background-color: var(--primary-color);
        border-color: var(--secondary-color);
    }
    
    /* --- Lover å¼€å…³æ ·å¼ --- */
    .lover-switch-container {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-right: 15px; /* ä¸å³ä¾§æŒ‰é’®çš„é—´è· */
    }
    .lover-switch-container .switch-label {
      font-size: 14px;
      font-weight: bold;
      color: var(--text-color);
    }
    .switch {
      position: relative;
      display: inline-block;
      width: 74px;
      height: 28px;
    }
    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #555;
      transition: .4s;
      border-radius: 28px;
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 20px;
      width: 20px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    input:checked + .slider {
      background-color: #e67e22; 
    }
    input:checked + .slider:before {
      transform: translateX(22px);
    }
    
    /* --- Modal æ ·å¼ (é€šç”¨) --- */
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: none; /* é»˜è®¤éšè— */
        justify-content: center;
        align-items: center;
        z-index: 10000;
        backdrop-filter: blur(5px);
    }
    .modal-content {
        background: var(--light-bg);
        padding: 25px;
        border-radius: 10px;
        width: 90%;
        box-shadow: 0 5px 25px rgba(0,0,0,0.5);
    }
    .modal-content h3 {
        color: var(--primary-color);
        margin-bottom: 20px;
        text-align: center;
    }
    .modal-content .modal-actions {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-top: 20px;
    }
    .modal-content .modal-actions button {
        padding: 10px 20px;
        border-radius: 5px;
        margin: 0 5px;
        min-width: 100px;
    }
    .modal-content .modal-actions .action-btn {
        background: var(--primary-color);
        color: #fff;
    }
    .modal-content .modal-actions .cancel-btn {
        background: #6c757d;
        color: #fff;
    }

    /* --- API è®¾ç½® Modal æ ·å¼ --- */
    #api-settings-modal .modal-content {
        max-width: 600px;
    }
    #api-settings-modal .api-provider-options {
        display: none; /* é»˜è®¤éšè—æ‰€æœ‰é…ç½®åŒº */
        border-top: 1px solid #444;
        margin-top: 15px;
        padding-top: 15px;
    }
    #api-settings-modal .api-provider-options.active {
        display: block; /* æ˜¾ç¤ºå½“å‰é€‰ä¸­çš„é…ç½®åŒº */
    }
    #api-settings-modal .field-group {
        margin-bottom: 15px;
    }
    #api-settings-modal label {
        display: block;
        font-weight: bold;
        margin-bottom: 5px;
        color: var(--text-color);
    }
    #api-settings-modal input, #api-settings-modal select {
        width: 100%;
        padding: 10px;
        border: 1px solid var(--input-border);
        border-radius: 5px;
        background: var(--input-bg);
        color: var(--text-color);
        font-size: 15px;
    }


    /* --- åå­—é€‰æ‹© Modal æ ·å¼ --- */
    #name-generator-modal .modal-content {
        max-width: 400px;
    }
    #name-generator-modal .name-options {
        display: flex;
        flex-direction: column;
        gap: 10px;
        margin-bottom: 20px;
    }
    #name-generator-modal .name-options button {
        width: 100%;
        padding: 12px;
        border-radius: 5px;
        background: var(--input-bg);
        color: var(--text-color);
        border: 1px solid var(--input-border);
    }
    #name-generator-modal .name-options button:hover {
        background: var(--primary-color);
        color: #fff;
    }
    
    /* --- Lorebook AI Modal --- */
    #worldbook-ai-generator-modal .modal-content {
        max-width: 800px;
    }
     #worldbook-ai-generator-modal .generation-type-selector {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-bottom: 20px;
    }
    #worldbook-ai-generator-modal #wb-ai-options-container {
        text-align: left;
        max-height: 60vh;
        overflow-y: auto;
        padding: 5px;
        background: rgba(0,0,0,0.1);
        border-radius: 5px;
        min-height: 100px;
    }
    #worldbook-ai-generator-modal .generated-entry {
        background: rgba(0,0,0,0.2);
        border: 1px solid #444;
        border-radius: 5px;
        padding: 15px;
        margin-bottom: 10px;
    }
    #worldbook-ai-generator-modal .generated-entry > label {
        display: flex;
        align-items: flex-start;
        font-weight: normal;
        cursor: pointer;
    }
    #worldbook-ai-generator-modal .generated-entry input[type="checkbox"] {
        margin-right: 15px;
        transform: scale(1.4);
        margin-top: 5px;
        flex-shrink: 0;
    }
    #worldbook-ai-generator-modal .entry-details h4 {
        color: var(--primary-color);
        margin-bottom: 5px;
    }
     #worldbook-ai-generator-modal .entry-details p {
        font-size: 14px;
        margin-bottom: 8px;
        color: #ccc;
        line-height: 1.5;
    }
    #worldbook-ai-generator-modal .entry-details p strong {
        color: var(--text-color);
    }
    #worldbook-ai-generator-modal .entry-details .ai-entry-controls {
        display: flex;
        gap: 15px;
        margin-top: 10px;
        font-size: 14px;
        align-items: center;
    }
    #worldbook-ai-generator-modal .entry-details .ai-entry-controls label {
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 5px;
    }


    /* --- Generic AI Guidance Modal --- */
    #ai-guidance-modal .modal-content {
        max-width: 500px;
    }
    #ai-guidance-input {
        width: 100%;
        min-height: 100px;
        padding: 10px;
        border-radius: 5px;
        background: var(--input-bg);
        color: var(--text-color);
        border: 1px solid var(--input-border);
        resize: vertical;
    }


    /* --- å“åº”å¼å¸ƒå±€ --- */
    @media (max-width: 800px) {
        body { padding: 10px; }
        #library-view .header { justify-content: center; text-align: center; }
        #library-view .header-buttons { justify-content: center; width: 100%; }
        #library-view .character-grid { grid-template-columns: 1fr; gap: 10px; }
        #editor-view { padding-top: 0; }
        #editor-view .editor-container { max-height: 100vh; height: 100%; border-radius: 0; }
        #editor-view .panel-content { padding: 15px; }
        #editor-view .editor-header h1 { font-size: 18px; }
        .entry-grid { grid-template-columns: 1fr; }
        .entry-header { flex-wrap: wrap; gap: 10px; /* Mobile Fix: Add gap for wrapped items */ }
        .worldbook-entry details .advanced-grid {
            grid-template-columns: 1fr; /* Mobile Fix: Force single column for advanced settings */
        }

        /* --- Mobile Input Zoom & Resize Improvement --- */
        #editor-view .field-group input, 
        #editor-view .field-group textarea, 
        #editor-view .field-group select {
            /* Using 16px font size is a common technique to prevent automatic page zoom on focus in mobile browsers, especially iOS Safari. */
            /* This provides a smoother experience without disabling user-initiated pinch-to-zoom. */
            font-size: 16px;
        }
    }
  </style>
</head>
<body>

  <div id="loading-overlay" class="loading-overlay">
    <div style="display: flex; flex-direction: column; align-items: center;">
      <div class="loading-spinner"></div>
      <div class="loading-text" id="loading-text">æ­£åœ¨åŠ è½½...</div>
    </div>
  </div>

  <div id="api-settings-modal" class="modal-overlay">
    <div class="modal-content">
        <h3 id="api-modal-title">API è®¾ç½®</h3>
        <div class="field-group">
            <label for="api-provider-selector">é€‰æ‹©æœåŠ¡å•†</label>
            <select id="api-provider-selector">
                <option value="deepseek">DeepSeek</option>
                <option value="gemini">Gemini (ç›´é“¾ï¼Œéœ€é­”æ³•)</option>
                <option value="gemini-proxy">Gemini (ä¸­è½¬ä»£ç†)</option>
                <option value="local">æœ¬åœ°å¤§æ¨¡å‹</option>
                <option value="tavern">è‡ªå®šä¹‰ (å…¼å®¹OpenAI)</option>
            </select>
        </div>

        <div id="deepseek-options" class="api-provider-options active">
            <div class="field-group">
                <label for="deepseek-api-key">API Key</label>
                <input type="password" id="deepseek-api-key" placeholder="è¾“å…¥ä½ çš„ DeepSeek API Key">
            </div>
        </div>

        <div id="gemini-options" class="api-provider-options">
            <div class="field-group">
                <label for="gemini-api-key">API Key</label>
                <input type="password" id="gemini-api-key" placeholder="è¾“å…¥ä½ çš„ Google AI Studio API Key">
            </div>
            <div class="field-group">
                <label for="gemini-model">é€‰æ‹©æ¨¡å‹</label>
                <select id="gemini-model">
                    <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
                    <option value="gemini-2.5-pro">Gemini 2.5 Pro</option>
                </select>
            </div>
        </div>

        <div id="gemini-proxy-options" class="api-provider-options">
            <div class="field-group">
                <label for="gemini-proxy-endpoint">ä»£ç† Endpoint URL</label>
                <input type="text" id="gemini-proxy-endpoint" placeholder="ä¾‹å¦‚: https://mydomain.com/v1beta/models">
            </div>
            <div class="field-group">
                <label for="gemini-proxy-api-key">API Key</label>
                <input type="password" id="gemini-proxy-api-key" placeholder="è¾“å…¥ä½ çš„ Google AI Studio API Key">
            </div>
            <div class="field-group">
                <label for="gemini-proxy-model">é€‰æ‹©æ¨¡å‹</label>
                <select id="gemini-proxy-model">
                    <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
                    <option value="gemini-2.5-pro">Gemini 2.5 Pro</option>
                </select>
            </div>
            <p class="help-text">ç”¨äºè¿æ¥ Cloudflare Worker ç­‰è‡ªå®šä¹‰åå‘ä»£ç†ã€‚Endpoint URL åº”ä¸ºä¸åŒ…å«æ¨¡å‹åç§°çš„å®Œæ•´è·¯å¾„ã€‚</p>
        </div>

        <div id="local-options" class="api-provider-options">
            <div class="field-group">
                <label for="local-api-endpoint">API URL</label>
                <input type="text" id="local-api-endpoint" placeholder="ä¾‹å¦‚: http://localhost:1234/v1">
            </div>
            <p class="help-text">ç”¨äºè¿æ¥LM Studioæˆ–è€…Ollama, éœ€ä¸‹è½½é¡¹ç›®æºæ–‡ä»¶å¯åŠ¨æ‰èƒ½ä½¿ç”¨ã€‚</p>
        </div>

        <div id="tavern-options" class="api-provider-options">
            <div class="field-group">
                <label for="tavern-api-endpoint">API URL</label>
                <input type="text" id="tavern-api-endpoint" placeholder="http://api.xxx.com/v1">
            </div>
            <div class="field-group">
                <label for="tavern-api-key">API Key</label>
                <input type="password" id="tavern-api-key" placeholder="è¾“å…¥ API Key">
            </div>
            <div class="field-group">
                <label for="tavern-model">æ¨¡å‹åç§°</label>
                <input type="text" id="tavern-model" placeholder="ä¾‹å¦‚: gpt-3.5-turbo">
            </div>
            <p class="help-text">ç”¨äºè¿æ¥è¿œç¨‹çš„ã€å…¼å®¹OpenAIæ ¼å¼çš„APIæœåŠ¡ã€‚</p>
        </div>

        <div class="modal-actions">
            <button id="save-api-settings-btn" class="action-btn">ä¿å­˜</button>
            <button id="cancel-api-settings-btn" class="cancel-btn">å–æ¶ˆ</button>
        </div>
    </div>
  </div>

  <div id="name-generator-modal" class="modal-overlay">
      <div class="modal-content">
          <h3 id="name-modal-title">ä¸ºä½ çš„è§’è‰²é€‰æ‹©ä¸€ä¸ªåå­—</h3>
          <div id="name-options-container" class="name-options">
              </div>
          <div class="modal-actions">
              <button id="regenerate-names-btn" class="action-btn">é‡æ–°ç”Ÿæˆ</button>
              <button id="cancel-name-generation-btn" class="cancel-btn">å–æ¶ˆ</button>
          </div>
      </div>
  </div>

  <div id="ai-guidance-modal" class="modal-overlay">
      <div class="modal-content">
          <h3 id="ai-guidance-title">ä¸ºAIæä¾›æŒ‡å¼•</h3>
          <textarea id="ai-guidance-input" rows="5" placeholder="åœ¨æ­¤è¾“å…¥ä½ çš„å…·ä½“è¦æ±‚ã€é£æ ¼ã€å…³é”®è¯ç­‰... (å¯ç•™ç©º)"></textarea>
          <div class="modal-actions">
              <button id="ai-guidance-generate-btn" class="action-btn">ç”Ÿæˆ</button>
              <button id="ai-guidance-cancel-btn" class="cancel-btn">å–æ¶ˆ</button>
          </div>
      </div>
  </div>

  <div id="worldbook-ai-generator-modal" class="modal-overlay">
      <div class="modal-content">
          <h3 id="wb-ai-modal-title">è§’è‰²ä¹¦ç”Ÿæˆ</h3>
          <p class="help-text" style="text-align: center; margin-top: -15px; margin-bottom: 20px;" id="wb-ai-modal-desc">è¯·é€‰æ‹©è¦ç”Ÿæˆçš„æ¡ç›®ç±»å‹ï¼š</p>
          <div class="generation-type-selector">
              <button data-type="worldview" class="action-btn">ç”Ÿæˆä¸–ç•Œè§‚</button>
              <button data-type="main_plot" class="action-btn">ç”Ÿæˆä¸»çº¿å‰§æƒ…</button>
              <button data-type="side_plot" class="action-btn">ç”Ÿæˆæ”¯çº¿å‰§æƒ…</button>
          </div>
          <div id="wb-ai-options-container">
              </div>
          <div class="modal-actions">
              <button id="wb-ai-inject-btn" style="display:none;" class="action-btn">æ³¨å…¥é€‰ä¸­æ¡ç›®</button>
              <button id="wb-ai-regenerate-btn" style="display:none;" class="action-btn">å†ç”Ÿæˆä¸€å¥—</button>
              <button id="wb-ai-cancel-btn" class="cancel-btn">å…³é—­</button>
          </div>
      </div>
  </div>

  <div id="library-view">
    <div class="container">
      <div class="header">
        <div style="display: flex; align-items: center; gap: 15px;">
          <h1>å¦®å¡è§’è‰²å·¥ä½œå®¤Pro</h1>
          <div class="language-switcher">
            <button onclick="switchLanguage('zh')" id="lang-zh" class="active">ä¸­æ–‡</button>
            <button onclick="switchLanguage('en')" id="lang-en">English</button>
          </div>
        </div>
        <div class="header-buttons">
          <button onclick="showEditorView()">+ åˆ›å»ºæ–°è§’è‰²/ä¹¦</button>
          <button onclick="document.getElementById('file-importer').click()">ğŸ“¥ å¯¼å…¥</button>
          <input type="file" id="file-importer" accept=".json,.png" onchange="importCharacter(event)" multiple />
        </div>
      </div>
      <div class="tag-filter-area">
        <h3>æ ‡ç­¾è¿‡æ»¤</h3>
        <div id="tag-container" class="tag-group"></div>
      </div>
      <div id="character-grid" class="character-grid"></div>
    </div>
  </div>

  <div id="editor-view">
    <div class="editor-container">
      <div class="editor-header">
        <h1 id="editor-title">åˆ›å»ºæ–°è§’è‰²</h1>
        <button onclick="openApiSettingsModal()" style="background: var(--secondary-color); color: white; padding: 8px 15px; border-radius: 5px;">âš™ï¸ API è®¾ç½®</button>
      </div>
      <div class="editor-body">
        <div class="panel-content">
          <input type="hidden" id="charId" />
          <input type="hidden" id="internalTags" />
          <input type="hidden" id="isFavorite" />
          <input type="hidden" id="originalCardData" />

          <h3 class="section-title" id="avatar-operation-title">è§’è‰²å¤´åƒä¸æ“ä½œ</h3>
           <div class="field-group">
                <label for="avatar-input-label" id="avatar-input-label" title="">è§’è‰²å¤´åƒ</label>
                <img id="avatar-preview" src="" alt="å¤´åƒé¢„è§ˆ"/>
                <input type="file" id="avatar-input" accept="image/*" style="display:none;">
                <button onclick="document.getElementById('avatar-input').click()" style="max-width: 250px;">ä¸Šä¼ å›¾ç‰‡</button>
            </div>
            <div class="action-buttons" style="flex-direction: column;">
                <button onclick="saveCharacter()">ğŸ’¾ å‚¨å­˜å¹¶è¿”å›è§’è‰²åº“</button>
                <button onclick="downloadCharacter()">ğŸ“¥ ä¸‹è½½ JSON</button>
                <button onclick="downloadCharacterAsPng()">ğŸ“¥ ä¸‹è½½ PNG è§’è‰²å¡</button>
                <button onclick="downloadAsWorldbookFile()">ğŸ“¥ ä¸‹è½½ä¸ºä¸–ç•Œä¹¦</button>
                <button class="secondary" onclick="showLibraryView()">ğŸ”™ è¿”å› (ä¸å‚¨å­˜)</button>
            </div>
          
          <div style="display:flex; justify-content: space-between; align-items: center;">
            <h3 class="section-title" id="character-info-title">è§’è‰²ä¿¡æ¯</h3>
            <div>
                <button id="translate-all-btn" onclick="translateAllFields(this)" style="background-color: #e67e22; color: white; padding: 5px 15px; border-radius: 5px; margin-right: 10px;">ğŸŒ ä¸€é”®ç¿»è¯‘</button>
                <button id="undo-translate-btn" style="display: none; background-color: #d35400; color: white; padding: 8px 15px; border-radius: 5px; margin-right: 10px;" onclick="undoTranslateAllFields(this)">æ’¤é”€ç¿»è¯‘</button>
                <button id="complete-all-btn" onclick="aiCompleteAllFields(this)">ğŸ”® ä¸€é”®è¡¥å…¨æ‰€æœ‰</button>
            </div>
          </div>
          <div class="field-group">
            <label for="topic">ä¸»é¢˜</label>
            <input id="topic" placeholder="ä¾‹ï¼šèµ›åšæœ‹å…‹, å¥‡å¹», æ ¡å›­" />
          </div>
          <div class="field-group">
              <div class="inline-group">
                  <div style="flex:3">
                      <label for="name">åå­—</label>
                      <div style="display: flex; align-items: center; gap: 5px;">
                          <input id="name" placeholder="ä¾‹ï¼šMonika" style="flex-grow: 1;" />
                          <button class="name-generator-btn" onclick="generateAiNames(this)" title="AI ç”Ÿæˆå¤šä¸ªåå­—ä¾›é€‰æ‹©">ğŸ”®</button>
                      </div>
                  </div>
                  <div style="flex:1"><label for="gender">æ€§åˆ«</label><input id="gender" placeholder="ä¾‹ï¼šå¥³" /></div>
              </div>
          </div>
          <div class="field-group">
            <label for="description">ç®€ä»‹</label>
            <textarea id="description" rows="5" placeholder="è§’è‰²çš„èº«ä»½ã€å¤–è²Œã€èƒŒæ™¯æ•…äº‹ç­‰ã€‚ä¼šæ˜¾ç¤ºåœ¨è§’è‰²å¡ä¸Šã€‚"></textarea>
            <button class="ai-button" onclick="callDeepSeek('description')">ğŸ”® AI å¸®æˆ‘å†™</button>
            <button class="ai-undo-button" onclick="undoAiCompletion(this)">â†©ï¸ æ’¤é”€</button>
          </div>
          <div class="field-group">
            <label for="tags">åˆ†ç±»æ ‡ç­¾(é€—å·åˆ†éš”)</label>
            <textarea id="tags" rows="2" placeholder="ä¸ºè§’è‰²æ·»åŠ æ ‡ç­¾ï¼Œæ–¹ä¾¿æŸ¥æ‰¾ã€‚ä¾‹ï¼šåŸåˆ›, æ¸¸æˆ, OOC "></textarea>
            <button class="ai-button" onclick="callDeepSeek('tags')">ğŸ”® AI å¸®æˆ‘å†™</button>
            <button class="ai-undo-button" onclick="undoAiCompletion(this)">â†©ï¸ æ’¤é”€</button>
          </div>
          <div class="field-group">
            <label for="personality">ä¸ªæ€§</label>
            <textarea id="personality" rows="2" placeholder="è¯¦ç»†æ€§æ ¼ç‰¹è´¨ã€‚ä¾‹ï¼šå–„äºè¨€è¾, æ€æƒ³æˆç†Ÿ, ç—…å¨‡ (é€—å·åˆ†éš”)"></textarea>
            <button class="ai-button" onclick="callDeepSeek('personality')">ğŸ”® AI å¸®æˆ‘å†™</button>
            <button class="ai-undo-button" onclick="undoAiCompletion(this)">â†©ï¸ æ’¤é”€</button>
          </div>

          <h3 class="section-title" id="ai-settings-title">AIè®¾å®š</h3>
           <div class="field-group">
            <label for="system_prompt">äººæ ¼è®¾å®š</label>
            <textarea id="system_prompt" rows="3" placeholder="AIå¿…é¡»éµå®ˆçš„æ ¸å¿ƒè®¾å®šã€‚ä¾‹ï¼šä½ æ˜¯[åå­—]ï¼Œä¸€ä¸ª[èº«ä»½]ã€‚ä½ å¿…é¡»ç§°å‘¼ç”¨æˆ·ä¸ºâ€œäº²çˆ±çš„â€ã€‚"></textarea>
             <button class="ai-button" onclick="callDeepSeek('system_prompt')">ğŸ”® AI å¸®æˆ‘å†™</button>
             <button class="ai-undo-button" onclick="undoAiCompletion(this)">â†©ï¸ æ’¤é”€</button>
          </div>
          <div class="field-group">
            <label for="scenario">åœºæ™¯è®¾å®š</label>
            <textarea id="scenario" rows="3" placeholder="è§’è‰²ä¸ç”¨æˆ·æ‰€å¤„çš„ç¯å¢ƒã€‚ä¾‹ï¼š{{char}}å’Œ{{user}}åœ¨é»„æ˜çš„æ•™å®¤é‡Œã€‚"></textarea>
             <button class="ai-button" onclick="callDeepSeek('scenario')">ğŸ”® AI å¸®æˆ‘å†™</button>
             <button class="ai-undo-button" onclick="undoAiCompletion(this)">â†©ï¸ æ’¤é”€</button>
          </div>
          <div class="field-group">
            <label for="first_mes">é—®å€™æ¶ˆæ¯</label>
            <textarea id="first_mes" rows="3" placeholder="è§’è‰²å‡ºåœºæ—¶è¯´çš„ç¬¬ä¸€å¥è¯ã€‚"></textarea>
            <button class="ai-button" onclick="callDeepSeek('first_mes')">ğŸ”® AI å¸®æˆ‘å†™</button>
            <button class="ai-undo-button" onclick="undoAiCompletion(this)">â†©ï¸ æ’¤é”€</button>
          </div>
          <div class="field-group">
            <label for="mes_example">ç¤ºä¾‹æ¶ˆæ¯</label>
            <textarea id="mes_example" rows="6" placeholder="æä¾›å‡ æ®µå¯¹è¯èŒƒä¾‹ï¼ŒAIä¼šæ¨¡ä»¿å…¶é£æ ¼ã€‚æä¸ºé‡è¦ï¼
ä¾‹å¦‚ï¼š
<START>ï¼ˆç”¨äºæ¯æ¬¡å¯¹è¯çš„å¼€å¤´ï¼‰
{{user}}: ä½ å¥½ã€‚
{{char}}: (å¾®ç¬‘ç€å‘ä½ ç‚¹å¤´) ä½ å¥½ï¼Œ{{user}}ã€‚æ‰¾æˆ‘æœ‰ä»€ä¹ˆäº‹å—ï¼Ÿ"></textarea>
            <button class="ai-button" onclick="callDeepSeek('mes_example')">ğŸ”® AI å¸®æˆ‘å†™</button>
            <button class="ai-undo-button" onclick="undoAiCompletion(this)">â†©ï¸ æ’¤é”€</button>
          </div>

          <h3 class="section-title" id="advanced-settings-title">é«˜çº§è®¾å®š</h3>
           <div class="field-group">
            <label for="post_history_instructions">åæœŸæŒ‡ä»¤</label>
            <textarea id="post_history_instructions" rows="3" placeholder="é…’é¦†ç”¨å®ƒæ¥ä¿®æ”¹AIçš„å›å¤æ ¼å¼ã€‚ä¾‹å¦‚ï¼Œè¦è®©{{char}}çš„åŠ¨ä½œéƒ½ç”¨æ˜Ÿå·åŒ…å›´ï¼Œå¯ä»¥å†™ï¼šå°†{{char}}çš„æ‰€æœ‰åŠ¨ä½œå’Œå™è¿°éƒ½æ”¾åœ¨æ˜Ÿå·ï¼ˆ*ï¼‰ä¹‹é—´ã€‚"></textarea>
            <div class="template-buttons" id="post-history-templates">
              <button id="btn-template-options" onclick="setPostHistoryTemplate('template-options-mode')"></button>
              <button id="btn-template-parentheses" onclick="setPostHistoryTemplate('template-parentheses-mode')"></button>
              <button id="btn-template-status-bar" onclick="setPostHistoryTemplate('template-status-bar')"></button>
              <button id="btn-template-third-person" onclick="setPostHistoryTemplate('template-third-person')"></button>
              <button id="btn-template-json-mode" onclick="setPostHistoryTemplate('template-json-mode')"></button>
              <button id="btn-template-image-prompt" onclick="setPostHistoryTemplate('template-image-prompt')"></button>
            </div>
          </div>
          <div class="field-group">
            <label for="creator_notes">åˆ›ä½œè€…ç¬”è®°</label>
            <textarea id="creator_notes" rows="2"></textarea>
          </div>
          <div class="field-group">
            <label for="character_version">è§’è‰²ç‰ˆæœ¬</label>
            <input id="character_version" />
          </div>

          <div style="display: flex; justify-content: space-between; align-items: center;">
             <h3 class="section-title" id="world-knowledge-book-title">è§’è‰²ä¹¦/ä¸–ç•Œä¹¦</h3>
             <button id="ai-lorebook-generator-btn" onclick="openWorldbookAiModal(this)" style="background-color: var(--ai-button-bg); color: white; padding: 8px 15px; border-radius: 5px;">ğŸ”® AIç”Ÿæˆå‚è€ƒæ¡ç›®</button>
          </div>
          <p class="help-text" id="worldbook-help-text">
              </p>
          <ul id="worldbook-entries-container" class="worldbook-list"></ul>
          <div class="action-buttons row" style="margin-top: 15px;">
            <div class="lover-switch-container">
                <span class="switch-label" id="companion-mode-label">ä¼´ä¾£æ¨¡å¼</span>
                <label class="switch">
                    <input type="checkbox" id="lover-switch">
                    <span class="slider"></span>
                </label>
            </div>
            <button onclick="addWorldbookEntry()" class="secondary" style="background-color: #e67e22; flex-grow: 1;">+ æ·»åŠ æ–°æ¡ç›®</button>
            <button onclick="sortWorldbookEntries()" class="secondary" style="flex-grow: 1;">ğŸ”„ æŒ‰IDå¤§å°æ’åº</button>
          </div>

        </div>
      </div>
    </div>
  </div>

<script>
// --- å›½é™…åŒ–æ”¯æŒ ---
let currentLanguage = localStorage.getItem('language') || 'zh';

const translations = {
    zh: {
        // æ ‡é¢˜å’ŒæŒ‰é’®
        'app-title': 'å¦®å¡è§’è‰²å·¥ä½œå®¤Pro',
        'create-new-character': 'åˆ›å»ºæ–°è§’è‰²/ä¹¦',
        'import-character': 'ğŸ“¥ å¯¼å…¥',
        'edit-character': 'ç¼–è¾‘è§’è‰²',
        'save-and-return': 'ğŸ’¾ å‚¨å­˜å¹¶è¿”å›è§’è‰²åº“',
        'return-without-save': 'ğŸ”™ è¿”å› (ä¸å‚¨å­˜)',
        'download-json': 'ğŸ“¥ ä¸‹è½½ JSON',
        'download-png': 'ğŸ“¥ ä¸‹è½½ PNG è§’è‰²å¡',
        'download-lorebook': 'ğŸ“¥ ä¸‹è½½ä¸ºä¸–ç•Œä¹¦',
        'upload-image': 'ä¸Šä¼ å›¾ç‰‡',
        'edit': 'ç¼–è¾‘',
        'export': 'å¯¼å‡º',
        'add-tag': 'æ·»åŠ æ ‡ç­¾',
        'delete': 'åˆ é™¤',
        'add-new-entry': '+ æ·»åŠ æ–°æ¡ç›®',
        'sort-by-id': 'ğŸ”„ æŒ‰IDå¤§å°æ’åº',
        'ai-generate-entries': 'ğŸ”® AIç”Ÿæˆå‚è€ƒæ¡ç›®',
        'ai-help-write': 'ğŸ”® AI å¸®æˆ‘å†™',
        'undo': 'â†©ï¸ æ’¤é”€',
        'generate-companion': 'ğŸ”® ç”Ÿæˆè™šæ‹Ÿä¼´ä¾£',
        'complete-all': 'ğŸ”® ä¸€é”®è¡¥å…¨æ‰€æœ‰',
        'translate-all': 'ğŸŒ ä¸€é”®ç¿»è¯‘',
        'undo-translation': 'æ’¤é”€ç¿»è¯‘',
        
        // æ ‡ç­¾è¿‡æ»¤
        'tag-filter': 'æ ‡ç­¾è¿‡æ»¤',
        'no-characters-found': 'æ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„è§’è‰²ã€‚å°è¯•æ¸…é™¤è¿‡æ»¤å™¨æˆ–å¯¼å…¥æ–°çš„è§’è‰²å¡ã€‚',
        
        // è¡¨å•æ ‡ç­¾
        'avatar-label': 'è§’è‰²å¤´åƒ',
        'avatar-upload': 'ä¸Šä¼ å›¾ç‰‡',
        'character-info': 'è§’è‰²ä¿¡æ¯',
        'topic': 'ä¸»é¢˜',
        'topic-placeholder': 'ä¾‹ï¼šèµ›åšæœ‹å…‹, å¥‡å¹», æ ¡å›­',
        'name': 'åå­—',
        'name-placeholder': 'ä¾‹ï¼šMonika',
        'gender': 'æ€§åˆ«',
        'gender-placeholder': 'ä¾‹ï¼šå¥³',
        'description': 'ç®€ä»‹',
        'description-placeholder': 'è§’è‰²çš„èº«ä»½ã€å¤–è²Œã€èƒŒæ™¯æ•…äº‹ç­‰ã€‚ä¼šæ˜¾ç¤ºåœ¨è§’è‰²å¡ä¸Šã€‚',
        'tags': 'åˆ†ç±»æ ‡ç­¾',
        'tags-placeholder': 'ä¸ºè§’è‰²æ·»åŠ æ ‡ç­¾ï¼Œæ–¹ä¾¿æŸ¥æ‰¾ã€‚ä¾‹ï¼šåŸåˆ›, æ¸¸æˆ, OOC',
        'personality': 'ä¸ªæ€§',
        'personality-placeholder': 'è¯¦ç»†æ€§æ ¼ç‰¹è´¨ã€‚ä¾‹ï¼šå–„äºè¨€è¾, æ€æƒ³æˆç†Ÿ, ç—…å¨‡ (é€—å·åˆ†éš”)',
        'ai-settings': 'AIè®¾å®š',
        'system-prompt': 'äººæ ¼è®¾å®š',
        'system-prompt-placeholder': 'AIå¿…é¡»éµå®ˆçš„æ ¸å¿ƒè®¾å®šã€‚ä¾‹ï¼šä½ æ˜¯[åå­—]ï¼Œä¸€ä¸ª[èº«ä»½]ã€‚ä½ å¿…é¡»ç§°å‘¼ç”¨æˆ·ä¸ºâ€œäº²çˆ±çš„â€ã€‚',
        'scenario': 'åœºæ™¯è®¾å®š',
        'scenario-placeholder': 'è§’è‰²ä¸ç”¨æˆ·æ‰€å¤„çš„ç¯å¢ƒã€‚ä¾‹ï¼š{{char}}å’Œ{{user}}åœ¨é»„æ˜çš„æ•™å®¤é‡Œã€‚',
        'first-message': 'é—®å€™æ¶ˆæ¯',
        'first-message-placeholder': 'è§’è‰²å‡ºåœºæ—¶è¯´çš„ç¬¬ä¸€å¥è¯ã€‚',
        'message-example': 'ç¤ºä¾‹æ¶ˆæ¯',
        'message-example-placeholder': 'æä¾›å‡ æ®µå¯¹è¯èŒƒä¾‹ï¼ŒAIä¼šæ¨¡ä»¿å…¶é£æ ¼ã€‚æä¸ºé‡è¦ï¼š\n<START>ï¼ˆæ¯å›å¯¹è¯éƒ½ä»¥<START>å¼€å¤´ï¼‰\n{{user}}: ä½ å¥½ã€‚\n{{char}}: (å¾®ç¬‘ç€å‘ä½ ç‚¹å¤´) ä½ å¥½ï¼Œ{{user}}ã€‚æ‰¾æˆ‘æœ‰ä»€ä¹ˆäº‹å—ï¼Ÿ',
        'advanced-settings': 'é«˜çº§è®¾å®š',
        'post-history-instructions': 'åæœŸæŒ‡ä»¤',
        'post-history-instructions-placeholder': 'é…’é¦†ç”¨å®ƒæ¥ä¿®æ”¹AIçš„å›å¤æ ¼å¼ã€‚ä¾‹å¦‚ï¼Œè¦è®©{{char}}çš„åŠ¨ä½œéƒ½ç”¨æ˜Ÿå·åŒ…å›´ï¼Œå¯ä»¥å†™ï¼šå°†{{char}}çš„æ‰€æœ‰åŠ¨ä½œå’Œå™è¿°éƒ½æ”¾åœ¨æ˜Ÿå·ï¼ˆ*ï¼‰ä¹‹é—´ã€‚',
        'creator-notes': 'åˆ›ä½œè€…ç¬”è®°',
        'creator-notes-placeholder': 'ç»™å…¶ä»–ç”¨æˆ·çš„ç•™è¨€æˆ–ç‰ˆæœ¬è¯´æ˜ã€‚',
        'character-version': 'è§’è‰²ç‰ˆæœ¬',
        'character-version-placeholder': 'ä¾‹å¦‚ï¼š1.0, 2.1.3',
        'world-knowledge-book': 'è§’è‰²ä¹¦/ä¸–ç•Œä¹¦',
        'companion-mode': 'ä¼´ä¾£æ¨¡å¼',
        
        // ä¸–ç•Œä¹¦ç›¸å…³
        'worldbook-help': 'â€œè§’è‰²ä¹¦â€æ˜¯ç»™AIè§’è‰²ç»‘å®šçš„ä¸€éƒ¨<b>å‚è€ƒè¯å…¸å’Œè®¾å®šé›†</b>ã€‚å¦‚æœä½ è¦ä¸–ç•Œä¹¦ï¼Œä¸Šé¢çš„ä¿¡æ¯åªç”¨å¡«åå­—',
        'entry-comment': 'æ¡ç›®æ³¨é‡Š',
        'entry-comment-placeholder': 'æ¡ç›®æ³¨é‡Š',
        'main-keys': 'è¯æ¡',
        'main-keys-placeholder': 'ä¾‹å¦‚: èª“çº¦èƒœåˆ©ä¹‹å‰‘, Excalibur æˆ–è€… ä¸–ç•Œè®¾å®šå‰§æƒ…ä¸»çº¿ï¼ˆè¦å¼€å¯é«˜çº§è®¾å®šâ€œæ’å®šæ³¨å…¥â€ï¼‰ä¹‹ç±»',
        'secondary-keys': 'æ¬¡è¦å…³é”®è¯',
        'secondary-keys-placeholder': 'ä¾‹å¦‚: å‰‘, æ­¦å™¨',
        'injection-content': 'å†…å®¹',
        'injection-content-placeholder': 'å½“å…³é”®è¯è¢«è§¦å‘æ—¶ï¼Œè¿™æ®µå†…å®¹ä¼šè¢«å‘é€ç»™AIã€‚',
        'entry-id': 'æ¡ç›®ID',
        'entry-id-placeholder': 'æ•°å­—ï¼Œå†³å®šæ¡ç›®è¢«å‘é€çš„é¡ºåº',
        'entry-priority': 'ä¼˜å…ˆçº§',
        'entry-priority-placeholder': 'æ•°å­—ï¼Œå†³å®šæ¡ç›®è¢«å‘é€çš„é¡ºåº',
        'entry-position': 'æ³¨å…¥ä½ç½®',
        'entry-scope': 'ä½œç”¨åŸŸ',
        'priority-preset-prereq': 'å‰æ',
        'priority-preset-important': 'é‡è¦',
        'priority-preset-normal': 'æ™®é€š',
        'entry-enabled': 'å¯ç”¨',
        'entry-constant': 'æ’å®šæ³¨å…¥',
        'entry-selective': 'é€‰æ‹©æ€§æ³¨å…¥',
        'entry-use-regex': 'æ­£åˆ™åŒ¹é…',
        'entry-prevent-recursion': 'é˜»æ­¢é€’å½’',
        'entry-group': 'åˆ†ç»„',
        'entry-group-placeholder': 'åˆ†ç»„åç§°',
        'entry-probability': 'è§¦å‘æ¦‚ç‡ (%)',
        'entry-probability-placeholder': '0-100',
        'entry-depth': 'è®°å¿†æ‰«ææ·±åº¦',
        'entry-depth-placeholder': 'æ•°å­—',
        'match-whole-words': 'å…¨è¯åŒ¹é…',
        'case-sensitive': 'åŒºåˆ†å¤§å°å†™',
        
        // é”™è¯¯å’Œæç¤ºä¿¡æ¯
        'db-timeout': 'æ•°æ®åº“è¿æ¥è¶…æ—¶ã€‚è¯·å°è¯•å…³é—­æ‰€æœ‰å…¶ä»–æ ‡ç­¾é¡µï¼Œå¹¶å¼ºåˆ¶åˆ·æ–°(Ctrl+F5)ã€‚å¦‚æœé—®é¢˜ä»ç„¶å­˜åœ¨ï¼Œè¯·å°è¯•æ¸…é™¤ç½‘ç«™æ•°æ®ã€‚',
        'db-error': 'é”™è¯¯ï¼šæ— æ³•è¿æ¥åˆ°æœ¬åœ°æ•°æ®åº“ã€‚\n\nè¯¦ç»†ä¿¡æ¯: {error}\n\næ‚¨çš„è§’è‰²å°†æ— æ³•ä¿å­˜æˆ–è¯»å–ã€‚è¯·æ£€æŸ¥æµè§ˆå™¨è®¾ç½®(å¦‚éšç§ä¿æŠ¤ã€ç¦æ­¢Cookieç­‰)æˆ–å°è¯•æ¸…é™¤ç½‘ç«™æ•°æ®ã€‚',
        'db-blocked': 'æ•°æ®åº“è¿æ¥è¢«é˜»å¡ï¼\n\nè¯·å…³é—­æ‰€æœ‰å…¶ä»–æ‰“å¼€æ­¤é¡µé¢çš„æµè§ˆå™¨æ ‡ç­¾é¡µï¼Œç„¶åå¼ºåˆ¶åˆ·æ–°(Ctrl+F5)æ­¤é¡µé¢ã€‚',
        'db-not-ready': 'æ•°æ®åº“å°šæœªå‡†å¤‡å¥½ï¼Œè¯·ç¨ç­‰ç‰‡åˆ»æˆ–åˆ·æ–°é¡µé¢å†è¯•ã€‚',
        'import-png-failed': 'å¯¼å…¥ PNG è§’è‰²å¡å¤±è´¥: {error}',
        'import-image-failed': 'å¯¼å…¥å›¾ç‰‡å¤±è´¥: {error}',
        'import-json-failed': 'å¯¼å…¥å¤±è´¥ï¼ŒJSON æ–‡ä»¶æ ¼å¼æ— æ•ˆã€‚',
        'save-import-failed': 'ä¿å­˜å¯¼å…¥çš„è§’è‰²å¤±è´¥ã€‚',
        'character-saved': 'è§’è‰² "{name}" å·²ä¿å­˜ã€‚',
        'save-failed': 'ä¿å­˜è§’è‰²å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ•°æ®æˆ–å›¾ç‰‡æ ¼å¼ã€‚',
        'upload-image-only': 'è¯·ä¸Šä¼ å›¾ç‰‡æ ¼å¼çš„æ–‡ä»¶ï¼ˆæ”¯æŒPNGã€JPGã€JPEGã€WEBPã€GIFã€BMPç­‰ï¼‰ã€‚',
        'image-process-failed': 'å›¾ç‰‡å¤„ç†å¤±è´¥: {error}',
        'file-read-error': 'è¯»å–æ–‡ä»¶æ—¶å‡ºé”™ã€‚',
        'file-read-error-with-name': 'è¯»å–æ–‡ä»¶ {name} æ—¶å‡ºé”™: {error}',
        'ai-return-not-array': 'AIè¿”å›çš„ä¸æ˜¯ä¸€ä¸ªæ•°ç»„ã€‚',
        'ai-parse-failed': 'AIè¿”å›çš„æ•°æ®æ ¼å¼ä¸æ­£ç¡®ï¼Œæ— æ³•è§£æã€‚è¯·åœ¨å¼€å‘è€…æ§åˆ¶å°æŸ¥çœ‹è¯¦æƒ…ã€‚',
        'already-root-entry': 'å·²ç»æ˜¯æ ¹æ¡ç›®ï¼Œæ— æ³•é€€å‡ºï¼ˆå–æ¶ˆç¼©è¿›ï¼‰ã€‚',
        'no-description': 'æ— æè¿°',
        
        // å¸®åŠ©æ–‡æœ¬
        'help-id-drop': 'ã€æ¡ç›®æ³¨é‡Šã€‘ç»™è‡ªå·±çœ‹çš„å°æ ‡é¢˜ï¼Œæ–¹ä¾¿è¯†åˆ«æ¡ç›®ç”¨é€”ã€‚\nã€æ’åºID+ç©ºæŠ•â¡ï¸ã€‘å¯ä»¥å¿«é€Ÿç»™æ¡ç›®é‡æ–°æ’å·ã€‚',
        'help-main-keys': 'è¿™æ˜¯è§¦å‘å™¨ï¼Œå†³å®šAIä½•æ—¶â€œæŸ¥é˜…â€è¿™æ¡å†…å®¹ã€‚\nç”¨æ³•ï¼šè¾“å…¥ä¸€ä¸ªæˆ–å¤šä¸ªè¯ï¼Œç”¨é€—å·éš”å¼€ã€‚\nä¾‹ï¼šå…³é”®è¯è®¾ä¸º`è‹¹æœ,é¦™è•‰`ï¼Œå½“ç”¨æˆ·æåˆ°`è‹¹æœ`æˆ–`é¦™è•‰`æ—¶ï¼Œæ­¤æ¡ç›®å°±ä¼šè¢«è§¦å‘ã€‚',
        'help-secondary-keys': 'è¿™æ˜¯â€œäºŒæ¬¡éªŒè¯â€ï¼Œä¸ºä¸»å…³é”®è¯å¢åŠ é¢å¤–çš„è§¦å‘æ¡ä»¶ã€‚\nç”¨æ³•ï¼šå’Œä¸»å…³é”®è¯é…åˆä½¿ç”¨ï¼Œè¿›ä¸€æ­¥è¿‡æ»¤å¯¹è¯ã€‚\nä¾‹ï¼šä¸»å…³é”®è¯æ˜¯`æ”»å‡»`ï¼ŒäºŒæ¬¡éªŒè¯è®¾ä¸ºã€éä»»æ„ã€‘`å–æ¶ˆ`ï¼Œé‚£ä¹ˆåªæœ‰å½“ç”¨æˆ·è¯´äº†`æ”»å‡»`ä½†æ²¡è¯´`å–æ¶ˆ`æ—¶ï¼Œæ¡ç›®æ‰ä¼šç”Ÿæ•ˆã€‚',
        'help-injection-content': 'å½“æ¡ç›®è¢«è§¦å‘æ—¶ï¼ŒAIä¼šâ€œæŸ¥é˜…â€çš„å†…å®¹ã€‚\nç”¨æ³•ï¼šå¡«å†™å¸Œæœ›AIåœ¨ç‰¹å®šæƒ…å¢ƒä¸‹çŸ¥é“çš„ä¿¡æ¯ã€‚\nä¾‹ï¼šå…³é”®è¯æ˜¯`æˆ‘çš„å‰‘`ï¼Œè¿™é‡Œå¯ä»¥å†™`é‚£æ˜¯ä¸€æŠŠç”Ÿé”ˆçš„é“å‰‘ï¼Œæ˜¯çˆ¶äº²çš„é—ç‰©ã€‚`',
        'help-entry-id': 'å†³å®šäº†æ¡ç›®çš„åŸºç¡€æ’åˆ—é¡ºåºã€‚\nç”¨æ³•ï¼šæ•°å­—è¶Šå°ï¼Œè¶Šé å‰ã€‚\nä¾‹ï¼šIDä¸º0çš„æ¡ç›®ä¼šæ¯”IDä¸º1çš„æ¡ç›®å…ˆè¢«å¤„ç†ã€‚',
        'help-entry-priority': 'å†³å®šäº†å½“å¤šä¸ªæ¡ç›®åŒæ—¶è¢«è§¦å‘æ—¶ï¼Œå“ªä¸ªæ¡ç›®è¯´äº†ç®—ã€‚\nç”¨æ³•ï¼šæ•°å­—è¶Šå¤§ï¼ŒæƒåŠ›è¶Šå¤§ã€‚\nä¾‹ï¼š`Aæ¡ç›®(ä¼˜å…ˆçº§100)`å’Œ`Bæ¡ç›®(ä¼˜å…ˆçº§200)`éƒ½è¢«è§¦å‘ï¼ŒAIä¼šä¼˜å…ˆå¬`Bæ¡ç›®`çš„ï¼ˆéœ€å¼€å¯â€œé€‰æ‹©æ€§æ³¨å…¥â€ï¼‰ã€‚',
        'help-entry-position': 'å†³å®šäº†è¿™æ¡å†…å®¹åœ¨ç»™AIçš„â€œå‰§æœ¬â€é‡Œçš„æ‘†æ”¾ä½ç½®ã€‚\nç”¨æ³•ï¼šé€šå¸¸é»˜è®¤å³å¯ã€‚æƒ³å¼ºè°ƒæ—¶å¯é€‰â€œæœ€å¼€å¤´â€ã€‚',
        'help-entry-scope': 'å†³å®šäº†AIåœ¨ä»€ä¹ˆæ—¶å€™ä¼šå»â€œæŸ¥é˜…â€è¿™æœ¬ä¹¦ã€‚\nç”¨æ³•ï¼šä¸€èˆ¬ä¿æŒé»˜è®¤â€œèŠå¤©ä¸­â€å³å¯ã€‚å…¶ä»–é€‰é¡¹ç”¨äºç‰¹æ®Šæ ¼å¼æ§åˆ¶ã€‚',
        'help-entry-enabled': 'è¿™ä¸ªæ¡ç›®çš„â€œå¼€å…³â€ã€‚\nç”¨æ³•ï¼šå–æ¶ˆå‹¾é€‰å¯æš‚æ—¶ç¦ç”¨æ­¤æ¡ç›®ï¼Œè€Œæ— éœ€åˆ é™¤ã€‚',
        'help-entry-constant': 'å°†å†…å®¹å˜æˆAIçš„â€œè‚Œè‚‰è®°å¿†â€ã€‚\næ•ˆæœï¼šæ— è®ºå…³é”®è¯æ˜¯å¦è¢«è§¦å‘ï¼Œè¿™é‡Œçš„å†…å®¹éƒ½ä¼šåœ¨æ¯æ¬¡å¯¹è¯æ—¶æ³¨å…¥ç»™AIã€‚\nç”¨é€”ï¼šé€‚åˆå­˜æ”¾è§’è‰²ç»å¯¹ä¸èƒ½å¿˜è®°çš„æ ¸å¿ƒè®¾å®šã€‚',
        'help-entry-selective': 'å¼€å¯â€œä¼˜èƒœåŠ£æ±°â€æ¨¡å¼ã€‚\næ•ˆæœï¼šå‹¾é€‰åï¼Œåœ¨åŒæ—¶è§¦å‘çš„æ¡ç›®ä¸­ï¼Œåªæœ‰ä¼˜å…ˆçº§æœ€é«˜çš„é‚£ä¸ªä¼šè¢«æ³¨å…¥ã€‚å¦åˆ™æ‰€æœ‰è§¦å‘çš„éƒ½ä¼šæ³¨å…¥ã€‚',
        'help-entry-use-regex': 'å¯ç”¨â€œç¨‹åºå‘˜æ¨¡å¼â€æ¥è®¾ç½®å…³é”®è¯ã€‚\nç”¨æ³•ï¼šå…è®¸ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æ¥è®¾ç½®æ›´å¤æ‚çš„å…³é”®è¯åŒ¹é…è§„åˆ™ï¼Œä¸æ‡‚ç¼–ç¨‹å»ºè®®ä¸å‹¾é€‰ã€‚',
        'help-entry-prevent-recursion': 'é˜²æ­¢AIâ€œè‡ªå·±è·Ÿè‡ªå·±è¯´è¯â€ã€‚\næ•ˆæœï¼šé˜²æ­¢ä¸€ä¸ªæ¡ç›®çš„æ³¨å…¥å†…å®¹ï¼Œåˆè§¦å‘äº†å¦ä¸€ä¸ªæ¡ç›®ï¼Œå½¢æˆæ— é™å¾ªç¯ã€‚å»ºè®®ä¿æŒå‹¾é€‰ã€‚',
        'help-entry-group': 'ç»™æ¡ç›®â€œè´´æ ‡ç­¾â€ï¼Œæ–¹ä¾¿ç®¡ç†ã€‚\nç”¨æ³•ï¼šç»™é€»è¾‘ç›¸å…³çš„æ¡ç›®è®¾ç½®åŒä¸€ä¸ªåˆ†ç»„åï¼Œå¯ç”¨äºå…¶ä»–é«˜çº§åŠŸèƒ½ã€‚',
        'help-entry-probability': 'è®©AIâ€œçœ‹å¿ƒæƒ…â€æŸ¥é˜…è¿™æ¡å†…å®¹ã€‚\nç”¨æ³•ï¼šè®¾ä¸º80ï¼Œåˆ™æ­¤æ¡ç›®è¢«å…³é”®è¯è§¦å‘åï¼Œæœ‰80%çš„å‡ ç‡ç”Ÿæ•ˆã€‚\nç”¨é€”ï¼šå¯ä»¥å¢åŠ AIè¡Œä¸ºçš„éšæœºæ€§ã€‚',
        'help-entry-depth': 'å†³å®šAIâ€œè®°æ€§æœ‰å¤šå¥½â€ã€‚\nç”¨æ³•ï¼šè®¾ä¸º5ï¼ŒAIä¼šæ£€æŸ¥æœ€è¿‘5è½®å¯¹è¯é‡Œæœ‰æ²¡æœ‰å…³é”®è¯ã€‚æ•°å­—è¶Šå¤§ï¼ŒAIçœ‹å¾—è¶Šè¿œï¼Œä½†ä¹Ÿä¼šæ¶ˆè€—æ›´å¤šæ€§èƒ½ã€‚',
        'help-match-whole-words': 'å¼€å¯â€œç²¾ç¡®æŸ¥æ‰¾â€æ¨¡å¼ã€‚\næ•ˆæœï¼šè¦æ±‚å…³é”®è¯å¿…é¡»æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„è¯æ‰è§¦å‘ã€‚\nä¾‹ï¼šå…³é”®è¯ä¸º`çˆ±`ã€‚å‹¾é€‰åï¼Œåªæœ‰å½“ç”¨æˆ·è¯´`çˆ±`è¿™ä¸ªå­—æ—¶æ‰ç®—ï¼Œ`çƒ­çˆ±`ã€`çˆ±æƒ…`è¿™äº›è¯ä¸ç®—ã€‚',
        'help-case-sensitive': 'è®©AIâ€œæ³¨æ„å¤§å°å†™â€ã€‚\næ•ˆæœï¼šå‹¾é€‰åï¼Œå…³é”®è¯çš„å¤§å°å†™å¿…é¡»å®Œå…¨ä¸€æ ·æ‰èƒ½è§¦å‘ã€‚\nä¾‹ï¼šå…³é”®è¯ä¸º`Apple`ï¼Œåˆ™`apple`ä¸ä¼šè§¦å‘ã€‚ä¸€èˆ¬ç”¨äºè‹±æ–‡ã€‚',

        // APIç›¸å…³
        'api-key-placeholder': 'è¾“å…¥ DeepSeek API Key',
        
        // é»˜è®¤å€¼
        'imported-character': 'ä»å›¾ç‰‡å¯¼å…¥çš„è§’è‰²',
        'imported-lorebook': 'å¯¼å…¥çš„è§’è‰²ä¹¦',
        'lorebook-description': 'ä»SillyTavernå¯¼å…¥çš„è§’è‰²ä¹¦ã€‚',
        'lorebook-tag': 'è§’è‰²ä¹¦',

        // ç¡®è®¤å¯¹è¯æ¡†
        'confirm-overwrite-worldbook': 'è¿™ä¼šæ‰“å¼€AIç”Ÿæˆå¼¹çª—ï¼Œä½†ä¸ä¼šè¦†ç›–ç°æœ‰æ¡ç›®ã€‚ä½ å¯ä»¥é€‰æ‹©æ€§æ³¨å…¥æ–°æ¡ç›®ã€‚ç»§ç»­å—ï¼Ÿ',
        
        // æˆåŠŸæ¶ˆæ¯
        'worldbook-generated-success': 'å·²æˆåŠŸç”Ÿæˆè§’è‰²ä¹¦å‚è€ƒæ¡ç›®ï¼è¯·åœ¨å¼¹çª—ä¸­é€‰æ‹©è¦æ³¨å…¥çš„æ¡ç›®ã€‚',
        'lorebook-injected-success': '{count}ä¸ªæ¡ç›®å·²æˆåŠŸæ³¨å…¥ï¼',
        'all-fields-completed': 'AIå·²è¡¥å…¨æ‰€æœ‰å­—æ®µï¼',
        
        // APIç›¸å…³é”™è¯¯
        'api-request-failed': 'API è¯·æ±‚å¤±è´¥: {status} - {message}',
        'ai-completion-failed': 'AIè¡¥å…¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥API Keyæˆ–ç½‘ç»œè¿æ¥ï¼Œå¹¶æŸ¥çœ‹æ§åˆ¶å°è·å–æ›´å¤šä¿¡æ¯ã€‚',
        'name-generation-failed': 'AIåå­—ç”Ÿæˆå¤±è´¥ï¼Œè¯·æ£€æŸ¥API Keyæˆ–ç½‘ç»œï¼Œå¹¶æŸ¥çœ‹æ§åˆ¶å°ã€‚',
        'ai-guidance-prompt': 'è¯·è¾“å…¥å¯¹AIçš„é¢å¤–å¼•å¯¼æˆ–è¦æ±‚ (å¯é€‰):',
        'ai-guidance-title': 'ä¸ºAIæä¾›æŒ‡å¼•',
        'ai-complete-all-guidance-title': 'ä¸€é”®è¡¥å…¨æ‰€æœ‰å­—æ®µ',
        'ai-complete-all-guidance-placeholder': 'è¯·è¾“å…¥è§’è‰²çš„æ ¸å¿ƒæ¦‚å¿µã€ä¸»é¢˜æˆ–å…³é”®è¯... (ä¾‹ï¼šä¸€ä¸ªåœ¨èµ›åšéƒ½å¸‚ä¸­è¿½å¯»è¿‡å»çš„å¤±å¿†ä¾¦æ¢)',


        // çŠ¶æ€æ–‡æœ¬
        'generating': 'ç”Ÿæˆä¸­...',
        'loading': 'æ­£åœ¨åŠ è½½...',
        'choose-a-name': 'ä¸ºä½ çš„è§’è‰²é€‰æ‹©ä¸€ä¸ªåå­—',
        'regenerate': 'é‡æ–°ç”Ÿæˆ',
        'cancel': 'å–æ¶ˆ',
        'generate': 'ç”Ÿæˆ',

        // Post-history Templates
        'post-history-options-mode': 'é€‰é¡¹æ¨¡å¼',
        'post-history-parentheses-mode': 'æ‹¬å·æ¨¡å¼',
        'post-history-status-bar': 'çŠ¶æ€æ ',
        'post-history-third-person': 'ç¬¬ä¸‰äººç§°',
        'post-history-json-mode': 'JSONæ¨¡å¼',
        'template-options-mode': '[ä»¥ä¸­æ–‡å›å¤] [ç³»ç»ŸæŒ‡ä»¤]: ä½ ç°åœ¨éœ€è¦æ ¹æ®ç”¨æˆ·çš„è¾“å…¥ç”Ÿæˆå›åº”ã€‚å›åº”å¿…é¡»ä¸¥æ ¼éµå¾ªä»¥ä¸‹æ ¼å¼ï¼šä¸ºç”¨æˆ·æä¾›å‡ ä¸ªæ¸…æ™°æ˜ç¡®çš„ä¸‹ä¸€æ­¥è¡ŒåŠ¨æˆ–å¯¹è¯é€‰é¡¹ã€‚æ¯ä¸ªé€‰é¡¹å ä¸€è¡Œï¼Œå¹¶ä»¥å­—æ¯ï¼ˆAã€Bã€Cç­‰ï¼‰å¼€å¤´ã€‚åœ¨é€‰é¡¹åˆ—è¡¨å‰åä¸è¦æ·»åŠ ä»»ä½•é¢å¤–æ–‡å­—ã€‚',
        'template-parentheses-mode': '[ç³»ç»ŸæŒ‡ä»¤]: åœ¨ç”Ÿæˆå›åº”æ—¶ï¼Œè¯·ä½¿ç”¨æ‹¬å·æ¥æè¿°{{char}}çš„åŠ¨ä½œã€è¡¨æƒ…å’Œå†…å¿ƒæƒ³æ³•ã€‚å¯¹è¯æœ¬èº«åº”åœ¨æ‹¬å·ä¹‹å¤–ã€‚ä¾‹å¦‚ï¼š"ä½ åœ¨è¿™é‡Œåšä»€ä¹ˆï¼Ÿ" (å¥¹æŒ‘èµ·ä¸€è¾¹çš„çœ‰æ¯›ï¼ŒåŒè‡‚äº¤å‰ï¼Œçœ¼ç¥ä¸­å¸¦ç€ä¸€ä¸å®¡è§†)ã€‚',
        'template-status-bar': '[ç³»ç»ŸæŒ‡ä»¤]: åœ¨æ¯æ¬¡å›åº”çš„æœ«å°¾ï¼Œä½ å¿…é¡»é™„å¸¦ä¸€ä¸ªæ˜¾ç¤º{{char}}å½“å‰å…³é”®æ•°å€¼çš„çŠ¶æ€æ ã€‚çŠ¶æ€æ å¿…é¡»ç”¨ä»£ç å—(```)åŒ…è£¹ã€‚æ ¼å¼ä¸ºï¼š| ç”Ÿå‘½å€¼: [æ•°å€¼] | ç†æ™º: [æ•°å€¼] | å¯¹{{user}}çš„å¥½æ„Ÿåº¦: [æ•°å€¼] | ä½ç½®: [åœ°ç‚¹] |ã€‚ä½ å¿…é¡»æ ¹æ®å¯¹è¯å†…å®¹ï¼Œåˆä¹é€»è¾‘åœ°æ›´æ–°è¿™äº›æ•°å€¼ã€‚',
        'template-third-person': '[ç³»ç»ŸæŒ‡ä»¤]: ä½¿ç”¨ç¬¬ä¸‰äººç§°å™äº‹è§†è§’æ’°å†™æ‰€æœ‰å›åº”ã€‚åœ¨æŒ‡ä»£{{char}}æ—¶ï¼Œä¸è¦ä½¿ç”¨"æˆ‘"ã€‚åƒå°è¯´æ—ç™½ä¸€æ ·æè¿°{{char}}çš„è¡ŒåŠ¨ã€è¯­è¨€å’Œæ€æƒ³ã€‚å§‹ç»ˆç”¨è§’è‰²çš„åå­—{{char}}æ¥æŒ‡ä»£è§’è‰²ã€‚',
        'template-json-mode': '[ç³»ç»ŸæŒ‡ä»¤]: ä½ æ‰€æœ‰çš„å›åº”éƒ½å¿…é¡»æ˜¯åˆæ³•çš„JSONæ ¼å¼ã€‚è¯¥JSONå¯¹è±¡å¿…é¡»åŒ…å«ä¸‰ä¸ªé”®ï¼š"dialogue" (å­—ç¬¦ä¸²ï¼ŒåŒ…å«è§’è‰²è¯´çš„è¯), "action" (å­—ç¬¦ä¸²ï¼Œæè¿°è§’è‰²çš„åŠ¨ä½œ), "emotion" (å­—ç¬¦ä¸²ï¼Œæè¿°è§’è‰²å½“å‰çš„ä¸»è¦æƒ…ç»ª)ã€‚ä¸è¦åœ¨JSONç»“æ„ä¹‹å¤–è¾“å‡ºä»»ä½•æ–‡å­—ã€‚',
        'post-history-image-prompt': 'æ–‡ç”Ÿå›¾æç¤ºè¯',
        'template-image-prompt': '[SYSTEM]: Loraåï¼šSv5-10ï¼Œè§’è‰²å…³é”®è¯ï¼šSilverWolfV5\nYour response must have a comma-separated list of English keywords before the text for an AI image generator. Describe the character\'s appearance, action, expression, and the background. Use descriptive tagsï¼Œæœ€åè¦æ¢è¡Œ. Example: masterpiece, best quality, è§’è‰²å…³é”®è¯, solo, beautiful detailed eyes, long silver hair, smiling, school uniform, standing in a classroom, from above, <lora:Loraå>',
        
        // AI Lorebook Modal
        'wb-ai-modal-title': 'è§’è‰²ä¹¦ç”Ÿæˆ',
        'wb-ai-modal-desc': 'è¯·é€‰æ‹©è¦ç”Ÿæˆçš„æ¡ç›®ç±»å‹ï¼š',
        'wb-ai-modal-desc-generating': 'AIæ­£åœ¨ç”Ÿæˆä¸€å¥—{type}æ¡ç›®ï¼Œè¯·ç¨å...',
        'wb-ai-modal-desc-generated': 'AIå·²ä¸ºä½ ç”Ÿæˆä¸€å¥—{type}æ¡ç›®ï¼Œè¯·é€‰æ‹©éœ€è¦æ³¨å…¥çš„æ¡ç›®ã€‚',
        'wb-ai-inject-btn': 'æ³¨å…¥é€‰ä¸­æ¡ç›®',
        'wb-ai-regenerate-btn': 'å†ç”Ÿæˆä¸€å¥—',
        'wb-ai-close-btn': 'å…³é—­',
        'wb-ai-type-worldview': 'ä¸–ç•Œè§‚',
        'wb-ai-type-main_plot': 'ä¸»çº¿å‰§æƒ…',
        'wb-ai-type-side_plot': 'æ”¯çº¿å‰§æƒ…',
        'wb-ai-gen-type-btn-worldview': 'ç”Ÿæˆä¸–ç•Œè§‚',
        'wb-ai-gen-type-btn-main-plot': 'ç”Ÿæˆä¸»çº¿å‰§æƒ…',
        'wb-ai-gen-type-btn-side-plot': 'ç”Ÿæˆæ”¯çº¿å‰§æƒ…',
    },
    
    en: {
        // Titles and buttons
        'app-title': 'Nika Character Studio Pro',
        'create-new-character': 'Create New Character/Book',
        'import-character': 'ğŸ“¥ Import',
        'edit-character': 'Edit Character',
        'save-and-return': 'ğŸ’¾ Save and Return to Library',
        'return-without-save': 'ğŸ”™ Return (Don\'t Save)',
        'download-json': 'ğŸ“¥ Download JSON',
        'download-png': 'ğŸ“¥ Download PNG Character Card',
        'download-lorebook': 'ğŸ“¥ Download as Lorebook',
        'upload-image': 'Upload Image',
        'edit': 'Edit',
        'export': 'Export',
        'add-tag': 'Add Tag',
        'delete': 'Delete',
        'add-new-entry': '+ Add New Entry',
        'sort-by-id': 'ğŸ”„ Sort by ID',
        'ai-generate-entries': 'ğŸ”® AI Generate Reference Entries',
        'ai-help-write': 'ğŸ”® AI Help Me Write',
        'undo': 'â†©ï¸ Undo',
        'generate-companion': 'ğŸ”® Generate Virtual Companion',
        'complete-all': 'ğŸ”® One-Click Complete All',
        'translate-all': 'ğŸŒ One-click Translate',
        'undo-translation': 'Undo Translation',
        
        // Tag filtering
        'tag-filter': 'Tag Filter',
        'no-characters-found': 'No matching characters found. Try clearing filters or importing new character cards.',
        
        // Form labels
        'avatar-label': 'Character Avatar',
        'avatar-upload': 'Upload Image',
        'character-info': 'Character Information',
        'topic': 'Topic',
        'topic-placeholder': 'e.g.: Cyberpunk, Fantasy, School',
        'name': 'Name',
        'name-placeholder': 'e.g.: Alice',
        'gender': 'Gender',
        'gender-placeholder': 'e.g.: Female',
        'description': 'Description',
        'description-placeholder': 'The character\'s identity, appearance, background, etc. Will be shown on the character card.',
        'tags': 'Category Tags (comma separated)',
        'tags-placeholder': 'Tags for filtering. e.g.: Original, Game, Yandere (comma separated)',
        'personality': 'Personality',
        'personality-placeholder': 'Detailed personality traits. e.g.: Eloquent, Mature, Yandere (comma separated)',
        'ai-settings': 'AI Settings',
        'system-prompt': 'Personality Setting',
        'system-prompt-placeholder': 'Core rules the AI must follow. e.g.: You are [Name], a [Role]. You must call the user "darling".',
        'scenario': 'Scenario Setting',
        'scenario-placeholder': 'The environment for the scene. e.g.: {{char}} and {{user}} are in a classroom at dusk.',
        'first-message': 'Greeting Message',
        'first-message-placeholder': 'The character\'s first message to the user.',
        'message-example': 'Message Example',
        'message-example-placeholder': 'Example dialogues for the AI to imitate. Very important!',
        'advanced-settings': 'Advanced Settings',
        'post-history-instructions': 'Post Instructions',
        'post-history-instructions-placeholder': 'ST use this to modify AI response format. For example, to make {{char}}\'s actions wrapped in asterisks, write: Put all {{char}}\'s actions and narration between asterisks (*).',
        'creator-notes': 'Creator Notes',
        'creator-notes-placeholder': 'Notes for other users or version info.',
        'character-version': 'Character Version',
        'character-version-placeholder': 'e.g.: 1.0, 2.1.3',
        'world-knowledge-book': 'Character Book/Lore Book',
        'companion-mode': 'Companion Mode',
        
        // Worldbook related
        'worldbook-help': 'You can think of the "Character Book" as a <b>setting reference</b> for the AI. If you only want the world book, you just need to fill in the name in the information above.',
        'entry-comment': 'Entry Comment (Comment)',
        'entry-comment-placeholder': 'Entry Comment (Comment)',
        'main-keys': 'Main Keywords (Keys, comma separated)',
        'main-keys-placeholder': 'e.g.: Excalibur, Holy Sword',
        'secondary-keys': 'Secondary Keywords (Secondary Keys, comma separated)',
        'secondary-keys-placeholder': 'e.g.: sword, weapon',
        'injection-content': 'Injection Content (Content)',
        'injection-content-placeholder': 'When keywords are triggered, this content will be sent to AI.',
        'entry-id': 'Sort ID',
        'entry-id-placeholder': 'Number, affects order',
        'entry-priority': 'Priority',
        'entry-priority-placeholder': 'Number, determines which entry wins',
        'entry-position': 'Injection Position',
        'entry-scope': 'Scope',
        'priority-preset-prereq': 'Prereq',
        'priority-preset-important': 'Important',
        'priority-preset-normal': 'Normal',
        'entry-enabled': 'Enabled',
        'entry-constant': 'Constant',
        'entry-selective': 'Selective',
        'entry-use-regex': 'Use Regex',
        'entry-prevent-recursion': 'Prevent Recursion',
        'entry-group': 'Group',
        'entry-group-placeholder': 'Group name',
        'entry-probability': 'Trigger Probability (%)',
        'entry-probability-placeholder': '0-100',
        'entry-depth': 'Scan Depth',
        'entry-depth-placeholder': 'Number',
        'match-whole-words': 'Match Whole Words',
        'case-sensitive': 'Case-Sensitive',

        
        // Error and prompt messages
        'db-timeout': 'Database connection timeout. Please try closing all other tabs and force refresh (Ctrl+F5). If the problem persists, try clearing site data.',
        'db-error': 'Error: Unable to connect to local database.\n\nDetails: {error}\n\nYour characters cannot be saved or read. Please check browser settings (such as privacy protection, cookie blocking, etc.) or try clearing site data.',
        'db-blocked': 'Database connection blocked!\n\nPlease close all other browser tabs that have this page open, then force refresh (Ctrl+F5) this page.',
        'db-not-ready': 'Database not ready, please wait a moment or refresh the page and try again.',
        'import-png-failed': 'Failed to import PNG character card: {error}',
        'import-image-failed': 'Failed to import image: {error}',
        'import-json-failed': 'Import failed, JSON file format is invalid.',
        'save-import-failed': 'Failed to save imported character.',
        'character-saved': 'Character "{name}" saved.',
        'save-failed': 'Failed to save character, please check data or image format.',
        'upload-image-only': 'Please upload image format files (supports PNG, JPG, JPEG, WEBP, GIF, BMP, etc.).',
        'image-process-failed': 'Image processing failed: {error}',
        'file-read-error': 'Error reading file.',
        'file-read-error-with-name': 'Error reading file {name}: {error}',
        'ai-return-not-array': 'AI did not return an array.',
        'ai-parse-failed': 'AI returned data format is incorrect and cannot be parsed. Please check developer console for details.',
        'already-root-entry': 'Already at root entry, cannot exit (cancel indentation).',
        'no-description': 'No description',
        
        // Help text
        'help-id-drop': 'The [ID Box + â¡ï¸ Button] allows for an "airdrop". Enter a target position (e.g., 5) in the ID box and click â¡ï¸. This entry\'s ID will become 5, and the original entry with ID 5 and all subsequent entries will have their IDs automatically incremented by 1.\n[Entry Comment] is for your own notes, helping you identify the purpose of this entry.',
        'help-main-keys': 'Set one or more keywords, separated by commas. When the user\'s message contains any of these keywords, this entry will be activated, and its "Injection Content" will be sent to the AI.',
        'help-secondary-keys': 'This is an additional activation condition that works with the main keywords to determine if this entry takes effect.\n\n[With Any]: The filter passes if at least one word from this list is in the message.\n[Not Any]: The filter passes if none of the words from this list are in the message.\n[With All]: The filter passes only if all words from this list are in the message.\n[Not All]: The filter passes as long as there is at least one word from the list not present in the message.',
        'help-injection-content': 'When the keywords are triggered, this content will be sent to the AI.',
        'help-entry-id': '[Sort ID] determines which entry the AI sees first within the same level. A smaller number means it comes first.',
        'help-entry-priority': '[Priority] determines which entry wins when multiple triggered entries compete for injection. A higher number means higher priority. Use the quick-set buttons on the right for common values.',
        'help-entry-position': '[Injection Position] determines where this content is placed in the final prompt sent to the AI.\n[Before Character]: Default. The content appears before the character\'s core definition.\n[After Character]: The content appears after the core definition.\n[At the very beginning]: The content is placed at the absolute top of the prompt.',
        'help-entry-scope': '[Scope] determines under what circumstances this entry is checked.\n[In chat]: Default. Checked after every user message.\n[In memory summary]: Checked when generating a conversation memory summary.\n[On chat entry]: Checked every time a new conversation with the character begins.',
        'help-entry-enabled': '[Enabled] Uncheck this to temporarily disable the entry without deleting it.',
        'help-entry-constant': '[Constant] If checked, this entry will always be injected into the prompt, regardless of keywords.',
        'help-entry-selective': '[Selective] If checked, only the highest-priority entry will be injected when multiple entries are triggered. If unchecked, all triggered entries will be injected.',
        'help-entry-use-regex': '[Use Regex] Allows you to use Regular Expressions for more complex keyword matching rules. For advanced users.',
        'help-entry-prevent-recursion': '[Prevent Recursion] Prevents the content of one entry from triggering other entries, avoiding infinite loops.',
        'help-entry-group': '[Group] Assign a group name to an entry to help organize and manage a large number of entries.',
        'help-entry-probability': '[Trigger Probability] Set a number from 0 to 100. This determines the chance that the entry will actually be injected after its keywords are triggered. 100 means it always will.',
        'help-entry-depth': '[Scan Depth] Determines how many turns of conversation history the AI will look back through to check for this entry\'s keywords. A larger number means it looks further back.',
        'help-match-whole-words': '[Match Whole Words] If checked, a keyword is only triggered if it appears as a whole word. For example, if the keyword is "love", it would trigger on "I love you" but not "glove".',
        'case-sensitive': '[Case-Sensitive] If checked, the keyword must match the case of the text exactly to be triggered. For example, if the keyword is "Apple", it will not be triggered by "apple".',

        // API related
        'api-key-placeholder': 'Enter DeepSeek API Key',
        
        // Default values
        'imported-character': 'Character imported from image',
        'imported-lorebook': 'Imported Lorebook',
        'lorebook-description': 'A lorebook imported from SillyTavern.',
        'lorebook-tag': 'lorebook',
        
        // Confirmation dialogs
        'confirm-overwrite-worldbook': 'This will open the AI generation modal, but will not overwrite existing entries. You can selectively inject new entries. Continue?',
        
        // Success messages
        'worldbook-generated-success': 'Successfully generated lorebook reference entries! Please select which entries to inject in the popup.',
        'lorebook-injected-success': '{count} entries have been successfully injected!',
        'all-fields-completed': 'AI has completed all fields!',

        // API related errors
        'api-request-failed': 'API request failed: {status} - {message}',
        'ai-completion-failed': 'AI completion failed, please check API Key or network connection, and check console for more information.',
        'name-generation-failed': 'AI Name Generation failed. Please check your API Key or network and see the console for details.',
        'ai-guidance-prompt': 'Provide additional guidance for the AI (optional):',
        'ai-guidance-title': 'Provide Guidance for AI',
        'ai-complete-all-guidance-title': 'One-Click Complete All Fields',
        'ai-complete-all-guidance-placeholder': 'Enter the core concept, theme, or keywords for your character... (e.g., An amnesiac detective searching for her past in a cyber city)',

        
        // Status text
        'generating': 'Generating...',
        'loading': 'Loading...',
        'choose-a-name': 'Choose a Name for Your Character',
        'regenerate': 'Regenerate',
        'cancel': 'Cancel',
        'generate': 'Generate',

        // Post-history Templates
        'post-history-options-mode': 'Options Mode',
        'post-history-parentheses-mode': 'Parentheses Mode',
        'post-history-status-bar': 'Status Bar',
        'post-history-third-person': 'Third Person',
        'post-history-json-mode': 'JSON Mode',
        'template-options-mode': '[SYSTEM]: You will now generate a response based on the user\'s input. The response must follow a strict format: present the user with a few distinct choices as their next action or dialogue line. Each choice should be on a new line, starting with a letter (A, B, C, etc.). Do not add any text before or after the list of choices.',
        'template-parentheses-mode': '[SYSTEM]: When generating a response, use parentheses to describe {{char}}\'s actions, expressions, and internal thoughts. Dialogue should remain outside of the parentheses. Example: "What are you doing here?" (She raises an eyebrow, a hint of suspicion in her eyes as she crosses her arms).',
        'template-status-bar': '[SYSTEM]: At the end of every response, you must include a status bar that displays {{char}}\'s current key stats. The status bar should be enclosed in code blocks (```). The format is: | Health: [value] | Sanity: [value] | Affection for {{user}}: [value] | Location: [value] |. You must update these values logically based on the conversation.',
        'template-third-person': '[SYSTEM]: Write all responses from a third-person narrative perspective. Do not use "I" or "me" when referring to {{char}}. Describe {{char}}\'s actions, speech, and thoughts as a narrator would. Always refer to the character by their name, {{char}}.',
        'template-json-mode': '[SYSTEM]: All your responses must be in a valid JSON format. The JSON object must have three keys: "dialogue" (a string containing what the character says), "action" (a string describing the character\'s physical action), and "emotion" (a string describing the character\'s current primary emotion). Do not output any text outside of the JSON structure.',
        'post-history-image-prompt': 'Image Prompt',
        'template-image-prompt': '[SYSTEM]: Lora name: Sv5-10, character keyword: SilverWolfV5\nYour response must have a comma-separated list of English keywords before the text for an AI image generator. Describe the character\'s appearance, action, expression, and the background.',
    
        // AI Lorebook Modal
        'wb-ai-modal-title': 'Interactive AI Lore Book Generation',
        'wb-ai-modal-desc': 'Please select the type of entries to generate:',
        'wb-ai-modal-desc-generating': 'The AI is generating a set of {type} entries, please wait...',
        'wb-ai-modal-desc-generated': 'The AI has generated a set of {type} entries. Please select the ones you want to inject.',
        'wb-ai-inject-btn': 'Inject Selected',
        'wb-ai-regenerate-btn': 'Regenerate Set',
        'wb-ai-close-btn': 'Close',
        'wb-ai-type-worldview': 'worldview',
        'wb-ai-type-main_plot': 'main plot',
        'wb-ai-type-side_plot': 'side plot',
        'wb-ai-gen-type-btn-worldview': 'Generate Worldview',
        'wb-ai-gen-type-btn-main-plot': 'Generate Main Plot',
        'wb-ai-gen-type-btn-side-plot': 'Generate Side Plot',
    }
};

// è¯­è¨€åˆ‡æ¢å‡½æ•°
function switchLanguage(lang) {
    currentLanguage = lang;
    localStorage.setItem('language', lang);
    
    // æ›´æ–°æŒ‰é’®çŠ¶æ€
    document.getElementById('lang-zh').classList.toggle('active', lang === 'zh');
    document.getElementById('lang-en').classList.toggle('active', lang === 'en');
    
    // æ›´æ–°é¡µé¢å†…å®¹
    updatePageContent();
}

// è·å–ç¿»è¯‘æ–‡æœ¬
function t(key, params = {}) {
    let text = translations[currentLanguage][key] || translations['zh'][key] || key;
    
    // æ›¿æ¢å‚æ•°
    Object.keys(params).forEach(param => {
        text = text.replace(`{${param}}`, params[param]);
    });
    
    return text;
}

// æ›´æ–°é¡µé¢å†…å®¹
function updatePageContent() {
    // æ›´æ–°æ ‡é¢˜
    document.title = t('app-title');
    
    // æ›´æ–°åº“è§†å›¾
    const libraryTitle = document.querySelector('#library-view .header h1');
    if (libraryTitle) libraryTitle.textContent = t('app-title');
    
    // ç¡®ä¿è¯­è¨€åˆ‡æ¢æŒ‰é’®åœ¨æ ‡é¢˜æ—è¾¹å¹¶æ›´æ–°çŠ¶æ€
    const titleContainer = libraryTitle?.parentElement;
    let languageSwitcher = titleContainer?.querySelector('.language-switcher');
    
    if (titleContainer && !languageSwitcher) {
        languageSwitcher = document.createElement('div');
        languageSwitcher.className = 'language-switcher';
        titleContainer.appendChild(languageSwitcher);
    }
    
    if (languageSwitcher) {
        languageSwitcher.innerHTML = `
            <button onclick="switchLanguage('zh')" id="lang-zh" class="${currentLanguage === 'zh' ? 'active' : ''}">ä¸­æ–‡</button>
            <button onclick="switchLanguage('en')" id="lang-en" class="${currentLanguage === 'en' ? 'active' : ''}">English</button>
        `;
    }
    
    const createBtn = document.querySelector('#library-view .header-buttons button:first-child');
    if (createBtn) createBtn.textContent = '+ ' + t('create-new-character');
    
    const importBtn = document.querySelector('#library-view .header-buttons button:nth-child(2)');
    if (importBtn) importBtn.textContent = t('import-character');
    
    const tagFilterTitle = document.querySelector('#library-view .tag-filter-area h3');
    if (tagFilterTitle) tagFilterTitle.textContent = t('tag-filter');
    
    // æ›´æ–°ç¼–è¾‘å™¨è§†å›¾
    const editorTitle = document.getElementById('editor-title');
    if (editorTitle) {
        const isEditing = document.getElementById('charId').value !== '';
        editorTitle.textContent = isEditing ? t('edit-character') : t('create-new-character');
    }
    
    const apiKeyInput = document.getElementById('apiKey');
    if (apiKeyInput) apiKeyInput.placeholder = t('api-key-placeholder');
    
    // æ›´æ–°è¡¨å•æ ‡ç­¾å’Œå ä½ç¬¦
    updateFormLabels();
    
    // æ›´æ–°æŒ‰é’®æ–‡æœ¬
    updateButtonTexts();
    
    // æ›´æ–°ä¸–ç•Œä¹¦å¸®åŠ©æ–‡æœ¬
    const worldbookHelpText = document.getElementById('worldbook-help-text');
    if (worldbookHelpText) {
        worldbookHelpText.innerHTML = t('worldbook-help');
    }
    
    // æ›´æ–°åŠ è½½æ–‡æœ¬
    const loadingText = document.getElementById('loading-text');
    if (loadingText) {
        loadingText.textContent = t('loading');
    }

    // æ›´æ–°åå­—ç”Ÿæˆå™¨ Modal
    document.getElementById('name-modal-title').textContent = t('choose-a-name');
    document.getElementById('regenerate-names-btn').textContent = t('regenerate');
    document.getElementById('cancel-name-generation-btn').textContent = t('cancel');

    // æ›´æ–°AI Guidance Modal
    document.getElementById('ai-guidance-generate-btn').textContent = t('generate');
    document.getElementById('ai-guidance-cancel-btn').textContent = t('cancel');
    
    // æ›´æ–°è§’è‰²ä¹¦AI Modal
    document.getElementById('wb-ai-modal-title').textContent = t('wb-ai-modal-title');
    document.getElementById('wb-ai-modal-desc').textContent = t('wb-ai-modal-desc');
    document.querySelector('.generation-type-selector button[data-type="worldview"]').textContent = t('wb-ai-gen-type-btn-worldview');
    document.querySelector('.generation-type-selector button[data-type="main_plot"]').textContent = t('wb-ai-gen-type-btn-main-plot');
    document.querySelector('.generation-type-selector button[data-type="side_plot"]').textContent = t('wb-ai-gen-type-btn-side-plot');
    document.getElementById('wb-ai-inject-btn').textContent = t('wb-ai-inject-btn');
    document.getElementById('wb-ai-regenerate-btn').textContent = t('wb-ai-regenerate-btn');
    document.getElementById('wb-ai-cancel-btn').textContent = t('wb-ai-close-btn');

    // é‡æ–°æ¸²æŸ“UIä»¥æ›´æ–°è§’è‰²å¡æ˜¾ç¤º
    if (libraryView.style.display !== 'none') {
        renderUI();
    }
    
    // é‡æ–°æ¸²æŸ“è§’è‰²ä¹¦æ¡ç›®ä»¥æ›´æ–°ç¿»è¯‘
    if (editorView.style.display !== 'none') {
        const worldbookData = buildWorldbookDataFromDOM();
        renderWorldbookFromData(worldbookData);
    }
}

// æ›´æ–°è¡¨å•æ ‡ç­¾
function updateFormLabels() {
    // æ›´æ–°sectionæ ‡é¢˜
    const sectionTitles = {
        'avatar-operation-title': t('avatar-label'),
        'character-info-title': t('character-info'),
        'ai-settings-title': t('ai-settings'),
        'advanced-settings-title': t('advanced-settings'),
        'world-knowledge-book-title': t('world-knowledge-book')
    };
    
    Object.keys(sectionTitles).forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            // Preserve child elements like buttons
            const button = element.querySelector('button');
            element.textContent = sectionTitles[id] + ' ';
            if(button) element.appendChild(button);
        }
    });
    
    // æ›´æ–°è¡¨å•æ ‡ç­¾
    const labels = {
        'topic': t('topic'),
        'name': t('name'),
        'gender': t('gender'),
        'description': t('description'),
        'tags': t('tags'),
        'personality': t('personality'),
        'system_prompt': t('system-prompt'),
        'scenario': t('scenario'),
        'first_mes': t('first-message'),
        'mes_example': t('message-example'),
        'post_history_instructions': t('post-history-instructions'),
        'creator_notes': t('creator-notes'),
        'character_version': t('character-version'),
    };
    
    Object.keys(labels).forEach(id => {
        const element = document.querySelector(`label[for="${id}"]`);
        if (element) element.textContent = labels[id];
    });
    
    // æ›´æ–°å ä½ç¬¦
    const placeholders = {
        'topic': t('topic-placeholder'),
        'name': t('name-placeholder'),
        'gender': t('gender-placeholder'),
        'description': t('description-placeholder'),
        'tags': t('tags-placeholder'),
        'personality': t('personality-placeholder'),
        'system_prompt': t('system-prompt-placeholder'),
        'scenario': t('scenario-placeholder'),
        'first_mes': t('first-message-placeholder'),
        'mes_example': t('message-example-placeholder'),
        'post_history_instructions': t('post-history-instructions-placeholder'),
        'creator_notes': t('creator-notes-placeholder'),
        'character_version': t('character-version-placeholder'),
    };
    
    Object.keys(placeholders).forEach(id => {
        const element = document.getElementById(id);
        if (element) element.placeholder = placeholders[id];
    });
    
    // æ›´æ–°ä¼´ä¾£æ¨¡å¼æ ‡ç­¾
    const companionModeLabel = document.getElementById('companion-mode-label');
    if (companionModeLabel) {
        companionModeLabel.textContent = t('companion-mode');
    }
    
    // æ›´æ–°å¤´åƒæ ‡ç­¾
    const avatarLabel = document.getElementById('avatar-input-label');
    if (avatarLabel) {
        avatarLabel.textContent = t('avatar-label');
        avatarLabel.title = currentLanguage === 'zh' ? 'ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®ä¸Šä¼ å›¾ç‰‡' : 'Click the button below to upload image';
    }
    
    // æ›´æ–°é«˜çº§è®¾å®šsummary
    const advancedSummary = document.getElementById('advanced-settings-summary');
    if (advancedSummary) {
        const subtitle = currentLanguage === 'zh' ? '(å…³é”®è¯åŒ¹é…ã€æ³¨å…¥é€»è¾‘ç­‰)' : '(Keyword matching, injection logic, etc.)';
        advancedSummary.innerHTML = `${t('advanced-settings')} <span style="font-weight: normal; font-size: 14px; color: #aaa;">${subtitle}</span>`;
    }
    
    // æ›´æ–°ä¸Šä¼ å›¾ç‰‡æŒ‰é’®
    const uploadBtn = document.querySelector('button[onclick="document.getElementById(\'avatar-input\').click()"]');
    if (uploadBtn) uploadBtn.textContent = t('upload-image');
}

// æ›´æ–°æŒ‰é’®æ–‡æœ¬
function updateButtonTexts() {
    // æ›´æ–°ä¿å­˜æŒ‰é’®
    const saveBtn = document.querySelector('button[onclick="saveCharacter()"]');
    if (saveBtn) saveBtn.textContent = t('save-and-return');
    
    const returnBtn = document.querySelector('button[onclick="showLibraryView()"]');
    if (returnBtn) returnBtn.textContent = t('return-without-save');
    
    const downloadJsonBtn = document.querySelector('button[onclick="downloadCharacter()"]');
    if (downloadJsonBtn) downloadJsonBtn.textContent = t('download-json');
    
    const downloadPngBtn = document.querySelector('button[onclick="downloadCharacterAsPng()"]');
    if (downloadPngBtn) downloadPngBtn.textContent = t('download-png');

    const downloadLorebookBtn = document.querySelector('button[onclick="downloadAsWorldbookFile()"]');
    if (downloadLorebookBtn) downloadLorebookBtn.textContent = t('download-lorebook');

    const completeAllBtn = document.getElementById('complete-all-btn');
    if(completeAllBtn) completeAllBtn.textContent = t('complete-all');

    const translateAllBtn = document.getElementById('translate-all-btn');
    if(translateAllBtn) translateAllBtn.textContent = t('translate-all');
    const undoTranslateBtn = document.getElementById('undo-translate-btn');
    if(undoTranslateBtn) undoTranslateBtn.textContent = t('undo-translation');
    
    // æ›´æ–°AIæŒ‰é’®
    const aiButtons = document.querySelectorAll('.ai-button');
    aiButtons.forEach(btn => {
        btn.textContent = t('ai-help-write');
    });
    
    const undoButtons = document.querySelectorAll('.ai-undo-button');
    undoButtons.forEach(btn => {
        btn.textContent = t('undo');
    });
    
    // æ›´æ–°ä¸–ç•Œä¹¦ç›¸å…³æŒ‰é’®
    const addEntryBtn = document.querySelector('button[onclick="addWorldbookEntry()"]');
    if (addEntryBtn) addEntryBtn.textContent = t('add-new-entry');
    
    const sortBtn = document.querySelector('button[onclick="sortWorldbookEntries()"]');
    if (sortBtn) sortBtn.textContent = t('sort-by-id');
    
    const generateBtn = document.querySelector('button[onclick="generateFullWorldbook(this)"]');
    if (generateBtn) generateBtn.textContent = t('ai-generate-entries');
    
    // æ›´æ–°è§’è‰²å¡æŒ‰é’®
    const addTagBtns = document.querySelectorAll('.card-footer button[onclick*="addInternalTag"]');
    addTagBtns.forEach(btn => {
        btn.textContent = `ğŸ·ï¸ ${t('add-tag')}`;
    });
    
    const deleteBtns = document.querySelectorAll('.card-footer button[onclick*="deleteCharacter"]');
    deleteBtns.forEach(btn => {
        btn.textContent = `ğŸ—‘ï¸ ${t('delete')}`;
    });

    // æ›´æ–°Post-historyæ¨¡æ¿æŒ‰é’®
    const templateContainer = document.getElementById('post-history-templates');
    if (templateContainer) {
        document.getElementById('btn-template-options').textContent = t('post-history-options-mode');
        document.getElementById('btn-template-parentheses').textContent = t('post-history-parentheses-mode');
        document.getElementById('btn-template-status-bar').textContent = t('post-history-status-bar');
        document.getElementById('btn-template-third-person').textContent = t('post-history-third-person');
        document.getElementById('btn-template-json-mode').textContent = t('post-history-json-mode');
        document.getElementById('btn-template-image-prompt').textContent = t('post-history-image-prompt');
    }
}

// --- å…¨å±€ç¿»è¯‘åŠŸèƒ½ ---
let originalFieldsData = null; // ç”¨äºå­˜å‚¨ç¿»è¯‘å‰çš„æ•°æ®

async function translateAllFields(button) {
    const apiSettings = loadApiSettings();
    const provider = apiSettings.provider;
    const key = apiSettings[provider]?.apiKey;
    const endpoint = apiSettings[provider]?.endpoint;

    if (!provider || (provider !== 'custom' && !key) || (provider === 'custom' && !endpoint)) {
        alert('è¯·å…ˆåœ¨ API è®¾ç½®ä¸­é…ç½®æ‚¨çš„æœåŠ¡å•†ã€‚');
        openApiSettingsModal();
        return;
    }

    const fromLang = currentLanguage === 'zh' ? 'English' : 'Chinese';
    const toLang = currentLanguage === 'zh' ? 'Chinese' : 'English';

    // 1. æ”¶é›†æ‰€æœ‰éœ€è¦ç¿»è¯‘çš„æ–‡æœ¬
    const fieldsToTranslate = [
        'topic', 'name', 'gender', 'description', 'tags', 'personality',
        'system_prompt', 'scenario', 'first_mes', 'mes_example',
        'post_history_instructions', 'creator_notes'
    ];

    let textObject = {};
    originalFieldsData = { fields: {}, worldbook: [] };

    fieldsToTranslate.forEach(id => {
        const el = document.getElementById(id);
        if (el && el.value.trim()) {
            textObject[id] = el.value;
            originalFieldsData.fields[id] = el.value;
        }
    });

    const worldbookEntries = buildWorldbookDataFromDOM();
    originalFieldsData.worldbook = JSON.parse(JSON.stringify(cleanWorldbookForStorage(worldbookEntries))); // Deep copy for undo

    let wbTextObject = [];
    worldbookEntries.forEach((entry, index) => {
        const entryTexts = {
            comment: entry.comment,
            keys: entry.keys.join(', '),
            content: entry.content
        };
        if (entryTexts.comment || entryTexts.keys || entryTexts.content) {
            wbTextObject.push({ index: index, ...entryTexts });
        }
    });

    if (Object.keys(textObject).length === 0 && wbTextObject.length === 0) {
        alert('æ²¡æœ‰éœ€è¦ç¿»è¯‘çš„å†…å®¹ã€‚');
        return;
    }

    // 2. æ„å»ºPrompt
    let prompt = `You are an expert translator. Translate the following JSON object's string values from ${fromLang} to ${toLang}.
Maintain the original JSON structure and keys. For keys like "tags" or "keys", translate each item in the comma-separated string individually.
Do not translate special placeholders like {{user}} or {{char}} or "<START>".

Translate this data:
${JSON.stringify({ fields: textObject, worldbook: wbTextObject }, null, 2)}
`;

    // 3. è°ƒç”¨API
    const originalText = button.textContent;
    button.disabled = true;
    button.textContent = t('generating');
    const loadingOverlay = document.getElementById('loading-overlay');
    loadingOverlay.style.display = 'flex';

    try {
        const result = await callApi(prompt, button);
        if (result) {
            const cleanedResult = result.replace(/^```json\s*|```$/g, '').trim();
            const translatedData = JSON.parse(cleanedResult);

            // 4. åº”ç”¨ç¿»è¯‘ç»“æœ
            if (translatedData.fields) {
                for (const id in translatedData.fields) {
                    const el = document.getElementById(id);
                    if (el) {
                        el.value = translatedData.fields[id];
                    }
                }
            }

            if (translatedData.worldbook) {
                translatedData.worldbook.forEach(item => {
                    const entry = worldbookEntries[item.index];
                    if (entry && entry.element) {
                        if (item.comment) entry.element.querySelector('.entry-comment').value = item.comment;
                        if (item.keys) entry.element.querySelector('.wb-keys').value = item.keys;
                        if (item.content) entry.element.querySelector('.wb-content').value = item.content;
                    }
                });
            }

            // æ˜¾ç¤ºæ’¤é”€æŒ‰é’®
            document.getElementById('undo-translate-btn').style.display = 'inline-block';
        }
    } catch (e) {
        console.error("Translation failed:", e, "Raw response:", result);
        alert('ç¿»è¯‘å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°è·å–è¯¦æƒ…ã€‚');
        originalFieldsData = null; // æ¸…é™¤å¤‡ä»½
    } finally {
        button.disabled = false;
        button.textContent = originalText;
        loadingOverlay.style.display = 'none';
    }
}

function undoTranslateAllFields(button) {
    if (!originalFieldsData) {
        alert('æ²¡æœ‰å¯æ’¤é”€çš„ç¿»è¯‘ã€‚');
        return;
    }

    // æ¢å¤æ™®é€šå­—æ®µ
    for (const id in originalFieldsData.fields) {
        const el = document.getElementById(id);
        if (el) {
            el.value = originalFieldsData.fields[id];
        }
    }

    // æ¢å¤ä¸–ç•Œä¹¦
    if (originalFieldsData.worldbook) {
        renderWorldbookFromData(originalFieldsData.worldbook);
    }

    // æ¸…ç†
    originalFieldsData = null;
    button.style.display = 'none';
}

// --- API Settings ---
function openApiSettingsModal() {
    const modal = document.getElementById('api-settings-modal');
    loadApiSettings(); // Load current settings when opening
    modal.style.display = 'flex';
}

function initializeApiSettingsModal() {
    const modal = document.getElementById('api-settings-modal');
    const selector = document.getElementById('api-provider-selector');
    const saveBtn = document.getElementById('save-api-settings-btn');
    const cancelBtn = document.getElementById('cancel-api-settings-btn');

    selector.addEventListener('change', () => {
        document.querySelectorAll('.api-provider-options').forEach(el => el.classList.remove('active'));
        const selectedProvider = selector.value;
        document.getElementById(`${selectedProvider}-options`).classList.add('active');
    });

    cancelBtn.onclick = () => modal.style.display = 'none';
    modal.onclick = (e) => { if (e.target === modal) modal.style.display = 'none'; };

    saveBtn.onclick = () => {
        const settings = {
            provider: document.getElementById('api-provider-selector').value,
            deepseek: {
                apiKey: document.getElementById('deepseek-api-key').value.trim()
            },
            gemini: {
                apiKey: document.getElementById('gemini-api-key').value.trim(),
                model: document.getElementById('gemini-model').value
            },
            'gemini-proxy': {
                endpoint: document.getElementById('gemini-proxy-endpoint').value.trim(),
                apiKey: document.getElementById('gemini-proxy-api-key').value.trim(),
                model: document.getElementById('gemini-proxy-model').value
            },
        tavern: {
            endpoint: document.getElementById('tavern-api-endpoint').value.trim(),
            apiKey: document.getElementById('tavern-api-key').value.trim(),
            model: document.getElementById('tavern-model').value.trim() || ''   // new field
        },
        local: {
            endpoint: document.getElementById('local-api-endpoint').value.trim()
        }
        };
        localStorage.setItem('apiSettings', JSON.stringify(settings));
        alert('API è®¾ç½®å·²ä¿å­˜ï¼');
        modal.style.display = 'none';
    };
}

function loadApiSettings() {
    const settings = JSON.parse(localStorage.getItem('apiSettings')) || {
        provider: 'deepseek',
        deepseek: { apiKey: '' },
        gemini: { apiKey: '', model: 'gemini-2.5-flash' },
        'gemini-proxy': { endpoint: '', apiKey: '', model: 'gemini-2.5-flash' },
        tavern: { endpoint: '', apiKey: '' },
        local: { endpoint: '' }
    };

    // Migrate old "custom" settings if they exist
    if (settings.custom) {
        if (settings.custom.endpoint && (settings.custom.endpoint.includes('gemini') || settings.custom.endpoint.includes(':generateContent'))) {
            settings['gemini-proxy'] = { ...settings.custom };
            settings.provider = 'gemini-proxy';
        } else {
            settings.tavern = { ...settings.custom };
            settings.provider = 'tavern';
        }
        delete settings.custom;
        // Save migrated settings back to localStorage
        localStorage.setItem('apiSettings', JSON.stringify(settings));
    }


    document.getElementById('api-provider-selector').value = settings.provider;
    document.getElementById('deepseek-api-key').value = settings.deepseek?.apiKey || '';
    document.getElementById('gemini-api-key').value = settings.gemini?.apiKey || '';
    document.getElementById('gemini-model').value = settings.gemini?.model || 'gemini-2.5-flash';
    document.getElementById('gemini-proxy-endpoint').value = settings['gemini-proxy']?.endpoint || '';
    document.getElementById('gemini-proxy-api-key').value = settings['gemini-proxy']?.apiKey || '';
    document.getElementById('gemini-proxy-model').value = settings['gemini-proxy']?.model || 'gemini-2.5-flash';
        document.getElementById('tavern-api-endpoint').value = settings.tavern?.endpoint || '';
        document.getElementById('tavern-api-key').value = settings.tavern?.apiKey || '';
        document.getElementById('tavern-model').value = settings.tavern?.model || '';
        document.getElementById('local-api-endpoint').value = settings.local?.endpoint || '';

    // Trigger change to show correct options
    document.getElementById('api-provider-selector').dispatchEvent(new Event('change'));
    return settings;
}


// --- Mobile Textarea Auto-Resize ---
function autoResizeTextarea(textarea) {
    // Temporarily reset height to allow the scrollHeight to be calculated correctly.
    textarea.style.height = 'auto';
    
    const maxHeight = window.innerHeight / 2; // Max height is half the viewport height.
    const scrollHeight = textarea.scrollHeight;
    
    // Set height to the calculated scroll height, but not exceeding the max height.
    textarea.style.height = Math.min(scrollHeight, maxHeight) + 'px';
}

function setupTextareaAutoResize() {
    // Use event delegation on the editor's scrolling body for efficiency, especially with dynamic worldbook entries.
    const editorBody = document.querySelector('#editor-view .editor-body');
    if (!editorBody) return;

    const resizeHandler = (event) => {
        if (event.target.tagName === 'TEXTAREA') {
            autoResizeTextarea(event.target);
        }
    };
    
    editorBody.addEventListener('focusin', resizeHandler);
    editorBody.addEventListener('input', resizeHandler);
}

// --- DB & Initialization ---
let db;
let activeFilters = new Set();
const libraryView = document.getElementById('library-view');
const editorView = document.getElementById('editor-view');
let avatarImageBase64 = null;

// --- å…¨å±€å¸®åŠ©å‡½æ•° ---
function showHelp(message) {
    alert(message);
}

// [MODIFIED] è®¾ç½®åæœŸæŒ‡ä»¤æ¨¡æ¿å‡½æ•°
function setPostHistoryTemplate(templateKey) {
    const textarea = document.getElementById('post_history_instructions');
    if (textarea) {
        const templateText = t(templateKey);
        // æ£€æŸ¥æ–‡æœ¬åŒºåŸŸæ˜¯å¦ä¸ºç©ºæˆ–ä»…åŒ…å«ç©ºç™½å­—ç¬¦
        if (textarea.value.trim() === '') {
            textarea.value = templateText;
        } else {
            // å¦‚æœå·²æœ‰å†…å®¹ï¼Œåˆ™åœ¨æ–°è¡Œè¿½åŠ ï¼Œå¹¶ç”¨ç©ºè¡Œåˆ†éš”
            textarea.value += '\n\n' + templateText;
        }
    }
}

/**
 * [NEW] Converts a SillyTavern lorebook object into the application's internal format.
 * @param {object} lorebook - The raw lorebook object from the imported JSON.
 * @returns {Array} An array of worldbook entries in the internal format.
 */
function convertTavernLorebookToInternal(lorebook) {
    const internalEntries = [];
    const entriesSource = (lorebook.entries && typeof lorebook.entries === 'object' && !Array.isArray(lorebook.entries))
        ? lorebook.entries
        : (lorebook.extensions && lorebook.extensions.entries && typeof lorebook.extensions.entries === 'object' && !Array.isArray(lorebook.extensions.entries))
            ? lorebook.extensions.entries
            : null;

    if (!entriesSource) {
        console.warn("Could not find a valid Tavern-style 'entries' object in the provided file.");
        return [];
    }

    const positionMap = {
        0: 'before_prompt',
        1: 'after_char',
        2: 'before_char'
    };

    for (const key in entriesSource) {
        const tavernEntry = entriesSource[key];
        const internalEntry = {
            id: tavernEntry.order || parseInt(key, 10) || 0,
            keys: tavernEntry.keys || tavernEntry.key || [],
            secondary_keys: tavernEntry.keysecondary || tavernEntry.secondary_keys || [],
            comment: tavernEntry.name || tavernEntry.comment || '',
            content: tavernEntry.content || '',
            priority: tavernEntry.order || 100,
            enabled: tavernEntry.disable !== undefined ? !tavernEntry.disable : (tavernEntry.enabled !== undefined ? tavernEntry.enabled : true),
            constant: tavernEntry.constant || false,
            selective: tavernEntry.selective || false,
            prevent_recursion: tavernEntry.excludeRecursion || false,
            position: positionMap[tavernEntry.position] || 'before_char',
            secondary_keys_logic: 'any',
            use_regex: tavernEntry.use_regex || false,
            group: tavernEntry.group || '',
            scope: 'chat',
            probability: tavernEntry.probability !== undefined ? tavernEntry.probability : 100,
            wb_depth: tavernEntry.depth || 4,
            match_whole_words: tavernEntry.match_whole_words || false,
            case_sensitive: tavernEntry.case_sensitive || false,
            children: []
        };
        internalEntries.push(internalEntry);
    }
    
    internalEntries.sort((a, b) => a.id - b.id);
    internalEntries.forEach((entry, index) => {
        entry.id = index;
    });
    return internalEntries;
}


window.onload = function() {
    // æ˜¾ç¤ºåŠ è½½åŠ¨ç”»
    const loadingOverlay = document.getElementById('loading-overlay');
    loadingOverlay.style.display = 'flex';
    
    // ä¼˜åŒ–ï¼šç§»é™¤ä¸å¿…è¦çš„å»¶è¿Ÿï¼Œè®©åº”ç”¨æ›´å¿«å¯åŠ¨
    initializeApiSettingsModal();
    loadApiSettings();
    initializeDatabase(); // initializeDatabase will call showLibraryView, which hides the overlay
    initializeLoverSwitch();
    initializeNameGeneratorModal();
    initializeWorldbookAiModal();
    initializeAiGuidanceModal();
    setupTextareaAutoResize(); // Initialize textarea resizing for mobile
    
    // åˆå§‹åŒ–è¯­è¨€è®¾ç½®
    const savedLanguage = localStorage.getItem('language') || 'zh';
    switchLanguage(savedLanguage);
};

function initializeDatabase() {
    const dbTimeout = setTimeout(() => {
        if (!db) {
            console.warn('Database connection timeout');
        }
    }, 7000);

    const request = indexedDB.open('CharacterDB', 2);

    request.onupgradeneeded = event => {
        const tempDb = event.target.result;
        if (!tempDb.objectStoreNames.contains('characters')) {
            const objectStore = tempDb.createObjectStore('characters', { keyPath: 'id', autoIncrement: true });
            objectStore.createIndex('name', 'name', { unique: false });
            objectStore.createIndex('lastUsed', 'lastUsed', { unique: false });
        }
    };

    request.onsuccess = event => {
        clearTimeout(dbTimeout);
        db = event.target.result;
        console.log(currentLanguage === 'zh' ? "æ•°æ®åº“å·²å‡†å¤‡å°±ç»ªã€‚" : "Database ready.");
        showLibraryView();
    };

    request.onerror = event => {
        clearTimeout(dbTimeout);
        console.error(currentLanguage === 'zh' ? "æ•°æ®åº“è¿æ¥å¤±è´¥ (onerror):" : "Database connection failed (onerror):", event.target.error);
        console.warn(t('db-error', { error: event.target.error }));
    };

    request.onblocked = event => {
        clearTimeout(dbTimeout);
        console.warn(currentLanguage === 'zh' ? "æ•°æ®åº“è¿æ¥è¢«é˜»å¡ (onblocked)ã€‚æ—§ç‰ˆæœ¬å¯èƒ½åœ¨å…¶ä»–æ ‡ç­¾é¡µä¸­æ‰“å¼€ã€‚" : "Database connection blocked (onblocked). Old version may be open in other tabs.");
        console.warn(t('db-blocked'));
    };
}

function checkDbReady() {
    if (!db) {
        console.warn(t('db-not-ready'));
        return false;
    }
    return true;
}


// --- View Management ---
function showLibraryView() {
    if (!checkDbReady()) return;
    editorView.style.display = 'none';
    libraryView.style.display = 'block';
    renderUI();
    // ä¼˜åŒ–ï¼šåœ¨UIæ¸²æŸ“åéšè—åŠ è½½åŠ¨ç”»
    document.getElementById('loading-overlay').style.display = 'none';
}

function showEditorView(characterId = null) {
    if (!checkDbReady()) return;
    
    libraryView.style.display = 'none';
    editorView.style.display = 'flex';
    clearEditorForm();

    if (characterId) {
        document.getElementById('editor-title').innerText = t('edit-character');
        const transaction = db.transaction(['characters'], 'readonly');
        const store = transaction.objectStore('characters');
        const request = store.get(characterId);
        
        request.onsuccess = e => {
            const charData = e.target.result;
            if (charData) {
                populateEditorForm(charData);
            }
        };
    } else {
        document.getElementById('editor-title').innerText = t('create-new-character');
        renderWorldbookFromData([]);
        document.getElementById('avatar-preview').src = createDefaultImage('2:3');
    }
    // ç¡®ä¿æ¯æ¬¡è¿›å…¥ç¼–è¾‘å™¨æ—¶ï¼ŒæŒ‰é’®æ–‡æœ¬éƒ½æ ¹æ®å¼€å…³çŠ¶æ€åˆ·æ–°
    toggleAiButtonText(document.getElementById('lover-switch').checked);
}

// --- Import / Export ---
function importCharacter(event) {
    if (!checkDbReady()) return;

    const files = event.target.files;
    if (!files.length) return;

    for (const file of files) {
        if (file.type === "image/png") {
            const readAsBuffer = file.arrayBuffer();
            const readAsDataURL = new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => reject(reader.error);
                reader.readAsDataURL(file);
            });

            Promise.all([readAsBuffer, readAsDataURL]).then(async ([buffer, dataUrl]) => {
                try {
                    const charData = await extractDataFromPng(buffer);
                    const pngDataUrl = await convertImageToPng(dataUrl);
                    saveImportedCharacter(charData, pngDataUrl);
                } catch (err) {
                    console.error(currentLanguage === 'zh' ? "PNGå¯¼å…¥é”™è¯¯:" : "PNG import error:", err);
                    alert(t('import-png-failed', { error: err.message || (currentLanguage === 'zh' ? 'æœªçŸ¥é”™è¯¯ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°ã€‚' : 'Unknown error, please check console.') }));
                }
            }).catch(err => {
                 alert(t('file-read-error-with-name', { name: file.name, error: err }));
            });

        } else if (file.type === "image/png" || file.type === "image/jpeg" || file.type === "image/jpg" || file.type === "image/webp" || file.type === "image/gif" || file.type === "image/bmp") {
            // å¤„ç†å„ç§å›¾ç‰‡æ ¼å¼
            const readAsDataURL = new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => reject(reader.error);
                reader.readAsDataURL(file);
            });

            readAsDataURL.then(async (dataUrl) => {
                try {
                    // å°†ä»»ä½•æ ¼å¼çš„å›¾ç‰‡è½¬æ¢ä¸ºPNGæ ¼å¼
                    const pngDataUrl = await convertImageToPng(dataUrl);
                    // åˆ›å»ºä¸€ä¸ªæ¨¡æ‹Ÿçš„è§’è‰²æ•°æ®å¯¹è±¡
                    const charData = {
                        spec: 'chara_card_v3',
                        data: {
                            name: file.name.replace(/\.[^/.]+$/, ""), // ä½¿ç”¨æ–‡ä»¶åä½œä¸ºè§’è‰²å
                            description: t('imported-character'),
                            personality: '',
                            scenario: '',
                            first_mes: '',
                            mes_example: '',
                            system_prompt: '',
                            post_history_instructions: '',
                            creator_notes: '',
                            character_version: '1.0',
                            tags: [],
                            character_book: { entries: [] }
                        }
                    };
                    saveImportedCharacter(charData, pngDataUrl);
                } catch (err) {
                    console.error(currentLanguage === 'zh' ? "å›¾ç‰‡å¯¼å…¥é”™è¯¯:" : "Image import error:", err);
                    alert(t('import-image-failed', { error: err.message || (currentLanguage === 'zh' ? 'æœªçŸ¥é”™è¯¯ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°ã€‚' : 'Unknown error, please check console.') }));
                }
            }).catch(err => {
                alert(t('file-read-error-with-name', { name: file.name, error: err }));
            });

        } else if (file.type === "application/json") {
            const reader = new FileReader();
            reader.onload = e => {
                try {
                    const charData = JSON.parse(e.target.result);
                    saveImportedCharacter(charData, null);
                } catch (err) {
                    console.error(currentLanguage === 'zh' ? "JSONå¯¼å…¥é”™è¯¯:" : "JSON import error:", err);
                    alert(t('import-json-failed'));
                }
            };
            reader.readAsText(file);
        }
    }
    event.target.value = '';
}

/**
 * [MODIFIED] Saves an imported character card or lorebook to the database.
 * @param {object} originalCard - The parsed data from the imported file.
 * @param {string|null} avatarBase64 - The base64-encoded avatar image, if any.
 */
function saveImportedCharacter(originalCard, avatarBase64 = null) {
    if (!checkDbReady()) return;
    
    let charDataForDb;

    const isTavernLorebook = (originalCard.entries && typeof originalCard.entries === 'object' && !Array.isArray(originalCard.entries)) ||
                             (originalCard.extensions && originalCard.extensions.entries && typeof originalCard.extensions.entries === 'object' && !Array.isArray(originalCard.extensions.entries));

    if (originalCard.spec === 'chara_card_v3' && originalCard.data) {
        const data = originalCard.data;
        const extensions = data.extensions || {};
        const book = data.character_book || {};
        
        function convertV3EntryToInternal(entry) {
            const entryExt = entry.extensions || {};
            const internalEntry = {
                id: entry.id,
                keys: entry.keys || [],
                secondary_keys: entry.secondary_keys || [],
                secondary_keys_logic: entryExt.secondary_keys_logic || 'any',
                comment: entry.comment || '',
                content: entry.content || '',
                priority: entry.insertion_order || 100,
                enabled: entry.enabled,
                position: entry.position || 'before_char',
                constant: entry.constant || false,
                selective: entry.selective === undefined ? true : entry.selective,
                use_regex: entry.use_regex || false,
                prevent_recursion: entryExt.prevent_recursion || false,
                group: entryExt.group || '',
                scope: 'chat',
                display_index: entryExt.display_index || 0,
                depth: entryExt.depth || 0,
                wb_depth: entryExt.depth || 4,
                probability: entryExt.probability === undefined ? 100 : entryExt.probability,
                match_whole_words: entryExt.match_whole_words || false,
                case_sensitive: entryExt.case_sensitive || false,
                children: []
            };
            
            if (entry.children && entry.children.length > 0) {
                internalEntry.children = entry.children.map(child => convertV3EntryToInternal(child));
            }
            
            return internalEntry;
        }
        
        const internalBookEntries = (book.entries || []).map(entry => convertV3EntryToInternal(entry));

        charDataForDb = {
            name: data.name || '',
            gender: data.gender || '',
            topic: extensions.world || '',
            description: data.description || '',
            personality: data.personality || '',
            tags: data.tags || [],
            system_prompt: data.system_prompt || '',
            scenario: data.scenario || '',
            first_mes: data.first_mes || '',
            mes_example: data.mes_example || '',
            post_history_instructions: data.post_history_instructions || '',
            creator_notes: data.creator_notes || '',
            character_version: data.character_version || '',
            worldbook: internalBookEntries,
            isFavorite: extensions.fav || false,
        };

    } else if (originalCard.spec === 'chara_card_v2' && originalCard.data) {
        const data = originalCard.data;
        charDataForDb = {
            name: data.name || '',
            gender: data.gender || '',
            topic: data.topic || '',
            description: data.description || '',
            personality: data.personality || '',
            tags: Array.isArray(data.tags) ? data.tags : (typeof data.tags === 'string' ? data.tags.split(/[,ã€ï¼Œ\s]+/).map(t => t.trim()).filter(Boolean) : []),
            system_prompt: data.system_prompt || '',
            scenario: data.scenario || '',
            first_mes: data.first_mes || '',
            mes_example: data.mes_example || '',
            post_history_instructions: data.post_history_instructions || '',
            creator_notes: data.creatorcomment || '',
            character_version: '', // v2 doesn't have this field
            worldbook: (data.character_book && Array.isArray(data.character_book.entries)) ? data.character_book.entries : [],
        };
    } else if (isTavernLorebook) {
        // Handle SillyTavern Lorebook JSON
        console.log("Detected SillyTavern Lorebook format. Converting...");
        const internalBookEntries = convertTavernLorebookToInternal(originalCard);

        charDataForDb = {
            name: originalCard.name || t('imported-lorebook'),
            description: originalCard.description || t('lorebook-description'),
            gender: '',
            topic: '',
            personality: '',
            tags: [t('lorebook-tag')],
            system_prompt: '',
            scenario: '',
            first_mes: '',
            mes_example: '',
            post_history_instructions: '',
            creator_notes: '',
            character_version: '',
            worldbook: internalBookEntries,
            isFavorite: false,
        };
        console.log("Conversion complete. Processed entries:", internalBookEntries.length);
    } else {
        charDataForDb = JSON.parse(JSON.stringify(originalCard));
        charDataForDb.tags = Array.isArray(charDataForDb.tags) ? charDataForDb.tags : (typeof charDataForDb.tags === 'string' ? charDataForDb.tags.split(/[,ã€ï¼Œ\s]+/).map(t => t.trim()).filter(Boolean) : []);
        charDataForDb.personality = charDataForDb.personality || '';
        charDataForDb.creator_notes = charDataForDb.creator_notes || '';
        charDataForDb.character_version = charDataForDb.character_version || '';
        charDataForDb.worldbook = charDataForDb.worldbook || [];
    }

    charDataForDb.avatar = avatarBase64 || originalCard.avatar || null;
    charDataForDb.internalTags = charDataForDb.internalTags || [];
    charDataForDb.isFavorite = charDataForDb.isFavorite || false;
    charDataForDb.lastUsed = Date.now();

    const transaction = db.transaction(['characters'], 'readwrite');
    const store = transaction.objectStore('characters');
    const addRequest = store.add(charDataForDb);
    
    addRequest.onsuccess = () => {
        if (document.getElementById('library-view').style.display !== 'none') {
            renderUI();
        }
    };
    addRequest.onerror = (e) => {
        console.error(currentLanguage === 'zh' ? "ä¿å­˜å¯¼å…¥è§’è‰²å¤±è´¥:" : "Failed to save imported character:", e.target.error);
        alert(t('save-import-failed'));
    }
}


function downloadCharacter() {
    if (!checkDbReady()) return;
    const v3Card = buildLiveExportCard();
    const blob = new Blob([JSON.stringify(v3Card, null, 2)], { type: 'application/json' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = (v3Card.data && v3Card.data.name ? v3Card.data.name : 'character') + '.json';
    a.click();
    URL.revokeObjectURL(a.href);
}

async function downloadCharacterAsPng() {
    if (!checkDbReady()) return;
    const v3Card = buildLiveExportCard();
    const cardData = buildCardObject();
    if (!v3Card.data || !v3Card.data.name) {
        alert("è¯·è¾“å…¥è§’è‰²åä»¥ç”ŸæˆPNGè§’è‰²å¡ã€‚");
        return;
    }
    const base64Data = btoa(unescape(encodeURIComponent(JSON.stringify(v3Card))));
    const imageToUse = cardData.avatar || document.getElementById('avatar-preview').src || createDefaultImage('2:3');
    const finalPngBlob = await embedDataInPng(imageToUse, base64Data);
    const a = document.createElement('a');
    a.href = URL.createObjectURL(finalPngBlob);
    a.download = (v3Card.data.name || 'character') + '.png';
    a.click();
    URL.revokeObjectURL(a.href);
}

function downloadAsWorldbookFile() {
    if (!checkDbReady()) return;
    const lorebookData = buildWorldbookExportObject();
    const blob = new Blob([JSON.stringify(lorebookData, null, 2)], { type: 'application/json' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    let filename = 'lorebook';
    if (lorebookData.originalData && lorebookData.originalData.name) {
        filename = lorebookData.originalData.name.replace(`(${t('world-knowledge-book')}) `, '');
    }
    a.download = filename + '.json';
    a.click();
    URL.revokeObjectURL(a.href);
}

// --- CRUD Operations ---
function saveCharacter() {
    if (!checkDbReady()) return;

    const card = buildCardObject();
    if (!card.name) {
        alert("è¯·è¾“å…¥è§’è‰²åç§°ã€‚");
        return;
    }

    card.internalTags = card.internalTags.filter(internalTag => card.tags.includes(internalTag));

    // --- å¼€å§‹ä¿®å¤ ---
    // åˆ›å»ºä¸€ä¸ªä¸“é—¨ç”¨äºå­˜å‚¨çš„"å¹²å‡€"ç‰ˆæœ¬çš„å¡ç‰‡æ•°æ®å¯¹è±¡
    const cardForDb = { ...card };
    // ä½¿ç”¨æ–°å‡½æ•°æ¸…ç†ä¸–ç•Œä¹¦æ•°æ®ï¼Œç§»é™¤æ‰€æœ‰å¯¹DOMå…ƒç´ çš„å¼•ç”¨
    cardForDb.worldbook = cleanWorldbookForStorage(card.worldbook);
    // --- ä¿®å¤ç»“æŸ ---

    const transaction = db.transaction(['characters'], 'readwrite');
    const store = transaction.objectStore('characters');
    
    cardForDb.lastUsed = Date.now(); // ç¡®ä¿æ›´æ–°çš„æ˜¯å¹²å‡€å¯¹è±¡çš„æ—¶é—´æˆ³
    
    // å°†æ¸…ç†è¿‡çš„ã€ä¸å«DOMå…ƒç´ çš„å¯¹è±¡å­˜å…¥æ•°æ®åº“
    const request = store.put(cardForDb);

    request.onsuccess = () => {
        alert(t('character-saved', { name: card.name }));
        // å¼ºåˆ¶åˆ·æ–°UIä»¥ç¡®ä¿å¤´åƒæ­£ç¡®æ˜¾ç¤º
        setTimeout(() => {
            showLibraryView();
        }, 100);
    };
            request.onerror = (e) => {
            alert(t('save-failed'));
            console.error(currentLanguage === 'zh' ? "ä¿å­˜å¤±è´¥:" : "Save failed:", e.target.error);
        };
}

function isPureLorebook(char) {
    // It must have a worldbook to be considered a lorebook.
    if (!char.worldbook || char.worldbook.length === 0) {
        return false;
    }

    // List of fields that MUST be empty for it to be a "pure" lorebook.
    const mustBeEmptyFields = [
        'gender', 
        'topic', 
        'description', 
        'personality', 
        'system_prompt', 
        'scenario', 
        'first_mes', 
        'mes_example', 
        'post_history_instructions'
    ];

    for (const field of mustBeEmptyFields) {
        const value = char[field];
        if (value && typeof value === 'string' && value.trim() !== '') {
            return false; // If any of these string fields have content, it's not a pure lorebook.
        }
    }

    // The 'tags' field must also be empty, but we can allow the default 'lorebook' tag.
    if (char.tags && Array.isArray(char.tags) && char.tags.length > 0) {
        const filteredTags = char.tags.filter(tag => tag !== t('lorebook-tag'));
        if (filteredTags.length > 0) {
            return false;
        }
    }

    return true;
}

function buildWorldbookExportObjectFromData(cardData) {
    const v3Card = buildV3Card(cardData);

    // This is the format SillyTavern uses for its lorebooks.
    const lorebookEntries = {};
    if (v3Card.data.character_book && v3Card.data.character_book.entries) {
        v3Card.data.character_book.entries.forEach((entry, index) => {
            const tavernEntry = {
                uid: entry.id,
                key: entry.keys,
                keysecondary: entry.secondary_keys,
                comment: entry.comment,
                content: entry.content,
                constant: entry.constant,
                selective: entry.selective,
                selectiveLogic: 0,
                addMemo: true,
                order: entry.insertion_order,
                position: 0,
                disable: !entry.enabled,
                excludeRecursion: entry.extensions.prevent_recursion,
                preventRecursion: entry.extensions.prevent_recursion,
                probability: entry.extensions.probability,
                useProbability: true,
                depth: entry.extensions.depth,
                displayIndex: index,
            };
            lorebookEntries[index] = tavernEntry;
        });
    }

    return {
        entries: lorebookEntries,
        originalData: v3Card.data.character_book || {
             name: `(${t('world-knowledge-book')}) ${cardData.name || 'Character Book'}`,
             description: cardData.creator_notes || `Character book for ${cardData.name}.`,
             scan_depth: 10,
             token_budget: 2048,
             recursive_scanning: false,
             entries: []
        }
    };
}

async function exportCharacter(id) {
    if (!checkDbReady()) return;
    const transaction = db.transaction(['characters'], 'readonly');
    const store = transaction.objectStore('characters');
    const request = store.get(id);

    request.onsuccess = async (e) => {
        const charData = e.target.result;
        if (!charData) {
            alert('æœªæ‰¾åˆ°è§’è‰²!');
            return;
        }

        if (isPureLorebook(charData)) {
            const lorebookData = buildWorldbookExportObjectFromData(charData);
            const blob = new Blob([JSON.stringify(lorebookData, null, 2)], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = (charData.name || 'lorebook') + '.json';
            a.click();
            URL.revokeObjectURL(a.href);
        } else {
            const v3Card = buildV3Card(charData);
            if (charData.avatar) {
                const base64Data = btoa(unescape(encodeURIComponent(JSON.stringify(v3Card))));
                const finalPngBlob = await embedDataInPng(charData.avatar, base64Data);
                const a = document.createElement('a');
                a.href = URL.createObjectURL(finalPngBlob);
                a.download = (v3Card.data.name || 'character') + '.png';
                a.click();
                URL.revokeObjectURL(a.href);
            } else {
                const blob = new Blob([JSON.stringify(v3Card, null, 2)], { type: 'application/json' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = (v3Card.data && v3Card.data.name ? v3Card.data.name : 'character') + '.json';
                a.click();
                URL.revokeObjectURL(a.href);
            }
        }
    };

    request.onerror = (e) => {
        alert('æ£€ç´¢è§’è‰²ä»¥ä¾›å¯¼å‡ºå¤±è´¥ã€‚');
        console.error("Export failed:", e.target.error);
    };
}

function deleteCharacter(id) {
    if (!checkDbReady()) return;
    if (confirm("ç¡®å®šè¦åˆ é™¤è¿™ä¸ªè§’è‰²å—ï¼Ÿ")) {
        const transaction = db.transaction(['characters'], 'readwrite');
        transaction.objectStore('characters').delete(id);
        transaction.oncomplete = () => {
            renderUI();
        };
    }
}

function toggleFavorite(id, event) {
    if (!checkDbReady()) return;
    event.stopPropagation();
    const transaction = db.transaction(['characters'], 'readwrite');
    const store = transaction.objectStore('characters');
    const request = store.get(id);
    request.onsuccess = e => {
        const charData = e.target.result;
        charData.isFavorite = !charData.isFavorite;
        store.put(charData);
    };
    event.target.classList.toggle('favorited');
}


// --- UI Rendering ---
async function renderUI() {
    if (!checkDbReady()) return;
    
    const transaction = db.transaction(['characters'], 'readonly');
    const allChars = await new Promise((resolve, reject) => {
        const req = transaction.objectStore('characters').getAll();
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
    });
    allChars.sort((a,b) => (b.isFavorite - a.isFavorite) || (b.lastUsed || 0) - (a.lastUsed || 0));

    renderTags(allChars);
    renderCharacters(allChars);
}

function renderTags(characters) {
    const tagContainer = document.getElementById('tag-container');
    const internalTags = new Set();
    const extraTags = new Set(); 

    characters.forEach(char => {
        (char.internalTags || []).forEach(tag => { if (tag) internalTags.add(tag.trim()); });
        const tags = Array.isArray(char.tags) ? char.tags : (typeof char.tags === 'string' ? char.tags.split(/[,ã€ï¼Œ\s]+/) : []);
        tags.forEach(tag => { if (tag) extraTags.add(tag.trim()); });
    });

    let tagsHtml = `<div class="tag type-special ${activeFilters.has('FAVORITE') ? 'active' : ''}" onclick="toggleFilter('FAVORITE', event)">â­ æ”¶è—</div>`;
    [...extraTags].sort().forEach(tag => { tagsHtml += `<div class="tag type-personality ${activeFilters.has(tag) ? 'active' : ''}" onclick="toggleFilter('${tag}', event)">${tag}</div>`; });
    [...internalTags].sort().forEach(tag => { tagsHtml += `<div class="tag type-internal ${activeFilters.has(tag) ? 'active' : ''}" onclick="toggleFilter('${tag}', event)">${tag}</div>`; });

    tagContainer.innerHTML = tagsHtml;
}

function renderCharacters(characters) {
    const grid = document.getElementById('character-grid');
    grid.innerHTML = '';

    // ä¼˜åŒ–ï¼šå®ç°å›¾ç‰‡æ‡’åŠ è½½
    const lazyImageObserver = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                const card = entry.target;
                const imageUrl = card.dataset.bgImage;
                card.style.backgroundImage = `var(--card-overlay), url('${imageUrl}')`;
                observer.unobserve(card); // åœæ­¢è§‚å¯Ÿå·²åŠ è½½çš„å›¾ç‰‡
            }
        });
    });

    let filteredChars = characters;
    if (activeFilters.size > 0) {
        filteredChars = characters.filter(char => {
            if (activeFilters.has('FAVORITE') && !char.isFavorite) return false;
            
            const regularFilters = [...activeFilters].filter(f => f !== 'FAVORITE');
            if (regularFilters.length > 0) {
                const tagSet = new Set([
                    ...(Array.isArray(char.tags) ? char.tags : (typeof char.tags === 'string' ? char.tags.split(/[,ã€ï¼Œ\s]+/) : [])),
                    ...(char.internalTags || [])
                ].map(t => t.trim()));
                return regularFilters.every(filter => tagSet.has(filter));
            }
            return true;
        });
    }

    if (filteredChars.length === 0) {
        grid.innerHTML = `<p style="grid-column: 1 / -1; text-align: center;">${t('no-characters-found')}</p>`;
        return;
    }

    filteredChars.forEach(char => {
        const card = document.createElement('div');
        card.className = 'character-card';
        
        // ä¼˜åŒ–ï¼šä¸ºæ‡’åŠ è½½å‡†å¤‡å›¾ç‰‡URL
        let imageToDisplay;
        if (char.avatar && char.avatar.trim() !== '') {
            imageToDisplay = char.avatar;
        } else {
            imageToDisplay = createDefaultImage('2:3');
        }
        card.dataset.bgImage = imageToDisplay;
        
        // åˆå§‹æ—¶å¯ä»¥è®¾ç½®ä¸€ä¸ªå ä½ç¬¦èƒŒæ™¯
        card.style.backgroundImage = `var(--default-card-bg)`;

        const headerDiv = document.createElement('div');
        const cardHeader = document.createElement('div');
        cardHeader.className = 'card-header';
        
        const h2 = document.createElement('h2');
        h2.textContent = char.name || 'æ— åè§’è‰²';
        
        const favButton = document.createElement('button');
        favButton.className = `favorite-btn ${char.isFavorite ? 'favorited' : ''}`;
        favButton.innerHTML = 'â˜…';
        favButton.onclick = (event) => toggleFavorite(char.id, event);
        
        cardHeader.appendChild(h2);
        cardHeader.appendChild(favButton);
        
        const descriptionP = document.createElement('p');
        descriptionP.className = 'card-description';
        descriptionP.textContent = char.description || t('no-description');
        
        const tagsDiv = document.createElement('div');
        tagsDiv.className = 'card-tags tag-group';
        const tagsArray = Array.isArray(char.tags) ? char.tags : (typeof char.tags === 'string' ? char.tags.split(/[,ã€ï¼Œ\s]+/) : []);
        const personalityTagsHtml = tagsArray.filter(t => t).map(tag => `<span class="tag type-personality">${tag.trim()}</span>`).join(' ');
        const internalTagsHtml = (char.internalTags || []).filter(t => t).map(tag => `<span class="tag type-internal">${tag.trim()}</span>`).join(' ');
        tagsDiv.innerHTML = personalityTagsHtml + ' ' + internalTagsHtml;
        
        headerDiv.appendChild(cardHeader);
        headerDiv.appendChild(descriptionP);
        headerDiv.appendChild(tagsDiv);

        const footerDiv = document.createElement('div');
        footerDiv.className = 'card-footer';
        footerDiv.innerHTML = `
            <button onclick="showEditorView(${char.id})">âœï¸ ${t('edit')}</button>
            <button onclick="exportCharacter(${char.id})">ğŸ“¤ ${t('export')}</button>
            <button onclick="deleteCharacter(${char.id})">ğŸ—‘ï¸ ${t('delete')}</button>
        `;
        
        card.appendChild(headerDiv);
        card.appendChild(footerDiv);
        grid.appendChild(card);
        
        // ä¼˜åŒ–ï¼šè§‚å¯Ÿæ–°åˆ›å»ºçš„å¡ç‰‡
        lazyImageObserver.observe(card);
    });
}


function toggleFilter(filterName, event) {
    event.stopPropagation();
    const button = event.currentTarget;
    button.classList.toggle('active');
    activeFilters.has(filterName) ? activeFilters.delete(filterName) : activeFilters.add(filterName);
    renderUI();
}

// --- Editor Form Management ---
function clearEditorForm() {
    const fields = ['charId', 'name', 'description', 'personality', 'system_prompt', 'scenario', 'first_mes', 'mes_example', 'internalTags', 'isFavorite', 'originalCardData', 'topic', 'gender', 'tags', 'post_history_instructions', 'creator_notes', 'character_version'];
    fields.forEach(id => { 
        const el = document.getElementById(id);
        if (el) el.value = ''; 
    });
    document.querySelectorAll('.ai-undo-button').forEach(btn => btn.style.display = 'none');
    document.getElementById('worldbook-entries-container').innerHTML = '';
    document.getElementById('avatar-input').value = '';
    document.getElementById('avatar-preview').src = createDefaultImage('2:3');
    avatarImageBase64 = null;
    document.querySelector('#editor-view .editor-body').scrollTop = 0;
}

function populateEditorForm(charData) {
    document.getElementById('charId').value = charData.id || '';
    document.getElementById('name').value = charData.name || '';
    document.getElementById('gender').value = charData.gender || '';
    document.getElementById('topic').value = charData.topic || '';
    document.getElementById('description').value = charData.description || '';
    document.getElementById('tags').value = Array.isArray(charData.tags) ? charData.tags.join(', ') : (typeof charData.tags === 'string' ? charData.tags : '');
    document.getElementById('personality').value = charData.personality || '';
    document.getElementById('system_prompt').value = charData.system_prompt || '';
    document.getElementById('scenario').value = charData.scenario || '';
    document.getElementById('first_mes').value = charData.first_mes || '';
    document.getElementById('mes_example').value = charData.mes_example || '';
    document.getElementById('post_history_instructions').value = charData.post_history_instructions || '';
    document.getElementById('creator_notes').value = charData.creator_notes || '';
    document.getElementById('character_version').value = charData.character_version || '';
    document.getElementById('internalTags').value = JSON.stringify(charData.internalTags || []);
    document.getElementById('isFavorite').value = charData.isFavorite || false;
    
    renderWorldbookFromData(charData.worldbook || []);

    // æ–°å¢: è§’è‰²åŠ è½½åï¼Œè‡ªåŠ¨è°ƒæ•´æ‰€æœ‰æ–‡æœ¬æ¡†å¤§å°ä»¥é€‚åº”å†…å®¹ï¼Œæ”¹å–„ç§»åŠ¨ç«¯ç¼–è¾‘ä½“éªŒ
    document.querySelectorAll('#editor-view textarea').forEach(autoResizeTextarea);

    if (charData.avatar) {
        // å¼ºåˆ¶æ˜¾ç¤ºä»»ä½•å›¾ç‰‡æ ¼å¼
        if (charData.avatar.startsWith('data:image/')) {
            document.getElementById('avatar-preview').src = charData.avatar;
            avatarImageBase64 = charData.avatar;
        } else if (charData.avatar.startsWith('http://') || charData.avatar.startsWith('https://')) {
            document.getElementById('avatar-preview').src = charData.avatar;
            avatarImageBase64 = charData.avatar;
        } else if (charData.avatar.trim() !== '') {
            document.getElementById('avatar-preview').src = charData.avatar;
            avatarImageBase64 = charData.avatar;
        } else {
            document.getElementById('avatar-preview').src = createDefaultImage('2:3');
            avatarImageBase64 = null;
        }
    } else {
        document.getElementById('avatar-preview').src = createDefaultImage('2:3');
        avatarImageBase64 = null;
    }
    document.querySelectorAll('.ai-undo-button').forEach(btn => btn.style.display = 'none');
    document.querySelector('#editor-view .editor-body').scrollTop = 0;
}

document.getElementById('avatar-input').addEventListener('change', function(event) {
    const file = event.target.files[0];
    if (!file) return;

    if (!file.type.startsWith("image/")) {
        alert(t('upload-image-only'));
        event.target.value = '';
        return;
    }

    const reader = new FileReader();
    reader.onload = async function(e) {
        try {
            // å°†ä»»ä½•æ ¼å¼çš„å›¾ç‰‡è½¬æ¢ä¸ºPNGæ ¼å¼
            const pngDataUrl = await convertImageToPng(e.target.result);
            avatarImageBase64 = pngDataUrl;
            document.getElementById('avatar-preview').src = pngDataUrl;
            console.log(currentLanguage === 'zh' ? 'å¤´åƒå·²è½¬æ¢ä¸ºPNGæ ¼å¼:' : 'Avatar converted to PNG format:', pngDataUrl.substring(0, 50) + '...');
        } catch (error) {
            console.error(currentLanguage === 'zh' ? 'å›¾ç‰‡è½¬æ¢å¤±è´¥:' : 'Image conversion failed:', error);
            alert(t('image-process-failed', { error: error.message }));
            event.target.value = '';
        }
    };
    reader.onerror = function() {
        alert(t('file-read-error'));
        event.target.value = '';
    };
    reader.readAsDataURL(file);
});

// ç”¨äºåœ¨ä¿å­˜åˆ°æ•°æ®åº“å‰ï¼Œæ¸…ç†ä¸–ç•Œä¹¦æ•°æ®ä¸­çš„DOMå…ƒç´ å¼•ç”¨
function cleanWorldbookForStorage(entries) {
    if (!entries) return [];
    return entries.map(entry => {
        // åˆ›å»ºä¸€ä¸ªä¸åŒ…å« 'element' å±æ€§çš„æ–°å¯¹è±¡
        const { element, ...cleanedEntry } = entry;

        // å¯¹å­æ¡ç›®è¿›è¡Œé€’å½’æ¸…ç†
        if (entry.children && entry.children.length > 0) {
            cleanedEntry.children = cleanWorldbookForStorage(entry.children);
        }
        return cleanedEntry;
    });
}

// --- Object Building ---
function buildCardObject() {
    const worldbookData = buildWorldbookDataFromDOM();
    
    const card = {
        name: document.getElementById('name').value.trim(),
        gender: document.getElementById('gender').value.trim(),
        topic: document.getElementById('topic').value.trim(),
        description: document.getElementById('description').value.trim(),
        personality: document.getElementById('personality').value.trim(),
        tags: document.getElementById('tags').value.trim().split(/[,ã€ï¼Œ\s]+/).map(t => t.trim()).filter(Boolean),
        system_prompt: document.getElementById('system_prompt').value.trim(),
        scenario: document.getElementById('scenario').value.trim(),
        first_mes: document.getElementById('first_mes').value.trim(),
        mes_example: document.getElementById('mes_example').value.trim(),
        post_history_instructions: document.getElementById('post_history_instructions').value.trim(),
        creator_notes: document.getElementById('creator_notes').value.trim(),
        character_version: document.getElementById('character_version').value.trim(),
        internalTags: JSON.parse(document.getElementById('internalTags').value || '[]'),
        isFavorite: (document.getElementById('isFavorite').value === 'true'),
        avatar: avatarImageBase64,
        worldbook: worldbookData
    };
    const charId = parseInt(document.getElementById('charId').value, 10);
    if (!isNaN(charId)) card.id = charId;
    
    return card;
}


function buildLiveExportCard() {
    const currentCardState = buildCardObject();
    return buildV3Card(currentCardState);
}

function hasWorldbookContent(entries) {
    if (!entries || entries.length === 0) {
        return false;
    }
    for (const entry of entries) {
        if (entry.content && entry.content.trim() !== '') {
            return true;
        }
        if (entry.children && entry.children.length > 0) {
            if (hasWorldbookContent(entry.children)) {
                return true;
            }
        }
    }
    return false;
}

function buildV3Card(cardData) {
    // é€’å½’å‡½æ•°ï¼šå°†æ¡ç›®åŠå…¶å­æ¡ç›®è½¬æ¢ä¸ºV3æ ¼å¼
    function convertEntryToV3(entry) {
        const v3Entry = {
            id: entry.id,
            keys: entry.keys || [],
            secondary_keys: entry.secondary_keys || [],
            comment: entry.comment || '',
            content: entry.content || '',
            constant: entry.constant || false,
            selective: entry.selective === undefined ? true : entry.selective,
            insertion_order: entry.priority || 100,
            enabled: entry.enabled === undefined ? true : entry.enabled,
            position: entry.position || 'before_char',
            use_regex: entry.use_regex || false,
            extensions: {
                position: 0,
                exclude_recursion: false,
                display_index: entry.display_index,
                probability: entry.probability === undefined ? 100 : entry.probability,
                useProbability: true,
                depth: entry.wb_depth || 4,
                selectiveLogic: 0,
                group: entry.group || "",
                group_override: false,
                group_weight: 100,
                prevent_recursion: entry.prevent_recursion || false,
                delay_until_recursion: false,
                scan_depth: null,
                match_whole_words: entry.match_whole_words || null,
                use_group_scoring: false,
                case_sensitive: entry.case_sensitive || null,
                automation_id: "",
                role: 0,
                vectorized: false,
                sticky: 0,
                cooldown: 0,
                delay: 0,
                secondary_keys_logic: entry.secondary_keys_logic || 'any'
            }
        };
        
        // é€’å½’å¤„ç†å­æ¡ç›®
        if (entry.children && entry.children.length > 0) {
            v3Entry.children = entry.children.map(child => convertEntryToV3(child));
        }
        
        return v3Entry;
    }
    
    const v3BookEntries = (cardData.worldbook || []).map(entry => convertEntryToV3(entry));
    const worldbookHasContent = hasWorldbookContent(cardData.worldbook);

    const dataObject = {
        name: cardData.name || '',
        description: cardData.description || '',
        personality: cardData.personality || '',
        scenario: cardData.scenario || '',
        first_mes: cardData.first_mes || '',
        mes_example: cardData.mes_example || '',
        creator_notes: cardData.creator_notes || 'Created with Nika Character Studio',
        system_prompt: cardData.system_prompt || '',
        post_history_instructions: cardData.post_history_instructions || '',
        tags: cardData.tags || [],
        creator: 'Nika Studio User',
        character_version: cardData.character_version || '1.0',
        alternate_greetings: [],
        group_only_greetings: [],
        extensions: {
            talkativeness: "0.5",
            fav: cardData.isFavorite || false,
            world: cardData.topic || '',
            depth_prompt: { prompt: "", depth: 4, role: "system" }
        },
        character_book: worldbookHasContent ? {
            name: `(${t('world-knowledge-book')}) ${cardData.name || 'Character Book'}`,
            description: cardData.creator_notes || `Character book for ${cardData.name}.`,
            scan_depth: 10,
            token_budget: 2048,
            recursive_scanning: false,
            entries: v3BookEntries,
        } : undefined,
    };

    return {
        spec: 'chara_card_v3',
        spec_version: '3.0',
        name: dataObject.name,
        description: dataObject.description,
        personality: dataObject.personality,
        scenario: dataObject.scenario,
        first_mes: dataObject.first_mes,
        mes_example: dataObject.mes_example,
        creatorcomment: dataObject.creator_notes,
        tags: dataObject.tags,
        create_date: new Date().toISOString(),
        avatar: "none",
        talkativeness: "0.5",
        fav: dataObject.extensions.fav,
        data: dataObject,
    };
}

function buildWorldbookExportObject() {
    const cardData = buildCardObject();
    return buildWorldbookExportObjectFromData(cardData);
}

function injectEntry(entry) {
  const userPromptTextarea = document.getElementById('user_prompt');
  const comment = entry.comment;
  const content = entry.content;
  let newText;

  if (content.trim().length > 0) {
    newText = `[${comment}ï¼š${content}]`;
  } else {
    newText = `[${comment}]`;
  }

  // è·å–å…‰æ ‡ä½ç½®
  const startPos = userPromptTextarea.selectionStart;
  const endPos = userPromptTextarea.selectionEnd;

  // æ’å…¥æ–‡æœ¬
  const textBefore = userPromptTextarea.value.substring(0, startPos);
  const textAfter = userPromptTextarea.value.substring(endPos, userPromptTextarea.value.length);
  userPromptTextarea.value = textBefore + newText + textAfter;

  // æ¢å¤å…‰æ ‡ä½ç½®
  userPromptTextarea.selectionStart = startPos + newText.length;
  userPromptTextarea.selectionEnd = startPos + newText.length;

  // èšç„¦åˆ°æ–‡æœ¬æ¡†
  userPromptTextarea.focus();
}

// ====================================================================================
// --- AI HELPER FUNCTIONS ---
// ====================================================================================

function initializeLoverSwitch() {
    const loverSwitch = document.getElementById('lover-switch');
    if (loverSwitch) {
        loverSwitch.addEventListener('change', (event) => {
            toggleAiButtonText(event.target.checked);
        });
    }
}

function toggleAiButtonText(isLover) {
    const aiButtons = document.querySelectorAll('.ai-button');
    const newText = isLover ? t('generate-companion') : t('ai-help-write');
    aiButtons.forEach(button => {
        button.textContent = newText;
    });
}

function getLoverPromptPrefix() {
    return `é‡è¦æŒ‡ä»¤ï¼šä½ æ˜¯ä¸€ä¸ªå°è¯´è§’è‰²åˆ›ä½œå®¶ï¼Œä½ è¦ç”Ÿæˆçš„è§’è‰²æŠŠè¯»è€…å½“æ‹äººæˆ–è€…å¯†å‹ï¼Œå¹¶ä¸”è¯»è€…çš„ä»£è¯ä¸º"{{user}}"ï¼Œè§’è‰²çš„ä»£è¯ä¸º"{{char}}ï¼Œç”Ÿæˆç›¸å…³è§’è‰²çš„ä¿¡æ¯\n\n`;
}

// æ–°å¢: æ’¤é”€AIè¡¥å…¨çš„åŠŸèƒ½
function undoAiCompletion(undoButton) {
    const container = undoButton.closest('.field-group, .entry-grid');
    if (!container) return;
    
    const targetElement = container.querySelector('textarea, input:not([type=file]):not([type=checkbox])');
    if (targetElement && targetElement.dataset.aiBackup !== undefined) {
        targetElement.value = targetElement.dataset.aiBackup;
        delete targetElement.dataset.aiBackup; // æ¸…é™¤å¤‡ä»½
        undoButton.style.display = 'none'; // éšè—è‡ªå·±
    }
}


async function callApi(prompt, button) {
    const apiSettings = loadApiSettings();
    const provider = apiSettings.provider;

    const isLover = document.getElementById('lover-switch').checked;
    const finalPrompt = isLover ? getLoverPromptPrefix() + prompt : prompt;

    console.log(`Using API provider: ${provider}`);
    console.log("Final prompt being sent to API:", finalPrompt);

    const originalText = button.textContent;
    button.disabled = true;
    button.textContent = t('generating');

    const undoButton = button.nextElementSibling;
    if (undoButton && undoButton.classList.contains('ai-undo-button')) {
        undoButton.style.display = 'none';
    }

    let requestUrl, requestOptions;

    try {
    const geminiBody = {
        contents: [{ parts: [{ text: finalPrompt }] }],
        generationConfig: { temperature: 0.7, topK: 1, topP: 1, maxOutputTokens: 8192 }
    };

        switch (provider) {
            case 'deepseek':
                if (!apiSettings.deepseek.apiKey) throw new Error('DeepSeek API Key is missing.');
                requestUrl = "https://api.deepseek.com/chat/completions";
                requestOptions = {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiSettings.deepseek.apiKey}` },
                    body: JSON.stringify({ model: "deepseek-chat", messages: [{ "role": "user", "content": finalPrompt }] })
                };
                break;

            case 'gemini':
                if (!apiSettings.gemini.apiKey) throw new Error('Gemini API Key is missing.');
                const geminiModel = apiSettings.gemini.model || 'gemini-2.5-flash';
                requestUrl = `https://generativelanguage.googleapis.com/v1beta/models/${geminiModel}:generateContent?key=${apiSettings.gemini.apiKey}`;
                requestOptions = {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(geminiBody)
                };
                break;
            
            case 'gemini-proxy':
                if (!apiSettings['gemini-proxy'].endpoint) throw new Error('Gemini Proxy Endpoint is missing.');
                if (!apiSettings['gemini-proxy'].apiKey) throw new Error('Gemini API Key for proxy is missing.');
                
                let proxyBaseUrl = apiSettings['gemini-proxy'].endpoint;
                if (!proxyBaseUrl.startsWith('http')) proxyBaseUrl = 'https://' + proxyBaseUrl;
                // remove trailing slash if present
                if (proxyBaseUrl.endsWith('/')) {
                    proxyBaseUrl = proxyBaseUrl.slice(0, -1);
                }

                const geminiProxyModel = apiSettings['gemini-proxy'].model || 'gemini-2.5-flash';
                requestUrl = `${proxyBaseUrl}/${geminiProxyModel}:generateContent?key=${apiSettings['gemini-proxy'].apiKey}`;
                requestOptions = {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }, // No Authorization header
                    body: JSON.stringify(geminiBody)
                };
                break;

        case 'local':
        case 'tavern':
            const isLocal = provider === 'local';
            const providerSettings = apiSettings[provider];
            const endpoint = providerSettings.endpoint;

            if (!endpoint) throw new Error(`API Endpoint for ${provider} is missing.`);

            let finalEndpoint = endpoint;
            if (finalEndpoint.endsWith('/v1')) {
                finalEndpoint += '/chat/completions';
            }
            if (!finalEndpoint.startsWith('http')) {
                // Local endpoints are http, not https
                finalEndpoint = (isLocal ? 'http://' : 'https://') + finalEndpoint;
            }
            requestUrl = finalEndpoint;

            const headers = { 'Content-Type': 'application/json' };
            // Only add auth header for tavern if key exists
            if (!isLocal && providerSettings.apiKey) {
                headers['Authorization'] = `Bearer ${providerSettings.apiKey}`;
            }

            requestOptions = {
                method: 'POST',
                headers: headers,
                body: JSON.stringify({
                    model: providerSettings.model || 'local-model', // For local, model name is often ignored
                    messages: [{ "role": "user", "content": finalPrompt }],
                    stream: false
                })
            };
            break;

            default:
                throw new Error(`Unknown API provider: ${provider}`);
        }

        const response = await fetch(requestUrl, requestOptions);

        if (!response.ok) {
            const errorBody = await response.text();
            let errorMessage = errorBody;
            try {
                const errorJson = JSON.parse(errorBody);
                errorMessage = errorJson.error?.message || JSON.stringify(errorJson);
            } catch (e) { /* Ignore if not JSON */ }
            throw new Error(t('api-request-failed', { status: response.statusText, message: errorMessage }));
        }

        const data = await response.json();
        
        // Handle different response structures
        if (provider === 'gemini' || provider === 'gemini-proxy') {
            if (data.candidates && data.candidates.length > 0) {
                return data.candidates[0].content.parts[0].text;
            }
            // Handle error response from Gemini
            if (data.error) {
                throw new Error(`Gemini API Error: ${data.error.message}`);
            }
        }
        // For DeepSeek and Tavern (assuming OpenAI compatible)
        if (data.choices && data.choices.length > 0) {
            return data.choices[0].message.content;
        }
        
        // Fallback for unexpected response structures
        throw new Error('Unexpected API response structure. Check console for details.');

    } catch (error) {
        console.error(`API error with provider ${provider}:`, error);
        alert(`${t('ai-completion-failed')}\nError: ${error.message}`);
        return null;
    } finally {
        button.disabled = false;
        button.textContent = originalText;
    }
}

async function callDeepSeek(fieldId) {
    const button = event.target;
    const targetElement = document.getElementById(fieldId);
    if (!targetElement) return;

    targetElement.dataset.aiBackup = targetElement.value;
    
    const labelText = document.querySelector(`label[for='${fieldId}']`).innerText.replace(' (é€—å·åˆ†éš”)','');

    getAiGuidance(t('ai-guidance-title') + `: ${labelText}`, async (userGuidance) => {
        const currentCard = buildCardObject();
        const existingEntries = buildWorldbookDataFromDOM();
        const existingEntriesText = existingEntries.map(e => `- ${e.comment}: ${e.content.substring(0, 100)}...`).join('\n');

        let prompt = `ä½ æ˜¯ä¸€ä½ä¸“ä¸šçš„è§’è‰²è®¾å®šå¸ˆã€‚è¯·æ ¹æ®ä»¥ä¸‹å·²ç»æä¾›çš„è§’è‰²ä¿¡æ¯ï¼Œä¸ºæˆ‘ç”Ÿæˆæˆ–è¡¥å…¨ã€${labelText}ã€‘è¿™ä¸€é¡¹ã€‚
è¯·ç›´æ¥è¿”å›æœ€é€‚åˆå¡«å…¥è¯¥é¡¹çš„å†…å®¹ï¼Œè¯­è¨€é£æ ¼è¦è‡ªç„¶ï¼Œä¸è¦åŒ…å«ä»»ä½•é¢å¤–è§£é‡Šã€æ ‡é¢˜æˆ–æ ‡ç­¾ã€‚

å·²æä¾›ä¿¡æ¯:
- ä¸»é¢˜/ä¸–ç•Œè§‚: ${currentCard.topic || 'æœªæŒ‡å®š'}
- è§’è‰²å: ${currentCard.name || 'æœªæŒ‡å®š'}
- æ€§åˆ«: ${currentCard.gender || 'æœªæŒ‡å®š'}
- è§’è‰²æè¿°: ${currentCard.description || 'æœªæŒ‡å®š'}
- åˆ†ç±»æ ‡ç­¾: ${(currentCard.tags && currentCard.tags.length > 0) ? currentCard.tags.join(', ') : 'æœªæŒ‡å®š'}
- ä¸ªæ€§: ${currentCard.personality || 'æœªæŒ‡å®š'}
- åœºæ™¯è®¾å®š: ${currentCard.scenario || 'æœªæŒ‡å®š'}
- é¦–æ¬¡å‘è¨€: ${currentCard.first_mes || 'æœªæŒ‡å®š'}
- èŒƒä¾‹å¯¹è¯: ${currentCard.mes_example || 'æœªæŒ‡å®š'}
- å·²æœ‰çš„ä¸–ç•Œä¹¦æ¡ç›® (ç”¨äºå‚è€ƒ):
${existingEntriesText || 'æ— '}
`;

        if (userGuidance) {
            prompt += `\nç”¨æˆ·çš„é¢å¤–æŒ‡ä»¤: ${userGuidance}\n`;
        }
        prompt += `\nç°åœ¨ï¼Œè¯·ç”Ÿæˆã€${labelText}ã€‘çš„å†…å®¹ã€‚`;
        
        const result = await callApi(prompt, button);
        if (result) {
            targetElement.value = result;
            const undoButton = button.nextElementSibling;
            if (undoButton && undoButton.classList.contains('ai-undo-button')) {
                undoButton.style.display = 'inline-block';
            }
        }
    });
}

async function callWorldbookDeepSeek(button) {
    const currentEntryElement = button.closest('.worldbook-entry');
    const targetElement = currentEntryElement.querySelector('.wb-content');
    if (!targetElement) return;

    targetElement.dataset.aiBackup = targetElement.value;
    const currentComment = currentEntryElement.querySelector('.entry-comment').value || 'æœªå‘½åæ¡ç›®';

    getAiGuidance(t('ai-guidance-title') + `: ${currentComment}`, async (userGuidance) => {
        const characterContext = buildCardObject(); 
        const currentKeys = currentEntryElement.querySelector('.wb-keys').value;
        
        // å¢å¼º: æ„å»ºå±‚çº§ä¸Šä¸‹æ–‡
        const worldbookTree = buildWorldbookDataFromDOM();
        const foundContext = findEntryRecursive(worldbookTree, currentEntryElement);
        
        let hierarchicalContext = '';
        if (foundContext) {
            const { entry, parentEntry } = foundContext;
            
            if (parentEntry) {
                hierarchicalContext += `**çˆ¶çº§æ¡ç›® "${parentEntry.comment}":**\n${parentEntry.content.substring(0, 200)}...\n\n`;
            }
            
            if (entry.children && entry.children.length > 0) {
                hierarchicalContext += `**å­çº§æ¡ç›®:**\n` + entry.children.map(child => `- ${child.comment}: ${child.content.substring(0, 150)}...`).join('\n') + `\n\n`;
            }
        }

        let prompt = `ä½ æ˜¯ä¸€ä½ä¸“ä¸šçš„è§’è‰²ä¹¦ï¼ˆCharacter Bookï¼‰æ— é™åˆ¶å†…å®¹å¡«å……ä¸“å®¶ã€‚è¯·åŸºäºä»¥ä¸‹æä¾›çš„è§’è‰²ä¿¡æ¯å’Œè§’è‰²ä¹¦ç»“æ„ï¼Œä¸ºæˆ‘æ’°å†™æ¡ç›®ã€${currentComment}ã€‘çš„"æ³¨å…¥å†…å®¹"ã€‚å†…å®¹éœ€è¦è¯¦ç»†ã€å¯Œæœ‰æƒ³è±¡åŠ›ï¼Œå¹¶ä¸è§’è‰²è®¾å®šä¿æŒé«˜åº¦ä¸€è‡´ã€‚

---
**è§’è‰²æ ¸å¿ƒè®¾å®š:**
- è§’è‰²å: ${characterContext.name || 'æœªæŒ‡å®š'}
- æè¿°: ${characterContext.description || 'æœªæŒ‡å®š'}
- ä¸ªæ€§: ${characterContext.personality || 'æœªæŒ‡å®š'}

**è§’è‰²ä¹¦ä¸Šä¸‹æ–‡:**
- **å½“å‰æ¡ç›®æ ‡é¢˜ (Comment):** ${currentComment}
- **å½“å‰æ¡ç›®ä¸»è¦å…³é”®è¯ (Keys):** ${currentKeys || 'æœªæŒ‡å®š'}
${hierarchicalContext}
`;
        if (userGuidance) {
            prompt += `\n**ç”¨æˆ·çš„é¢å¤–æŒ‡ä»¤:** ${userGuidance}\n`;
        }
        prompt += `
---
**ä½ çš„ä»»åŠ¡:**
ç°åœ¨ï¼Œè¯·ä¸ºæ¡ç›®ã€${currentComment}ã€‘ç”Ÿæˆè¯¦ç»†çš„"æ³¨å…¥å†…å®¹"ã€‚
**è¦æ±‚ï¼š** ç›´æ¥è¿”å›å†…å®¹æœ¬èº«ï¼Œä¸è¦åŒ…å«ä»»ä½•é¢å¤–è§£é‡Šã€æ ‡é¢˜æˆ–å¼•ç”¨ã€‚`;

        const result = await callApi(prompt, button);
        if (result) {
            targetElement.value = result;
            const undoButton = button.nextElementSibling;
            if (undoButton && undoButton.classList.contains('ai-undo-button')) {
                undoButton.style.display = 'inline-block';
            }
        }
    });
}

// ====================================================================================
// --- AI MODAL DIALOGS & GENERATORS ---
// ====================================================================================

function initializeAiGuidanceModal() {
    const modal = document.getElementById('ai-guidance-modal');
    const generateBtn = document.getElementById('ai-guidance-generate-btn');
    const cancelBtn = document.getElementById('ai-guidance-cancel-btn');
    
    modal.onclick = (e) => { if (e.target === modal) modal.style.display = 'none'; };
    cancelBtn.onclick = () => modal.style.display = 'none';
}

function getAiGuidance(title, callback, placeholder = '') {
    const modal = document.getElementById('ai-guidance-modal');
    const titleEl = document.getElementById('ai-guidance-title');
    const inputEl = document.getElementById('ai-guidance-input');
    const generateBtn = document.getElementById('ai-guidance-generate-btn');

    titleEl.textContent = title;
    inputEl.value = '';
    inputEl.placeholder = placeholder || t('ai-guidance-prompt');
    
    generateBtn.onclick = () => {
        modal.style.display = 'none';
        callback(inputEl.value.trim());
    };

    modal.style.display = 'flex';
    inputEl.focus();
}

function initializeNameGeneratorModal() {
    const modal = document.getElementById('name-generator-modal');
    const cancelButton = document.getElementById('cancel-name-generation-btn');
    const regenerateButton = document.getElementById('regenerate-names-btn');

    modal.addEventListener('click', (event) => {
        if (event.target === modal) modal.style.display = 'none';
    });
    cancelButton.addEventListener('click', () => modal.style.display = 'none');
    regenerateButton.addEventListener('click', () => {
        const generatorButton = document.querySelector('.name-generator-btn');
        generateAiNames(generatorButton);
    });
}

async function generateAiNames(button) {
    const modal = document.getElementById('name-generator-modal');
    const optionsContainer = document.getElementById('name-options-container');
    const regenerateButton = document.getElementById('regenerate-names-btn');
    
    optionsContainer.innerHTML = `<div class="loading-spinner" style="margin: 20px auto;"></div>`;
    modal.style.display = 'flex';

    const currentCard = buildCardObject();
    const prompt = `ä½ æ˜¯ä¸€ä½å¯Œæœ‰åˆ›é€ åŠ›çš„å‘½åå¤§å¸ˆã€‚è¯·æ ¹æ®ä»¥ä¸‹è§’è‰²è®¾å®šï¼Œä¸ºè§’è‰²ç”Ÿæˆ5ä¸ªå¥½å¬ã€è´´åˆ‡çš„åå­—ã€‚
è¯·ä¸¥æ ¼æŒ‰ç…§JSONæ•°ç»„çš„æ ¼å¼è¿”å›ï¼Œä¾‹å¦‚ï¼š["åå­—A", "åå­—B", "åå­—C", "åå­—D", "åå­—E"]ã€‚ä¸è¦åŒ…å«ä»»ä½•é¢å¤–çš„è§£é‡Šæˆ–æ–‡æœ¬ã€‚

è§’è‰²è®¾å®š:
- ä¸»é¢˜/ä¸–ç•Œè§‚: ${currentCard.topic || 'æœªæŒ‡å®š'}
- æ€§åˆ«: ${currentCard.gender || 'æœªæŒ‡å®š'}
- è§’è‰²æè¿°: ${currentCard.description || 'æœªæŒ‡å®š'}
- ä¸ªæ€§: ${currentCard.personality || 'æœªæŒ‡å®š'}`;

    const originalRegenerateText = regenerateButton.textContent;
    regenerateButton.disabled = true;
    regenerateButton.textContent = t('generating');

    try {
        const result = await callApi(prompt, button);
        if (result) {
            const cleanedResult = result.replace(/^```json\s*|```$/g, '').trim();
            const names = JSON.parse(cleanedResult);

            if (Array.isArray(names) && names.length > 0) {
                optionsContainer.innerHTML = '';
                names.forEach(name => {
                    const nameButton = document.createElement('button');
                    nameButton.textContent = name;
                    nameButton.onclick = () => {
                        document.getElementById('name').value = name;
                        modal.style.display = 'none';
                    };
                    optionsContainer.appendChild(nameButton);
                });
            } else {
                throw new Error("AI did not return a valid array of names.");
            }
        } else {
            optionsContainer.innerHTML = `<p>${t('name-generation-failed')}</p>`;
        }
    } catch (e) {
        console.error("Failed to parse AI-generated names:", e);
        console.error("Raw response:", result);
        optionsContainer.innerHTML = `<p>${t('name-generation-failed')}</p>`;
    } finally {
        regenerateButton.disabled = false;
        regenerateButton.textContent = originalRegenerateText;
    }
}


function initializeWorldbookAiModal() {
    const modal = document.getElementById('worldbook-ai-generator-modal');
    const injectBtn = document.getElementById('wb-ai-inject-btn');
    const regenerateBtn = document.getElementById('wb-ai-regenerate-btn');
    const cancelBtn = document.getElementById('wb-ai-cancel-btn');
    const genTypeButtons = modal.querySelectorAll('.generation-type-selector button');

    cancelBtn.onclick = () => modal.style.display = 'none';
    modal.onclick = (e) => { if (e.target === modal) modal.style.display = 'none'; };
    
    genTypeButtons.forEach(button => {
        button.onclick = () => {
            const genType = button.dataset.type;
            modal.dataset.lastGenType = genType; // Store for regeneration
            const generatorButton = document.getElementById('ai-lorebook-generator-btn');
            fetchWorldbookStoryNodes(generatorButton, genType);
        };
    });

    regenerateBtn.onclick = () => {
        const genType = modal.dataset.lastGenType;
        if (genType) {
            const generatorButton = document.getElementById('ai-lorebook-generator-btn');
            fetchWorldbookStoryNodes(generatorButton, genType);
        }
    };

    injectBtn.onclick = () => {
        const container = document.getElementById('wb-ai-options-container');
        const checked = container.querySelectorAll('input[type="checkbox"][data-entry]:checked');
        const existingEntries = buildWorldbookDataFromDOM();
        let maxId = existingEntries.length > 0 ? Math.max(...existingEntries.map(e => e.id)) : -1;

        const newEntries = Array.from(checked).map(checkbox => {
            const entryData = JSON.parse(checkbox.dataset.entry);
            maxId++;
            return {
                ...entryData,
                id: maxId,
                children: [] 
            };
        });

        if (newEntries.length > 0) {
            renderWorldbookFromData(existingEntries.concat(newEntries));
            alert(t('lorebook-injected-success', {count: newEntries.length}));
        }
        modal.style.display = 'none';
    };
}

function openWorldbookAiModal(button) {
    const modal = document.getElementById('worldbook-ai-generator-modal');
    const desc = document.getElementById('wb-ai-modal-desc');
    const optionsContainer = document.getElementById('wb-ai-options-container');
    const injectBtn = document.getElementById('wb-ai-inject-btn');
    const regenerateBtn = document.getElementById('wb-ai-regenerate-btn');
    
    // Reset modal state
    desc.textContent = t('wb-ai-modal-desc');
    optionsContainer.innerHTML = '';
    injectBtn.style.display = 'none';
    regenerateBtn.style.display = 'none';
    
    modal.style.display = 'flex';
}

async function fetchWorldbookStoryNodes(button, generationType) {
    const modal = document.getElementById('worldbook-ai-generator-modal');
    const container = document.getElementById('wb-ai-options-container');
    const desc = document.getElementById('wb-ai-modal-desc');
    const injectBtn = document.getElementById('wb-ai-inject-btn');
    const regenerateBtn = document.getElementById('wb-ai-regenerate-btn');

    const typeName = t(`wb-ai-type-${generationType}`);
    desc.textContent = t('wb-ai-modal-desc-generating', {type: typeName});
    container.innerHTML = `<div class="loading-spinner" style="margin: 20px auto;"></div>`;
    injectBtn.style.display = 'none';
    regenerateBtn.style.display = 'none';
    
    const characterContext = buildCardObject();
    const existingEntries = buildWorldbookDataFromDOM(); // è·å–ç°æœ‰æ¡ç›®
    
    // DeepSeek é™åˆ¶é€»è¾‘
    const apiSettings = loadApiSettings();
    const isDeepSeek = apiSettings.provider === 'deepseek';
    const totalEntries = countAllEntries(existingEntries);
    const truncationLength = isDeepSeek && totalEntries > 0 ? Math.floor(40000 / totalEntries) : Infinity;

    const existingEntriesText = existingEntries.map(entry => {
        const truncatedContent = entry.content.substring(0, truncationLength);
        return `æ¡ç›®æ³¨é‡Š: ${entry.comment}\nå…³é”®è¯: ${entry.keys.join(', ')}\nå†…å®¹: ${truncatedContent}${entry.content.length > truncationLength ? '...' : ''}\n`;
    }).join('\n---\n');

    let prompt;
    switch (generationType) {
        case 'worldview':
            prompt = `ä½ æ˜¯ä¸€ä½ä¸–ç•Œæ„å»ºä¸“å®¶ã€‚è¯·åˆ†æä»¥ä¸‹è§’è‰²è®¾å®šå’Œã€å·²æœ‰çš„ä¸–ç•Œä¹¦æ¡ç›®ã€‘ï¼Œå¹¶ä¸ºè¯¥è§’è‰²åˆ›å»º3-5ä¸ªã€æ–°çš„ã€ä¸é‡å¤çš„ã€‘æ ¸å¿ƒã€ä¸–ç•Œè§‚ã€‘æ¡ç›®ã€‚è¿™äº›æ¡ç›®åº”è¯¥æè¿°é‡è¦çš„åœ°ç‚¹ã€ç»„ç»‡ã€æ¦‚å¿µæˆ–æŠ€æœ¯ã€‚`;
            break;
        case 'main_plot':
            prompt = `ä½ æ˜¯ä¸€ä½å‰§æƒ…è®¾è®¡å¸ˆã€‚è¯·åˆ†æä»¥ä¸‹è§’è‰²è®¾å®šå’Œã€å·²æœ‰çš„ä¸–ç•Œä¹¦æ¡ç›®ã€‘ï¼Œå¹¶ä¸ºè¯¥è§’è‰²åˆ›å»ºä¸€å¥—åŒ…å«1ä¸ªä¸»çº¿ç›®æ ‡å’Œ2-3ä¸ªæ­¥éª¤çš„ã€æ–°çš„ã€ä¸é‡å¤çš„ã€‘ã€ä¸»çº¿å‰§æƒ…ã€‘æ¡ç›®ã€‚`;
            break;
        case 'side_plot':
            prompt = `ä½ æ˜¯ä¸€ä½æ•…äº‹åˆ›ä½œè€…ã€‚è¯·åˆ†æä»¥ä¸‹è§’è‰²è®¾å®šå’Œã€å·²æœ‰çš„ä¸–ç•Œä¹¦æ¡ç›®ã€‘ï¼Œå¹¶ä¸ºè¯¥è§’è‰²åˆ›å»ºä¸€å¥—åŒ…å«2-3ä¸ªç›¸å…³æ¡ç›®çš„ã€æ–°çš„ã€ä¸é‡å¤çš„ã€‘ã€æ”¯çº¿å‰§æƒ…ã€‘ã€‚`;
            break;
    }

    prompt += `
**è§’è‰²è®¾å®š:**
- è§’è‰²å: ${characterContext.name || 'æœªæŒ‡å®š'}
- ä¸»é¢˜/ä¸–ç•Œè§‚: ${characterContext.topic || 'æœªæŒ‡å®š'}
- è§’è‰²æè¿°: ${characterContext.description || 'æœªæŒ‡å®š'}

**å·²æœ‰çš„ä¸–ç•Œä¹¦æ¡ç›® (ç”¨äºå‚è€ƒï¼Œè¯·å‹¿é‡å¤):**
${existingEntriesText || 'æ— '}

**ä½ çš„ä»»åŠ¡:**
**ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹JSONæ ¼å¼è¿”å›ä½ çš„ç­”æ¡ˆï¼Œä¸è¦åŒ…å«ä»»ä½•JSONæ ¼å¼ä¹‹å¤–çš„é¢å¤–æ–‡å­—ã€è§£é‡Šæˆ–Markdownæ ‡è®°ã€‚**
è¿”å›ä¸€ä¸ªJSONæ•°ç»„ï¼Œå…¶ä¸­æ¯ä¸ªå¯¹è±¡ä»£è¡¨ä¸€ä¸ªæ¡ç›®ï¼Œä¸”å¿…é¡»åŒ…å«ä»¥ä¸‹é”®:
- "comment": (å­—ç¬¦ä¸²) æ¡ç›®æ³¨é‡Š/æ ‡é¢˜ã€‚
- "keys": (å­—ç¬¦ä¸²æ•°ç»„) ç›¸å…³çš„è§¦å‘å…³é”®è¯ã€‚
- "content": (å­—ç¬¦ä¸²) æ¡ç›®çš„è¯¦ç»†å†…å®¹ã€‚
- "priority": (æ•°å­—) ä¼˜å…ˆçº§ï¼Œè¶Šå¤§è¶Šé‡è¦ (æ™®é€š=100, é‡è¦=200, æ ¸å¿ƒ=1000)ã€‚
- "constant": (å¸ƒå°”å€¼) æ˜¯å¦ä¸ºæ’å®šæ³¨å…¥ã€‚å¯¹äºåŸºç¡€ä¸–ç•Œè§‚ã€è§’è‰²æ ¸å¿ƒè®¾å®šç­‰åº”ä¸º trueï¼Œå¯¹äºå…·ä½“äº‹ä»¶æˆ–åœ°ç‚¹ç­‰åº”ä¸º falseã€‚
`;

    getAiGuidance(t('ai-guidance-title'), async (userGuidance) => {
        let finalPrompt = prompt;
        if (userGuidance) {
            finalPrompt += `\n**ç”¨æˆ·çš„é¢å¤–æŒ‡ä»¤:** ${userGuidance}\n`;
        }

        const result = await callApi(finalPrompt, button);
        try {
            if (result) {
                const cleanedResult = result.replace(/^```json\s*|```$/g, '');
                const generatedEntries = JSON.parse(cleanedResult);

                if (Array.isArray(generatedEntries)) {
                    desc.textContent = t('wb-ai-modal-desc-generated', {type: typeName});
                    container.innerHTML = ''; // Clear spinner
                    injectBtn.style.display = 'inline-block';
                    regenerateBtn.style.display = 'inline-block';

                    generatedEntries.forEach((entry) => {
                        const entryData = {
                            comment: entry.comment || 'æ— é¢˜',
                            keys: entry.keys || [],
                            content: entry.content || 'æ— å†…å®¹',
                            priority: entry.priority || 100,
                            constant: entry.constant || false, // Capture the new field
                            enabled: true, 
                            selective: true, 
                            position: 'before_char', 
                            wb_depth: 4,
                        };

                        const entryDiv = document.createElement('div');
                        entryDiv.className = 'generated-entry';
                        
                        // Main selection checkbox
                        // ================== BUG FIX START ==================
                        const mainCheckboxId = `main-check-id-${Math.random().toString(36).slice(2)}`;
                        // =================== BUG FIX END ===================

                        entryDiv.innerHTML = `
                            <label for="${mainCheckboxId}">
                                <input type="checkbox" id="${mainCheckboxId}" checked data-entry='${JSON.stringify(entryData)}'>
                                <div class="entry-details">
                                    <h4>${entry.comment || 'æ— é¢˜'}</h4>
                                    <p><strong>è§¦å‘è¯:</strong> ${(entry.keys || []).join(', ')}</p>
                                    <p><strong>å†…å®¹:</strong> ${entry.content || 'æ— å†…å®¹'}</p>
                                    <div class="ai-entry-controls">
                                        <span><strong>å»ºè®®ä¼˜å…ˆçº§:</strong> ${entry.priority || 100}</span>
                                        <label>
                                            <input type="checkbox" class="wb-ai-constant-toggle" ${entry.constant ? 'checked' : ''}>
                                            ${t('entry-constant')}
                                        </label>
                                    </div>
                                </div>
                            </label>
                        `;
                        container.appendChild(entryDiv);
                        
                        // Add event listener to the new constant toggle
                        const constantToggle = entryDiv.querySelector('.wb-ai-constant-toggle');
                        const mainCheckbox = entryDiv.querySelector(`#${mainCheckboxId}`);
                        
                        constantToggle.addEventListener('change', (e) => {
                            const currentData = JSON.parse(mainCheckbox.dataset.entry);
                            currentData.constant = e.target.checked;
                            mainCheckbox.dataset.entry = JSON.stringify(currentData);
                        });
                    });
                } else { throw new Error(t('ai-return-not-array')); }
            }
        } catch (e) {
            console.error("è§£æAIè¿”å›çš„JSONå¤±è´¥:", e, "æ”¶åˆ°çš„åŸå§‹æ•°æ®:", result);
            container.innerHTML = `<p>${t('ai-parse-failed')}</p>`;
            alert(t('ai-parse-failed'));
        }
    });
}


async function aiCompleteAllFields(button) {
    const currentCard = buildCardObject();
    const allFields = ["name", "topic", "gender", "description", "personality", "tags", "system_prompt", "scenario", "first_mes", "mes_example"];
    const filledFields = {};
    const emptyFields = [];

    allFields.forEach(id => {
        const el = document.getElementById(id);
        if (el) {
            if (el.value.trim()) {
                filledFields[id] = el.value.trim();
            } else {
                emptyFields.push(id);
            }
        }
    });

    const isAnythingFilled = Object.keys(filledFields).length > 0;
    const existingEntries = buildWorldbookDataFromDOM();
    
    // DeepSeek é™åˆ¶é€»è¾‘
    const apiSettings = loadApiSettings();
    const isDeepSeek = apiSettings.provider === 'deepseek';
    const totalEntries = countAllEntries(existingEntries);
    const truncationLength = isDeepSeek && totalEntries > 0 ? Math.floor(40000 / totalEntries) : Infinity;

    const existingEntriesText = existingEntries.map(entry => {
        const truncatedContent = entry.content.substring(0, truncationLength);
        return `- ${entry.comment}: ${truncatedContent}${entry.content.length > truncationLength ? '...' : ''}`;
    }).join('\n');

    const worldbookContextPrompt = `
---
**å·²æœ‰çš„ä¸–ç•Œä¹¦æ¡ç›® (ç”¨äºå‚è€ƒ):**
${existingEntriesText || 'æ— '}
---`;

    if (isAnythingFilled) {
        // æ–¹æ¡ˆ1ï¼šæœ‰å†…å®¹ï¼Œè¡¥å…¨å…¶ä»–
        if (emptyFields.length === 0) {
            alert("æ‰€æœ‰å­—æ®µéƒ½å·²å¡«å†™ï¼");
            return;
        }
        
        getAiGuidance(t('ai-guidance-title'), async (userGuidance) => {
            emptyFields.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.dataset.aiBackup = el.value;
            });

            let prompt = `ä½ æ˜¯ä¸€ä½é¡¶çº§çš„è§’è‰²è®¾è®¡å¸ˆã€‚è¯·æ ¹æ®ä»¥ä¸‹å·²ç»æä¾›çš„è§’è‰²ä¿¡æ¯ï¼Œä¸ºè§’è‰²è¡¥å…¨å‰©ä½™çš„ç©ºç™½å­—æ®µã€‚
---
**å·²æä¾›çš„ä¿¡æ¯:**
${Object.entries(filledFields).map(([key, value]) => `- ${t(key)}: ${value}`).join('\n')}
${worldbookContextPrompt}
---
**éœ€è¦ä½ è¡¥å…¨çš„å­—æ®µ:**
"${emptyFields.join('", "')}"
---
`;
            if (userGuidance) {
                prompt += `**ç”¨æˆ·çš„é¢å¤–æŒ‡ä»¤:** ${userGuidance}\n---`;
            }
            prompt += `**ä½ çš„ä»»åŠ¡:**
è¯·ä¸ºéœ€è¦è¡¥å…¨çš„å­—æ®µç”Ÿæˆå†…å®¹ï¼Œå¹¶**ä¸¥æ ¼ä»¥ä¸€ä¸ªå•ä¸€çš„JSONå¯¹è±¡æ ¼å¼è¿”å›**ï¼ŒåªåŒ…å«ä½ éœ€è¦è¡¥å…¨çš„å­—æ®µçš„é”®å’Œå€¼ã€‚ä¸è¦åŒ…å«ä»»ä½•è§£é‡Šæˆ–Markdownæ ‡è®°ã€‚
- å¯¹äº "tags" å’Œ "personality" å­—æ®µ, è¯·è¿”å›ä¸€ä¸ªç”±é€—å·åˆ†éš”çš„å­—ç¬¦ä¸²ã€‚
- å¯¹äº "mes_example", è¯·ç”Ÿæˆä¸€æ®µåŒ…å«{{user}}å’Œ{{char}}çš„å¯¹è¯ç¤ºä¾‹ï¼Œå¯¹è¯å¼€å§‹å¦èµ·ä¸€è¡Œä»¥<START>å¼€å¤´ã€‚ä¾‹å¦‚ï¼š
<START>ï¼ˆæ¯æ¬¡å¯¹è¯çš„å¼€å¤´éƒ½éœ€è¦è¿™æ ·æ ‡è®°ï¼‰

{{user}}: ä½ å¥½ã€‚
{{char}}: (å¾®ç¬‘ç€å‘ä½ ç‚¹å¤´) ä½ å¥½ï¼Œ{{user}}ã€‚æ‰¾æˆ‘æœ‰ä»€ä¹ˆäº‹å—ï¼Ÿ

`;
            const result = await callApi(prompt, button);
            if (result) {
                try {
                    const cleanedResult = result.replace(/^```json\s*|```$/g, '');
                    const data = JSON.parse(cleanedResult);

                    emptyFields.forEach(id => {
                        if (data[id]) {
                            const el = document.getElementById(id);
                            if (el) {
                                el.value = data[id];
                                const undoBtn = el.closest('.field-group').querySelector('.ai-undo-button');
                                if (undoBtn) {
                                    undoBtn.style.display = 'inline-block';
                                }
                            }
                        }
                    });
                    alert(t('all-fields-completed'));
                } catch (e) {
                    console.error("è§£æAIè¿”å›çš„JSONå¤±è´¥:", e, "æ”¶åˆ°çš„åŸå§‹æ•°æ®:", result);
                    alert(t('ai-parse-failed'));
                }
            }
        }, t('ai-guidance-prompt'));

    } else {
        // æ–¹æ¡ˆ2ï¼šå…¨ç©ºï¼ŒæŒ‰åŸé€»è¾‘æ‰§è¡Œ
        getAiGuidance(t('ai-complete-all-guidance-title'), async (userGuidance) => {
            if (!userGuidance) {
                alert(t('ai-complete-all-guidance-placeholder'));
                return;
            }

            const fieldsToComplete = ["description", "personality", "tags", "system_prompt", "scenario", "first_mes", "mes_example", "name", "topic", "gender"];
            fieldsToComplete.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.dataset.aiBackup = el.value;
            });

            const prompt = `ä½ æ˜¯ä¸€ä½é¡¶çº§çš„è§’è‰²è®¾è®¡å¸ˆã€‚æ ¹æ®ç”¨æˆ·æä¾›çš„æ ¸å¿ƒæ¦‚å¿µï¼Œä¸ºè§’è‰²ç”Ÿæˆä¸€ä¸ªå®Œæ•´çš„è®¾å®šæ¡£æ¡ˆã€‚
---
**ç”¨æˆ·æ ¸å¿ƒæ¦‚å¿µ:** ${userGuidance}
${worldbookContextPrompt}
---
**ä½ çš„ä»»åŠ¡:**
è¯·ä¸ºä»¥ä¸‹æ‰€æœ‰å­—æ®µç”Ÿæˆå†…å®¹ï¼Œå¹¶**ä¸¥æ ¼ä»¥ä¸€ä¸ªå•ä¸€çš„JSONå¯¹è±¡æ ¼å¼è¿”å›**ï¼Œä¸è¦åŒ…å«ä»»ä½•è§£é‡Šæˆ–Markdownæ ‡è®°ã€‚
å­—æ®µåŒ…æ‹¬: "${fieldsToComplete.join('", "')}"
- å¯¹äº "tags" å’Œ "personality" å­—æ®µ, è¯·è¿”å›ä¸€ä¸ªç”±é€—å·åˆ†éš”çš„å­—ç¬¦ä¸²ã€‚
- å¯¹äº "mes_example", è¯·ç”Ÿæˆä¸€æ®µåŒ…å«{{user}}å’Œ{{char}}çš„å¯¹è¯ç¤ºä¾‹ï¼Œå¯¹è¯å¼€å§‹å¦èµ·ä¸€è¡Œä»¥<START>å¼€å¤´ã€‚ä¾‹å¦‚ï¼š
<START>ï¼ˆæ¯æ¬¡å¯¹è¯çš„å¼€å¤´éƒ½éœ€è¦è¿™æ ·æ ‡è®°ï¼‰

{{user}}: ä½ å¥½ã€‚
{{char}}: (å¾®ç¬‘ç€å‘ä½ ç‚¹å¤´) ä½ å¥½ï¼Œ{{user}}ã€‚æ‰¾æˆ‘æœ‰ä»€ä¹ˆäº‹å—ï¼Ÿ
`;
            const result = await callApi(prompt, button);
            if (result) {
                try {
                    const cleanedResult = result.replace(/^```json\s*|```$/g, '');
                    const data = JSON.parse(cleanedResult);

                    fieldsToComplete.forEach(id => {
                        if (data[id]) {
                            const el = document.getElementById(id);
                            if (el) {
                                el.value = data[id];
                                const undoBtn = el.closest('.field-group').querySelector('.ai-undo-button');
                                if (undoBtn) {
                                    undoBtn.style.display = 'inline-block';
                                }
                            }
                        }
                    });
                    alert(t('all-fields-completed'));
                } catch (e) {
                    console.error("è§£æAIè¿”å›çš„JSONå¤±è´¥:", e, "æ”¶åˆ°çš„åŸå§‹æ•°æ®:", result);
                    alert(t('ai-parse-failed'));
                }
            }
        }, t('ai-complete-all-guidance-placeholder'));
    }
}

// ====================================================================================
// --- LORE BOOK MANAGEMENT (DATA-DRIVEN) ---
// ====================================================================================

function findEntryRecursive(list, elementToFind, parent = null) {
    for (let i = 0; i < list.length; i++) {
        const item = list[i];
        if (item.element === elementToFind) {
            return {
                entry: item,
                parentList: list,
                index: i,
                parentEntry: parent
            };
        }
        if (item.children && item.children.length > 0) {
            const found = findEntryRecursive(item.children, elementToFind, item);
            if (found) {
                return found;
            }
        }
    }
    return null;
}

function parseEntryFromElement(element) {
    return {
        id: parseInt(element.querySelector('.wb-sort-id').value, 10) || 0,
        keys: element.querySelector('.wb-keys').value.split(/[,ã€ï¼Œ\s]+/).map(k => k.trim()).filter(Boolean),
        secondary_keys: element.querySelector('.wb-secondary-keys').value.split(/[,ã€ï¼Œ\s]+/).map(k => k.trim()).filter(Boolean),
        secondary_keys_logic: element.querySelector('.wb-secondary-keys-logic').value,
        comment: element.querySelector('.entry-comment').value,
        content: element.querySelector('.wb-content').value,
        priority: parseInt(element.querySelector('.wb-priority').value, 10) || 100,
        enabled: element.querySelector('.wb-enabled').checked,
        prevent_recursion: element.querySelector('.wb-prevent-recursion').checked,
        group: element.querySelector('.wb-group').value.trim(),
        position: element.querySelector('.wb-position').value,
        scope: element.querySelector('.wb-scope').value,
        constant: element.querySelector('.wb-constant').checked,
        selective: element.querySelector('.wb-selective').checked,
        use_regex: element.querySelector('.wb-use-regex').checked,
        match_whole_words: element.querySelector('.wb-match-whole-words').checked,
        case_sensitive: element.querySelector('.wb-case-sensitive').checked,
        probability: parseInt(element.querySelector('.wb-probability').value, 10),
        wb_depth: parseInt(element.querySelector('.wb-depth').value, 10) || 4,
        element: element,
        children: []
    };
}

function buildWorldbookDataFromDOM(parentElement = document.getElementById('worldbook-entries-container')) {
    const entries = [];
    const childElements = Array.from(parentElement.children);

    for (const el of childElements) {
        if (el.matches('li.worldbook-entry')) {
            const entryData = parseEntryFromElement(el);
            const childContainer = el.querySelector('.child-entries');
            if (childContainer && childContainer.children.length > 0) {
                entryData.children = buildWorldbookDataFromDOM(childContainer);
            }
            entries.push(entryData);
        }
    }
    return entries;
}

function renderWorldbookFromData(data) {
    const container = document.getElementById('worldbook-entries-container');
    container.innerHTML = ''; 

    function renderLevel(entries, parentElement) {
        entries.forEach(entryData => {
            const entryElement = createWorldbookEntryElement(entryData);
            parentElement.appendChild(entryElement);
            if (entryData.children && entryData.children.length > 0) {
                const childContainer = entryElement.querySelector('.child-entries');
                renderLevel(entryData.children, childContainer);
            }
        });
    }
    
    renderLevel(data, container);
    updateAllEntryAttributes();
}

function countAllEntries(entries) {
    let count = 0;
    if (!entries) return 0;
    
    for (const entry of entries) {
        count++; // Count the entry itself
        if (entry.children && entry.children.length > 0) {
            count += countAllEntries(entry.children); // Add count of children
        }
    }
    return count;
}

function sortDataTree(data) {
    data.sort((a, b) => (a.id || 0) - (b.id || 0));
    data.forEach(entry => {
        if (entry.children && entry.children.length > 0) {
            sortDataTree(entry.children);
        }
    });
}

function sortWorldbookEntries() {
    const worldbookData = buildWorldbookDataFromDOM();
    sortDataTree(worldbookData);
    renderWorldbookFromData(worldbookData);
    alert('æ¡ç›®å·²æŒ‰IDé‡æ–°æ’åˆ—ï¼');
}

function airdropEntry(button) {
    const currentEntryElement = button.closest('.worldbook-entry');
    if (!currentEntryElement) return;

    const idInput = currentEntryElement.querySelector('.wb-sort-id');
    if (!idInput) return;

    const targetId = parseInt(idInput.value, 10);
    if (isNaN(targetId)) {
        alert("è¯·è¾“å…¥ä¸€ä¸ªæœ‰æ•ˆçš„æ•°å­—IDã€‚");
        return;
    }
    const worldbookData = buildWorldbookDataFromDOM();
    let entryToMove = null;
    let parentList = null;

    function findEntryAndParent(data, parent) {
        for (const entry of data) {
            if (entry.element === currentEntryElement) {
                entryToMove = entry;
                parentList = parent;
                return;
            }
            if (entry.children.length > 0) {
                findEntryAndParent(entry.children, entry.children);
            }
        }
    }
    findEntryAndParent(worldbookData, worldbookData);
    if (!entryToMove || !parentList) return;
    parentList.forEach(sibling => {
        if (sibling !== entryToMove && sibling.id >= targetId) {
            sibling.id += 1;
        }
    });
    entryToMove.id = targetId;
    sortDataTree(worldbookData);
    renderWorldbookFromData(worldbookData);
    alert(`æ“ä½œå®Œæˆï¼åˆ—è¡¨å·²æ ¹æ®æ–°IDæ’åˆ—ã€‚`);
}

function createDefaultImage(ratio = '2:3') {
    const canvas = document.createElement('canvas');
    const [width, height] = ratio === '2:3' ? [512, 768] : [768, 512];
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');
    const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
    gradient.addColorStop(0, '#2d2d2d');
    gradient.addColorStop(1, '#1c1c1c');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    return canvas.toDataURL('image/png');
}

function addWorldbookEntry() {
    const worldbookData = buildWorldbookDataFromDOM();
    const newId = (worldbookData.length > 0) ? Math.max(...worldbookData.map(e => e.id)) + 1 : 0;
    worldbookData.push({ id: newId, comment: 'æ–°æ¡ç›®', keys: [], content: '', children: [] });
    renderWorldbookFromData(worldbookData);
}

// æ–°å¢ï¼šè®¾ç½®ä¼˜å…ˆçº§çš„è¾…åŠ©å‡½æ•°
function setPriority(button, value) {
    const priorityInput = button.closest('.field-group').querySelector('.wb-priority');
    if (priorityInput) {
        priorityInput.value = value;
    }
}

function createWorldbookEntryElement(entryData = {}) {
    const entryLi = document.createElement('li');
    entryLi.className = 'worldbook-entry';
    const uniqueId = `wb-entry-${Date.now()}-${Math.random()}`;
    entryLi.dataset.uniqueId = uniqueId;
    
    const defaultEntry = {
        comment: 'æ–°æ¡ç›®', keys: [], secondary_keys: [], content: '',
        secondary_keys_logic: 'any',
        priority: 100, enabled: true, prevent_recursion: false,
        group: '', position: 'before_char', scope: 'chat',
        id: 0,
        constant: false, selective: true, use_regex: false,
        match_whole_words: true, case_sensitive: false, probability: 100,
        wb_depth: 4,
        ...entryData
    };
    
    entryLi.innerHTML = `
        <div class="entry-content-wrapper">
            <div class="entry-header">
                <div class="entry-title-group">
                    <div style="display: flex; align-items: center; gap: 5px;">
                        <input type="number" class="wb-sort-id" title="${t('help-entry-id')}" placeholder="${t('entry-id')}" value="${defaultEntry.id}" style="width: 65px; flex-shrink: 0;">
                        <button title="å°†æ­¤æ¡ç›®æ’å…¥åˆ°å·¦ä¾§æ¡†ä¸­æŒ‡å®šçš„IDä½ç½®ï¼Œå¹¶é¡ºå»¶åç»­æ¡ç›®" onclick="airdropEntry(this)" style="padding: 5px 8px; font-size: 14px; background-color: #6c757d; color: white;">â¡ï¸</button>
                    </div>
                    <input type="text" class="entry-comment" placeholder="${t('entry-comment-placeholder')}" value="${defaultEntry.comment}">
                    <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-id-drop'))">?</span>
                </div>
                <div class="entry-actions">
                    <button title="æ·»åŠ å­æ¡ç›®" onclick="addChildEntry(this)">â•</button>
                    <button title="å°†æ­¤æ¡ç›®ç§»å‡ºçˆ¶æ¡ç›®" onclick="indentEntry(this, -1)">â†“é€€å‡º</button>
                    <button title="å°†æ­¤æ¡ç›®è®¾ä¸ºä¸Šæ–¹åŒçº§æ¡ç›®çš„å­æ¡ç›®" onclick="indentEntry(this, 1)">â†‘åŠ å…¥</button>
                    <button class="delete-entry-btn" onclick="this.closest('.worldbook-entry').remove();">${t('delete')}</button>
                </div>
            </div>
            <div class="entry-grid">
                <div class="field-group full-width">
                    <label>${t('main-keys')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-main-keys'))">?</span></label>
                    <input type="text" class="wb-keys" placeholder="${t('main-keys-placeholder')}" value="${(defaultEntry.keys || []).join(', ')}">
                </div>
                <div class="field-group full-width">
                    <label>${t('injection-content')} <button class="ai-button" onclick="callWorldbookDeepSeek(this)" style="padding: 2px 8px; font-size: 12px; width: auto; margin-left: 10px;">${t('ai-help-write')}</button><button class="ai-undo-button" onclick="undoAiCompletion(this)">${t('undo')}</button></label>
                    <textarea class="wb-content" rows="3" placeholder="${t('injection-content-placeholder')}">${defaultEntry.content}</textarea>
                </div>

                <div class="field-group full-width">
                    <details>
                        <summary id="advanced-settings-summary">${t('advanced-settings')} <span style="font-weight: normal; font-size: 14px; color: #aaa;">(å…³é”®è¯åŒ¹é…ã€æ³¨å…¥é€»è¾‘ç­‰)</span></summary>
                        <div class="advanced-grid">
                            <div class="field-group full-width">
                                <label>å…³é”®å­—è¿‡æ»¤å™¨ 
                                    <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-secondary-keys'))">?</span>
                                </label>
                                <div style="display: flex; gap: 10px; align-items: center;">
                                    <select class="wb-secondary-keys-logic" style="flex: 1; padding: 12px;">
                                        <option value="any" ${defaultEntry.secondary_keys_logic === 'any' ? 'selected' : ''}>ä¸ä»»æ„</option>
                                        <option value="none" ${defaultEntry.secondary_keys_logic === 'none' ? 'selected' : ''}>éä»»æ„</option>
                                        <option value="all" ${defaultEntry.secondary_keys_logic === 'all' ? 'selected' : ''}>ä¸æ‰€æœ‰</option>
                                        <option value="not_all" ${defaultEntry.secondary_keys_logic === 'not_all' ? 'selected' : ''}>éæ‰€æœ‰</option>
                                    </select>
                                    <input type="text" class="wb-secondary-keys" placeholder="${t('secondary-keys-placeholder')}" value="${(defaultEntry.secondary_keys || []).join(', ')}" style="flex: 3;">
                                </div>
                            </div>
                            <div class="field-group">
                                <label>${t('entry-position')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-entry-position'))">?</span></label>
                                <select class="wb-position">
                                    <option value="before_char" ${defaultEntry.position === 'before_char' ? 'selected' : ''}>è§’è‰²å®šä¹‰å‰</option>
                                    <option value="after_char" ${defaultEntry.position === 'after_char' ? 'selected' : ''}>è§’è‰²å®šä¹‰å</option>
                                    <option value="before_prompt" ${defaultEntry.position === 'before_prompt' ? 'selected' : ''}>æœ€å¼€å¤´</option>
                                </select>
                            </div>
                            <div class="field-group">
                                <label>${t('entry-scope')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-entry-scope'))">?</span></label>
                                <select class="wb-scope">
                                    <option value="chat" ${defaultEntry.scope === 'chat' ? 'selected' : ''}>èŠå¤©ä¸­</option>
                                    <option value="summary" ${defaultEntry.scope === 'summary' ? 'selected' : ''}>è®°å¿†æ‘˜è¦ä¸­</option>
                                    <option value="discovery" ${defaultEntry.scope === 'discovery' ? 'selected' : ''}>æ¯æ¬¡è¿›å…¥èŠå¤©æ—¶</option>
                                </select>
                            </div>
                            <div class="field-group" style="display: flex; flex-direction: column; align-items: flex-start;">
                                <label style="margin-bottom: 8px;">${t('entry-priority')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-entry-priority'))">?</span></label>
                                <div style="display: flex; align-items: center; width: 100%;">
                                    <input type="number" class="wb-priority" value="${defaultEntry.priority}" step="100" style="flex-grow: 1;">
                                    <div class="priority-buttons">
                                        <button onclick="setPriority(this, 1000)" title="1000">${t('priority-preset-prereq')}</button>
                                        <button onclick="setPriority(this, 200)" title="200">${t('priority-preset-important')}</button>
                                        <button onclick="setPriority(this, 100)" title="100">${t('priority-preset-normal')}</button>
                                    </div>
                                </div>
                            </div>
                            <div class="field-group"><label>${t('entry-group')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-entry-group'))">?</span></label><input type="text" class="wb-group" value="${defaultEntry.group}" placeholder="${t('entry-group-placeholder')}"></div>
                            <div class="field-group"><label>${t('entry-probability')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-entry-probability'))">?</span></label><input type="number" class="wb-probability" value="${defaultEntry.probability}" min="0" max="100"></div>
                            <div class="field-group"><label>${t('entry-depth')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-entry-depth'))">?</span></label><input type="number" class="wb-depth" value="${defaultEntry.wb_depth}"></div>
                            <div class="field-group logic-group full-width">
                                <label><input type="checkbox" class="wb-enabled" ${defaultEntry.enabled ? 'checked' : ''}>${t('entry-enabled')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-entry-enabled'))">?</span></label>
                                <label><input type="checkbox" class="wb-constant" ${defaultEntry.constant ? 'checked' : ''}>${t('entry-constant')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-entry-constant'))">?</span></label>
                                <label><input type="checkbox" class="wb-selective" ${defaultEntry.selective ? 'checked' : ''}>${t('entry-selective')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-entry-selective'))">?</span></label>
                                <label><input type="checkbox" class="wb-prevent-recursion" ${defaultEntry.prevent_recursion ? 'checked' : ''}>${t('entry-prevent-recursion')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-entry-prevent-recursion'))">?</span></label>
                                <label><input type="checkbox" class="wb-use-regex" ${defaultEntry.use_regex ? 'checked' : ''}>${t('entry-use-regex')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-entry-use-regex'))">?</span></label>
                                <label><input type="checkbox" class="wb-match-whole-words" ${defaultEntry.match_whole_words ? 'checked' : ''}>${t('match-whole-words')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-match-whole-words'))">?</span></label>
                                <label><input type="checkbox" class="wb-case-sensitive" ${defaultEntry.case_sensitive ? 'checked' : ''}>${t('case-sensitive')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-case-sensitive'))">?</span></label>
                            </div>
                        </div>
                    </details>
                </div>
            </div>
        </div>
        <ul class="child-entries"></ul>
    `;
    return entryLi;
}

function addChildEntry(button) {
    const worldbookData = buildWorldbookDataFromDOM();
    const parentEntryElement = button.closest('.worldbook-entry');
    
    function findAndAdd(data) {
        for (const entry of data) {
            if (entry.element === parentEntryElement) {
                const newId = (entry.children.length > 0) ? Math.max(...entry.children.map(e => e.id)) + 1 : 0;
                entry.children.push({ id: newId, comment: 'æ–°å­æ¡ç›®', keys: [], content: '', children: [] });
                return true;
            }
            if (entry.children.length > 0) {
                if(findAndAdd(entry.children)) return true;
            }
        }
        return false;
    }

    findAndAdd(worldbookData);
    renderWorldbookFromData(worldbookData);
}

function indentEntry(button, direction) {
    const worldbookData = buildWorldbookDataFromDOM();
    const currentEntryElement = button.closest('.worldbook-entry');
    if (!currentEntryElement) return;

    const found = findEntryRecursive(worldbookData, currentEntryElement);

    if (!found) {
        console.error(currentLanguage === 'zh' ? "æ— æ³•åœ¨æ•°æ®ç»“æ„ä¸­æ‰¾åˆ°å¯¹åº”çš„æ¡ç›®ã€‚" : "Unable to find corresponding entry in data structure.");
        return;
    }

    const { entry, parentList, index, parentEntry } = found;

    if (direction > 0) { // Indent (â†‘åŠ å…¥): å°†æ¡ç›®è®¾ä¸ºä¸Šæ–¹åŒçº§æ¡ç›®çš„å­æ¡ç›®
        if (index > 0) {
            const newParent = parentList[index - 1];
            parentList.splice(index, 1); // ä»å½“å‰åˆ—è¡¨ä¸­ç§»é™¤
            newParent.children.push(entry); // æ·»åŠ åˆ°æ–°çˆ¶çº§çš„ children æ•°ç»„ä¸­
        } else {
            alert('å·²ç»æ˜¯åŒçº§ä¸­çš„ç¬¬ä¸€ä¸ªæ¡ç›®ï¼Œæ— æ³•åŠ å…¥ï¼ˆç¼©è¿›ï¼‰ã€‚');
            return;
        }
    } else { // Un-indent (â†“é€€å‡º): å°†å­æ¡ç›®ç§»å‡ºï¼Œæˆä¸ºçˆ¶æ¡ç›®çš„åŒçº§
        if (parentEntry) {
            const parentFound = findEntryRecursive(worldbookData, parentEntry.element);
            if (parentFound) {
                const grandParentList = parentFound.parentList;
                const parentIndex = parentFound.index;

                parentList.splice(index, 1); // ä»å½“å‰çˆ¶çº§çš„ children æ•°ç»„ä¸­ç§»é™¤
                grandParentList.splice(parentIndex + 1, 0, entry); // æ·»åŠ åˆ°ç¥–çˆ¶çº§åˆ—è¡¨ï¼Œç´§è·Ÿåœ¨åŸçˆ¶çº§ä¹‹å
            }
        } else {
            alert(t('already-root-entry'));
            return;
        }
    }

    renderWorldbookFromData(worldbookData);
}

function updateAllEntryAttributes() {
    const container = document.getElementById('worldbook-entries-container');
    
    function traverse(element, depth, indexRef) {
        if (element.matches('li.worldbook-entry')) {
            element.dataset.depth = depth;
            element.dataset.displayIndex = indexRef.index++;
            const childContainer = element.querySelector('.child-entries');
            if (childContainer) {
                Array.from(childContainer.children).forEach(child => traverse(child, depth + 1, indexRef));
            }
        } else if (element.children) {
             Array.from(element.children).forEach(child => traverse(child, 0, indexRef));
        }
    }
    
    let indexCounter = { index: 0 };
    traverse(container, -1, indexCounter);
}

// --- PNG EMBEDDING FUNCTIONS ---
async function cleanImageAndGetDataURL(base64Str) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            resolve(canvas.toDataURL('image/png'));
        };
        img.onerror = () => reject(new Error('æ— æ³•åŠ è½½å›¾ç‰‡ï¼Œå¯èƒ½ä¸æ˜¯æœ‰æ•ˆçš„å›¾ç‰‡æ ¼å¼ã€‚'));
        img.src = base64Str;
    });
}

// æ–°å¢ï¼šå°†ä»»ä½•æ ¼å¼çš„å›¾ç‰‡è½¬æ¢ä¸ºPNGæ ¼å¼
async function convertImageToPng(imageDataUrl) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = 'anonymous'; // å…è®¸è·¨åŸŸå›¾ç‰‡
        
        img.onload = () => {
            try {
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                
                // ç»˜åˆ¶å›¾ç‰‡åˆ°canvas
                ctx.drawImage(img, 0, 0);
                
                // è½¬æ¢ä¸ºPNGæ ¼å¼
                const pngDataUrl = canvas.toDataURL('image/png', 0.9);
                resolve(pngDataUrl);
            } catch (error) {
                reject(new Error(`å›¾ç‰‡è½¬æ¢å¤±è´¥: ${error.message}`));
            }
        };
        
        img.onerror = () => {
            reject(new Error('æ— æ³•åŠ è½½å›¾ç‰‡ï¼Œå¯èƒ½ä¸æ˜¯æœ‰æ•ˆçš„å›¾ç‰‡æ ¼å¼ã€‚'));
        };
        
        img.src = imageDataUrl;
    });
}
async function embedDataInPng(imageBase64, textData) {
    const response = await fetch(imageBase64);
    const imageBuffer = await response.arrayBuffer();
    const imageData = new Uint8Array(imageBuffer);
    
    const textEncoder = new TextEncoder();
    const encodedText = textEncoder.encode("chara\x00" + textData);

    const chunk = createTextChunk('tEXt', encodedText);
    
    const iendPosition = findIend(imageData);
    if (iendPosition === -1) throw new Error("Invalid PNG: IEND chunk not found.");
    
    const newPngData = new Uint8Array(imageData.length + chunk.length);
    newPngData.set(imageData.slice(0, iendPosition));
    newPngData.set(chunk, iendPosition);
    newPngData.set(imageData.slice(iendPosition), iendPosition + chunk.length);
    
    return new Blob([newPngData], { type: 'image/png' });
}

function createTextChunk(type, data) {
    const chunkType = new TextEncoder().encode(type);
    const chunkData = data;
    const chunkLength = new Uint8Array(4);
    new DataView(chunkLength.buffer).setUint32(0, chunkData.length);

    const toCrc = new Uint8Array(chunkType.length + chunkData.length);
    toCrc.set(chunkType);
    toCrc.set(chunkData, chunkType.length);
    const crcValue = crc32(toCrc);
    const crc = new Uint8Array(4);
    new DataView(crc.buffer).setUint32(0, crcValue);

    const chunk = new Uint8Array(12 + chunkData.length);
    chunk.set(chunkLength);
    chunk.set(chunkType, 4);
    chunk.set(chunkData, 8);
    chunk.set(crc, 8 + chunkData.length);

    return chunk;
}

function findIend(imageData) {
    const IEND_SIGNATURE = [0x49, 0x45, 0x4E, 0x44];
    for (let i = imageData.length - 12; i >= 8; i--) {
        if (imageData[i+4] === IEND_SIGNATURE[0] && imageData[i+5] === IEND_SIGNATURE[1] && imageData[i+6] === IEND_SIGNATURE[2] && imageData[i+7] === IEND_SIGNATURE[3]) {
           return i;
        }
    }
    return -1;
}

const crc32 = (function() {
    const table = new Uint32Array(256);
    for (let i = 0; i < 256; i++) {
        let c = i;
        for (let j = 0; j < 8; j++) {
            c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
        }
        table[i] = c;
    }
    return function(bytes) {
        let crc = -1;
        for (let i = 0; i < bytes.length; i++) {
            crc = (crc >>> 8) ^ table[(crc ^ bytes[i]) & 0xFF];
        }
        return (crc ^ -1) >>> 0;
    };
})();

async function extractDataFromPng(arrayBuffer) {
    const bytes = new Uint8Array(arrayBuffer);
    const keyword = 'chara';
    
    let i = 8;
    while(i < bytes.length) {
        const view = new DataView(bytes.buffer, i);
        const length = view.getUint32(0);
        const type = new TextDecoder().decode(bytes.slice(i + 4, i + 8));

        if (type === 'tEXt' || type === 'iTXt') {
            const data_start = i + 8;
            let currentKeyword = '';
            let k_end = data_start;
            while(k_end < data_start + length && bytes[k_end] !== 0) {
              currentKeyword += String.fromCharCode(bytes[k_end]);
              k_end++;
            }
            
            if (currentKeyword === keyword) {
                const dataBytes = bytes.slice(k_end + 1, data_start + length);
                const base64String = new TextDecoder("utf-8").decode(dataBytes);
                const jsonString = decodeURIComponent(escape(atob(base64String)));
                return JSON.parse(jsonString);
            }
        }
        i += 12 + length;
    }
    throw new Error('åœ¨PNGä¸­æœªæ‰¾åˆ°è§’è‰²æ•°æ®ã€‚');
}

</script>

</body>
</html>
