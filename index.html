<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>å¦®å¡è§’è‰²å·¥ä½œå®¤Pro</title>
  <script src="https://unpkg.com/pako@2.1.0/dist/pako.min.js"></script>
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-7PYFG35VCZ"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-7PYFG35VCZ');
  </script>
 
  <style>
    /* --- å…¨å±€æ ·å¼ ("æˆ‘ä»¬çš„ä¸»é¢˜") --- */
    :root {
        --primary-color: #e67e22;
        --secondary-color: #d35400;
        --dark-bg: #1c1c1c;
        --light-bg: #2d2d2d;
        --default-card-bg: linear-gradient(135deg, #2d2d2d, #1c1c1c);
        --text-color: #f0f0f0;
        --label-color: #e67e22;
        --input-bg: #333;
        --input-border: #555;
        --card-overlay: linear-gradient(to top, rgba(28, 28, 28, 0.9) 0%, rgba(28, 28, 28, 0.5) 50%, rgba(28, 28, 28, 0.7) 100%);
        --ai-button-bg: #e67e22;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif; }
    body { background: var(--dark-bg); min-height: 100vh; padding: 20px; color: var(--text-color); }
    button { cursor: pointer; font-weight: bold; border: none; transition: all 0.2s ease; }
    p.help-text { font-size: 14px; color: #aaa; margin-top: -10px; margin-bottom: 15px; line-height: 1.6; }

    /* --- è¯­è¨€åˆ‡æ¢æŒ‰é’®æ ·å¼ --- */
    .language-switcher {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-left: 15px;
    }
    .language-switcher button {
        background: transparent;
        color: var(--text-color);
        border: 1px solid rgba(255,255,255,0.2);
        padding: 4px 8px;
        margin: 0 1px;
        border-radius: 12px;
        font-size: 11px;
        font-weight: normal;
        transition: all 0.2s ease;
        min-width: 40px;
    }
    .language-switcher button.active {
        background: transparent;
        border-color: var(--primary-color);
        color: var(--primary-color);
        font-weight: bold;
    }
    .language-switcher button:hover {
        background: rgba(230, 126, 34, 0.05);
        border-color: rgba(230, 126, 34, 0.3);
        transform: scale(1.02);
    }

    /* --- åŠ è½½åŠ¨ç”»æ ·å¼ --- */
    .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(28, 28, 28, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        backdrop-filter: blur(5px);
    }
    
    .loading-spinner {
        width: 50px;
        height: 50px;
        border: 3px solid rgba(230, 126, 34, 0.3);
        border-top: 3px solid var(--primary-color);
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    .loading-text {
        color: var(--text-color);
        margin-top: 15px;
        font-size: 16px;
        text-align: center;
    }

    /* --- è§’è‰²åº“ (Library View) æ ·å¼ --- */
    #library-view .container { width: 100%; max-width: 1200px; margin: 0 auto; }
    #library-view .header { display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center; margin-bottom: 25px; padding-bottom: 15px; border-bottom: 2px solid rgba(255,255,255,0.1); }
    #library-view .header h1 { font-size: 28px; color: white; text-shadow: 0 0 8px var(--primary-color); }
    #library-view .header-buttons { display: flex; gap: 10px; margin-top: 10px; }
    #library-view .header-buttons button { background: var(--primary-color); color: white; padding: 10px 20px; border-radius: 5px; font-size: 16px; }
    #library-view .header-buttons button:hover { background: var(--secondary-color); box-shadow: 0 0 10px var(--secondary-color); transform: translateY(-2px); }
    #library-view #file-importer { display: none; }
    #library-view .tag-filter-area { background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px; margin-bottom: 25px; }
    #library-view .tag-filter-area h3 { margin-bottom: 10px; color: var(--text-color); }
    #library-view .tag-group { display: flex; flex-wrap: wrap; gap: 8px; }
    #library-view .tag { padding: 5px 12px; border-radius: 15px; font-size: 14px; cursor: pointer; color: white; background-color: #555; border: 1px solid #777; }
    #library-view .tag.type-personality { background-color: #7f8c8d; border-color: #95a5a6; }
    #library-view .tag.type-internal { background-color: #d18076; border-color: #bc7168; }
    #library-view .tag.type-special { background-color: var(--secondary-color); border-color: var(--primary-color); }
    #library-view .tag:hover { opacity: 0.8; }
    #library-view .tag.active { box-shadow: 0 0 8px 2px var(--primary-color); transform: scale(1.05); }
    #library-view .character-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 20px; }

    #library-view .character-card {
        aspect-ratio: 2 / 3;
        border-radius: 8px;
        padding: 15px;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        border: 1px solid rgba(255,255,255,0.1);
        transition: transform 0.2s ease, border-color 0.2s ease;
        overflow: hidden;
        position: relative;
        background: var(--default-card-bg);
        background-size: cover;
        background-position: center;
    }
    #library-view .character-card > div:first-of-type {
        flex: 1;
        overflow: hidden;
        min-height: 0;
    }
    #library-view .character-card:hover { transform: translateY(-5px); border-color: var(--primary-color); }
    #library-view .card-header { display: flex; justify-content: space-between; align-items: flex-start; }
    #library-view .card-header h2 { font-size: 20px; color: var(--text-color); margin-bottom: 5px; text-shadow: 0 1px 3px rgba(0,0,0,0.8); }
    #library-view .favorite-btn { background: none; color: #aaa; font-size: 24px; padding: 0; text-shadow: 0 1px 3px rgba(0,0,0,0.8); }
    #library-view .favorite-btn.favorited { color: #f1c40f; }
    #library-view .card-description { font-size: 14px; color: #ccc; margin-bottom: 15px; flex-grow: 1; white-space: pre-wrap; max-height: 100px; overflow: hidden; text-overflow: ellipsis; text-shadow: 0 1px 2px rgba(0,0,0,0.7); }
    #library-view .card-footer { display: flex; gap: 8px; flex-wrap: wrap; }
    #library-view .card-footer button { flex-grow: 1; background: rgba(0,0,0,0.4); backdrop-filter: blur(5px); color: white; border: 1px solid var(--label-color); padding: 8px 10px; border-radius: 5px; }
    #library-view .card-footer button:hover { background-color: var(--primary-color); }

    /* --- ç·¨è¼¯å™¨ (Editor View) æ¨£å¼ --- */
    #editor-view { display: none; justify-content: center; align-items: flex-start; width: 100%; padding-top: 2vh; }
    #editor-view .editor-container { width: 100%; max-width: 900px; background: var(--light-bg); border-radius: 10px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); overflow: hidden; display: flex; flex-direction: column; max-height: 93vh; color: var(--text-color); }
    #editor-view .editor-header { background: var(--primary-color); padding: 15px 20px; color: white; display: flex; align-items: center; justify-content: space-between; }
    #editor-view .editor-header h1 { font-size: 22px; text-shadow: 1px 1px 2px rgba(0,0,0,0.3); }
    #editor-view .editor-body { flex: 1; overflow-y: auto; /* ä¸»æ»šåŠ¨åŒº */ }
    #editor-view .panel-content { padding: 20px; }
    #editor-view .section-title { font-size: 1.2em; font-weight: bold; color: var(--primary-color); margin-top: 25px; margin-bottom: 15px; padding-bottom: 8px; border-bottom: 2px solid var(--primary-color); }
    #editor-view .field-group { margin-bottom: 15px; position: relative; }
    #editor-view .field-group label { display: flex; align-items: center; font-weight: bold; margin-bottom: 8px; color: var(--text-color); cursor: default; }
    #editor-view .field-group input, #editor-view .field-group textarea, #editor-view .field-group select { width: 100%; padding: 12px; border: 1px solid var(--input-border); border-radius: 5px; background: var(--input-bg); font-size: 15px; color: var(--text-color); }
    #editor-view .field-group .inline-group { display: flex; gap: 15px; align-items: flex-end; }
    #editor-view .field-group textarea { resize: vertical; min-height: 80px; }
    .ai-button { background: var(--ai-button-bg); color: #fff; border: 1px solid var(--secondary-color); border-radius: 5px; padding: 5px 10px; font-size: 12px; width: 100px; margin-top: 5px; }
    .ai-button:hover { background: var(--secondary-color); }
    /* æ–°å¢: æ’¤é”€æŒ‰é’®æ ·å¼ */
    .ai-undo-button {
      background: #6c757d; color: #fff; border-radius: 5px;
      padding: 5px 10px; font-size: 12px; margin-top: 5px;
      margin-left: 5px; display: none; /* é»˜è®¤éšè— */
    }
    .ai-undo-button:hover { background: #5a6268; }
    /* åå­—ç”Ÿæˆå™¨æŒ‰é’® */
    .name-generator-btn {
        background: none;
        border: none;
        font-size: 22px;
        padding: 0 8px;
        margin-bottom: 5px;
        color: var(--primary-color);
    }
    .name-generator-btn:hover {
        transform: scale(1.1);
        text-shadow: 0 0 5px var(--primary-color);
    }


    #editor-view #avatar-preview { max-width: 250px; border-radius: 8px; border: 2px dashed var(--input-border); object-fit: cover; aspect-ratio: 2/3; margin-bottom: 10px; }
    #editor-view .action-buttons { display: flex; gap: 10px; margin-top: 20px; }
    #editor-view .action-buttons.row { flex-direction: row; align-items: center; } /* ç¡®ä¿å‚ç›´å±…ä¸­ */
    #editor-view .action-buttons button { width: 100%; padding: 12px; border-radius: 5px; background: var(--primary-color); color: white; font-size: 16px;}
    #editor-view .action-buttons button.secondary { background: #6c757d; }
    #editor-view .action-buttons button:hover { transform: translateY(-1px); box-shadow: 0 4px 8px rgba(0,0,0,0.2); opacity: 0.9; }

    /* --- è§’è‰²ä¹¦ (Character Book) ä¸“ä¸šæ ·å¼ --- */
    .worldbook-list, .child-entries {
        list-style-type: none;
        padding-left: 25px; /* æ§åˆ¶ç¼©è¿›é‡ */
        border-left: 2px dotted #444;
    }
    .worldbook-list {
        padding-left: 0;
        border-left: none;
    }
    .worldbook-entry {
        background: rgba(0,0,0,0.15);
        border: 1px solid var(--input-border);
        border-radius: 8px;
        margin-top: 10px;
        transition: background-color 0.3s;
        border-left: 3px solid transparent;
    }
    .worldbook-entry:hover {
       border-left-color: var(--primary-color);
    }
    .entry-content-wrapper { padding: 15px; }
    .entry-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; gap: 10px; }
    .entry-title-group { display: flex; align-items: center; gap: 10px; flex-grow: 1; }
    .wb-sort-id { width: 60px !important; text-align: center; } /* Adjusted from full width */
    .entry-comment {
        font-size: 1.1em;
        font-weight: bold;
        color: var(--text-color);
        border: none;
        background: transparent;
        border-bottom: 2px solid var(--input-border);
        padding: 5px;
        flex-grow: 1;
    }
    .entry-comment:focus { outline: none; border-bottom-color: var(--primary-color); }
    .entry-actions { display: flex; gap: 5px; flex-shrink: 0; align-items: center;}
    .entry-actions button { background: #555; color: white; padding: 5px 8px; border-radius: 5px; font-size: 14px; }
    .entry-actions button.delete-entry-btn { background: #dc3545; }

    .entry-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
    .full-width { grid-column: 1 / -1; }
    
    /* --- FIX: é€»è¾‘ç»„ (Logic Group) æ ·å¼é‡æ„ --- */
    .logic-group {
        display: flex;
        flex-wrap: wrap;
        gap: 10px; /* æŒ‰é’®ä¹‹é—´çš„é—´è· */
        background: rgba(0,0,0,0.2);
        padding: 10px;
        border-radius: 5px;
    }
    .logic-group label {
        display: inline-flex; /* å…³é”®ä¿®å¤ï¼šä½¿å…¶è¡¨ç°ä¸ºè¡Œå†…å¼¹æ€§å®¹å™¨ï¼Œä¿è¯å†…éƒ¨å…ƒç´ ä¸åˆ†ç¦» */
        align-items: center;
        background-color: #4a4a4a; /* æŒ‰é’®èƒŒæ™¯è‰² */
        padding: 6px 12px; /* å†…è¾¹è· */
        border-radius: 15px; /* èƒ¶å›Šå½¢çŠ¶ */
        border: 1px solid #666;
        cursor: pointer;
        font-weight: normal;
        margin-bottom: 0;
        transition: all 0.2s ease;
        white-space: nowrap; /* å¼ºåˆ¶æŒ‰é’®å†…çš„æ–‡æœ¬ä¸æ¢è¡Œ */
    }
    .logic-group label:hover {
        background-color: #5a5a5a;
        border-color: #888;
    }
    .logic-group input[type="checkbox"] {
        width: auto;
        margin-right: 8px; /* å¤é€‰æ¡†å’Œæ–‡å­—çš„é—´è· */
        transform: scale(1.2); /* æ”¾å¤§å¤é€‰æ¡†ï¼Œæ–¹ä¾¿ç‚¹å‡» */
    }
    
    /* --- å¸®åŠ©å›¾æ ‡æ ·å¼ --- */
    .help-icon {
        display: inline-block;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background-color: #6c757d;
        color: white;
        text-align: center;
        font-size: 12px;
        font-weight: bold;
        line-height: 18px;
        cursor: help;
        margin-left: 5px;
        user-select: none; /* é˜²æ­¢æ–‡æœ¬è¢«é€‰ä¸­ */
        flex-shrink: 0; /* é˜²æ­¢å›¾æ ‡è¢«å‹ç¼© */
        transition: background-color 0.2s ease, transform 0.2s ease;
    }
    .help-icon:hover {
        background-color: var(--primary-color);
        transform: scale(1.1);
    }

    /* --- è§’è‰²ä¹¦é«˜çº§è®¾ç½®æ ·å¼ --- */
    .worldbook-entry details {
        border: 1px solid #444;
        border-radius: 5px;
        padding: 10px;
        margin-top: 15px;
        background: rgba(0,0,0,0.1);
    }
    .worldbook-entry summary {
        font-weight: bold;
        color: var(--primary-color);
        cursor: pointer;
        outline: none;
        padding-bottom: 10px;
    }
    .worldbook-entry details[open] summary {
        border-bottom: 1px solid #555;
    }
    .worldbook-entry details .advanced-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 15px;
        padding-top: 10px;
    }
    .worldbook-entry details .logic-group {
        gap: 10px 20px; /* row-gap column-gap */
    }
    /* ä¼˜å…ˆçº§å¿«é€Ÿè®¾ç½®æŒ‰é’® */
    .priority-buttons {
        display: flex;
        gap: 5px;
        margin-left: 8px;
    }
    .priority-buttons button {
        padding: 2px 8px;
        font-size: 11px;
        border-radius: 4px;
        background-color: #555;
        color: #fff;
    }
    .priority-buttons button:hover {
        background-color: var(--primary-color);
    }

    /* --- Post History Template Buttons --- */
    .template-buttons {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 8px;
        margin-bottom: 15px;
    }
    .template-buttons button {
        background: #555;
        color: white;
        padding: 5px 12px;
        border-radius: 5px;
        font-size: 13px;
        border: 1px solid #777;
    }
    .template-buttons button:hover {
        background-color: var(--primary-color);
        border-color: var(--secondary-color);
    }
    
    /* --- Lover å¼€å…³æ ·å¼ --- */
    .lover-switch-container {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-right: 15px; /* ä¸å³ä¾§æŒ‰é’®çš„é—´è· */
    }
    .lover-switch-container .switch-label {
      font-size: 14px;
      font-weight: bold;
      color: var(--text-color);
    }
    .switch {
      position: relative;
      display: inline-block;
      width: 74px;
      height: 28px;
    }
    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #555;
      transition: .4s;
      border-radius: 28px;
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 20px;
      width: 20px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    input:checked + .slider {
      background-color: #e67e22; 
    }
    input:checked + .slider:before {
      transform: translateX(22px);
    }
    
    /* --- åå­—é€‰æ‹© Modal æ ·å¼ --- */
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: none; /* é»˜è®¤éšè— */
        justify-content: center;
        align-items: center;
        z-index: 10000;
        backdrop-filter: blur(5px);
    }
    .modal-content {
        background: var(--light-bg);
        padding: 25px;
        border-radius: 10px;
        width: 90%;
        max-width: 400px;
        text-align: center;
        box-shadow: 0 5px 25px rgba(0,0,0,0.5);
    }
    .modal-content h3 {
        color: var(--primary-color);
        margin-bottom: 20px;
    }
    .modal-content .name-options {
        display: flex;
        flex-direction: column;
        gap: 10px;
        margin-bottom: 20px;
    }
    .modal-content .name-options button {
        padding: 12px;
        border-radius: 5px;
        background: var(--input-bg);
        color: var(--text-color);
        border: 1px solid var(--input-border);
    }
    .modal-content .name-options button:hover {
        background: var(--primary-color);
        color: #fff;
    }
    .modal-content .modal-actions button {
        padding: 10px 20px;
        border-radius: 5px;
        margin: 0 5px;
    }
    .modal-content .modal-actions .regenerate-btn {
        background: var(--primary-color);
        color: #fff;
    }
    .modal-content .modal-actions .cancel-btn {
        background: #6c757d;
        color: #fff;
    }


    /* --- å“åº”å¼å¸ƒå±€ --- */
    @media (max-width: 800px) {
        body { padding: 10px; }
        #library-view .header { justify-content: center; text-align: center; }
        #library-view .header-buttons { justify-content: center; width: 100%; }
        #library-view .character-grid { grid-template-columns: 1fr; gap: 10px; }
        #editor-view { padding-top: 0; }
        #editor-view .editor-container { max-height: 100vh; height: 100%; border-radius: 0; }
        #editor-view .panel-content { padding: 15px; }
        #editor-view .editor-header h1 { font-size: 18px; }
        .entry-grid { grid-template-columns: 1fr; }
        .entry-header { flex-wrap: wrap; gap: 10px; /* Mobile Fix: Add gap for wrapped items */ }
        .worldbook-entry details .advanced-grid {
            grid-template-columns: 1fr; /* Mobile Fix: Force single column for advanced settings */
        }
    }
  </style>
</head>
<body>

  <div id="loading-overlay" class="loading-overlay">
    <div style="display: flex; flex-direction: column; align-items: center;">
      <div class="loading-spinner"></div>
      <div class="loading-text" id="loading-text">æ­£åœ¨åŠ è½½...</div>
    </div>
  </div>

  <div id="name-generator-modal" class="modal-overlay">
      <div class="modal-content">
          <h3 id="name-modal-title">ä¸ºä½ çš„è§’è‰²é€‰æ‹©ä¸€ä¸ªåå­—</h3>
          <div id="name-options-container" class="name-options">
              </div>
          <div class="modal-actions">
              <button id="regenerate-names-btn" class="regenerate-btn">é‡æ–°ç”Ÿæˆ</button>
              <button id="cancel-name-generation-btn" class="cancel-btn">å–æ¶ˆ</button>
          </div>
      </div>
  </div>

  <div id="library-view">
    <div class="container">
      <div class="header">
        <div style="display: flex; align-items: center; gap: 15px;">
          <h1>å¦®å¡è§’è‰²å·¥ä½œå®¤Pro</h1>
          <div class="language-switcher">
            <button onclick="switchLanguage('zh')" id="lang-zh" class="active">ä¸­æ–‡</button>
            <button onclick="switchLanguage('en')" id="lang-en">English</button>
          </div>
        </div>
        <div class="header-buttons">
          <button onclick="showEditorView()">+ åˆ›å»ºæ–°è§’è‰²</button>
          <button onclick="document.getElementById('file-importer').click()">ğŸ“¥ å¯¼å…¥è§’è‰²å¡</button>
          <input type="file" id="file-importer" accept=".json,.png" onchange="importCharacter(event)" multiple />
        </div>
      </div>
      <div class="tag-filter-area">
        <h3>æ ‡ç­¾è¿‡æ»¤</h3>
        <div id="tag-container" class="tag-group"></div>
      </div>
      <div id="character-grid" class="character-grid"></div>
    </div>
  </div>

  <div id="editor-view">
    <div class="editor-container">
      <div class="editor-header">
        <h1 id="editor-title">åˆ›å»ºæ–°è§’è‰²</h1>
        <input id="apiKey" placeholder="è¾“å…¥ DeepSeek API Key" style="padding:6px 12px;border-radius:5px;border:1px solid #ccc;width:280px;background:#fff;color:#333;" oninput="localStorage.setItem('deepseekApiKey', this.value)" />
      </div>
      <div class="editor-body">
        <div class="panel-content">
          <input type="hidden" id="charId" />
          <input type="hidden" id="internalTags" />
          <input type="hidden" id="isFavorite" />
          <input type="hidden" id="originalCardData" />

          <h3 class="section-title" id="avatar-operation-title">è§’è‰²å¤´åƒä¸æ“ä½œ</h3>
           <div class="field-group">
                <label for="avatar-input-label" id="avatar-input-label" title="">è§’è‰²å¤´åƒ</label>
                <img id="avatar-preview" src="" alt="å¤´åƒé¢„è§ˆ"/>
                <input type="file" id="avatar-input" accept="image/*" style="display:none;">
                <button onclick="document.getElementById('avatar-input').click()" style="max-width: 250px;">ä¸Šä¼ å›¾ç‰‡</button>
            </div>
            <div class="action-buttons" style="flex-direction: column;">
                <button onclick="saveCharacter()">ğŸ’¾ å‚¨å­˜å¹¶è¿”å›è§’è‰²åº“</button>
                <button onclick="downloadCharacter()">ğŸ“¥ ä¸‹è½½ JSON</button>
                <button onclick="downloadCharacterAsPng()">ğŸ“¥ ä¸‹è½½ PNG è§’è‰²å¡</button>
                <button class="secondary" onclick="showLibraryView()">ğŸ”™ è¿”å› (ä¸å‚¨å­˜)</button>
            </div>

          <h3 class="section-title" id="world-topic-title">ä¸–ç•Œè¯é¢˜</h3>
          <div class="field-group">
            <label for="topic">ä¸»é¢˜</label>
            <input id="topic" placeholder="ä¾‹ï¼šèµ›åšæœ‹å…‹, å¥‡å¹», æ ¡å›­" />
          </div>
          
          <h3 class="section-title" id="character-core-title">è§’è‰²æ ¸å¿ƒ</h3>
          <div class="field-group">
              <div class="inline-group">
                  <div style="flex:3">
                      <label for="name">åå­—</label>
                      <div style="display: flex; align-items: center; gap: 5px;">
                          <input id="name" placeholder="ä¾‹ï¼šMonika" style="flex-grow: 1;" />
                          <button class="name-generator-btn" onclick="generateAiNames(this)" title="AI ç”Ÿæˆå¤šä¸ªåå­—ä¾›é€‰æ‹©">ğŸ”®</button>
                      </div>
                  </div>
                  <div style="flex:1"><label for="gender">æ€§åˆ«</label><input id="gender" placeholder="ä¾‹ï¼šå¥³" /></div>
              </div>
          </div>
          
          <h3 class="section-title" id="character-details-title">è§’è‰²ç»†èŠ‚</h3>
          <div class="field-group">
            <label for="description">ç®€ä»‹</label>
            <textarea id="description" rows="5" placeholder="è§’è‰²çš„èº«ä»½ã€å¤–è²Œã€èƒŒæ™¯æ•…äº‹ç­‰ã€‚ä¼šæ˜¾ç¤ºåœ¨è§’è‰²å¡ä¸Šã€‚"></textarea>
            <button class="ai-button" onclick="callDeepSeek('description')">ğŸ”® AI å¸®æˆ‘å†™</button>
            <button class="ai-undo-button" onclick="undoAiCompletion(this)">â†©ï¸ æ’¤é”€</button>
          </div>
          <div class="field-group">
            <label for="tags">åˆ†ç±»æ ‡ç­¾(é€—å·åˆ†éš”)</label>
            <textarea id="tags" rows="2" placeholder="ä¸ºè§’è‰²æ·»åŠ æ ‡ç­¾ï¼Œæ–¹ä¾¿æŸ¥æ‰¾ã€‚ä¾‹ï¼šåŸåˆ›, æ¸¸æˆ, OOC "></textarea>
            <button class="ai-button" onclick="callDeepSeek('tags')">ğŸ”® AI å¸®æˆ‘å†™</button>
            <button class="ai-undo-button" onclick="undoAiCompletion(this)">â†©ï¸ æ’¤é”€</button>
          </div>
          <div class="field-group">
            <label for="personality">ä¸ªæ€§</label>
            <textarea id="personality" rows="2" placeholder="è¯¦ç»†æ€§æ ¼ç‰¹è´¨ã€‚ä¾‹ï¼šå–„äºè¨€è¾, æ€æƒ³æˆç†Ÿ, ç—…å¨‡ (é€—å·åˆ†éš”)"></textarea>
            <button class="ai-button" onclick="callDeepSeek('personality')">ğŸ”® AI å¸®æˆ‘å†™</button>
            <button class="ai-undo-button" onclick="undoAiCompletion(this)">â†©ï¸ æ’¤é”€</button>
          </div>

          <h3 class="section-title" id="settings-title">è®¾å®š</h3>
           <div class="field-group">
            <label for="system_prompt">äººæ ¼è®¾å®š</label>
            <textarea id="system_prompt" rows="3" placeholder="AIå¿…é¡»éµå®ˆçš„æ ¸å¿ƒè®¾å®šã€‚ä¾‹ï¼šä½ æ˜¯[åå­—]ï¼Œä¸€ä¸ª[èº«ä»½]ã€‚ä½ å¿…é¡»ç§°å‘¼ç”¨æˆ·ä¸ºâ€œäº²çˆ±çš„â€ã€‚"></textarea>
             <button class="ai-button" onclick="callDeepSeek('system_prompt')">ğŸ”® AI å¸®æˆ‘å†™</button>
             <button class="ai-undo-button" onclick="undoAiCompletion(this)">â†©ï¸ æ’¤é”€</button>
          </div>
          <div class="field-group">
            <label for="scenario">åœºæ™¯è®¾å®š</label>
            <textarea id="scenario" rows="3" placeholder="è§’è‰²ä¸ç”¨æˆ·æ‰€å¤„çš„ç¯å¢ƒã€‚ä¾‹ï¼š{{char}}å’Œ{{user}}åœ¨é»„æ˜çš„æ•™å®¤é‡Œã€‚"></textarea>
             <button class="ai-button" onclick="callDeepSeek('scenario')">ğŸ”® AI å¸®æˆ‘å†™</button>
             <button class="ai-undo-button" onclick="undoAiCompletion(this)">â†©ï¸ æ’¤é”€</button>
          </div>
          <div class="field-group">
            <label for="first_mes">é—®å€™æ¶ˆæ¯</label>
            <textarea id="first_mes" rows="3" placeholder="è§’è‰²å‡ºåœºæ—¶è¯´çš„ç¬¬ä¸€å¥è¯ã€‚"></textarea>
            <button class="ai-button" onclick="callDeepSeek('first_mes')">ğŸ”® AI å¸®æˆ‘å†™</button>
            <button class="ai-undo-button" onclick="undoAiCompletion(this)">â†©ï¸ æ’¤é”€</button>
          </div>
          <div class="field-group">
            <label for="mes_example">ç¤ºä¾‹æ¶ˆæ¯</label>
            <textarea id="mes_example" rows="6" placeholder="æä¾›å‡ æ®µå¯¹è¯èŒƒä¾‹ï¼ŒAIä¼šæ¨¡ä»¿å…¶é£æ ¼ã€‚æä¸ºé‡è¦ï¼"></textarea>
            <button class="ai-button" onclick="callDeepSeek('mes_example')">ğŸ”® AI å¸®æˆ‘å†™</button>
            <button class="ai-undo-button" onclick="undoAiCompletion(this)">â†©ï¸ æ’¤é”€</button>
          </div>

          <h3 class="section-title" id="advanced-settings-title">é«˜çº§è®¾å®š</h3>
           <div class="field-group">
            <label for="post_history_instructions">åæœŸæŒ‡ä»¤</label>
            <textarea id="post_history_instructions" rows="3" placeholder="ä¸€äº›å¹³å°ç”¨å®ƒæ¥ä¿®æ”¹AIçš„å›å¤æ ¼å¼ã€‚ä¾‹å¦‚ï¼Œè¦è®©{{char}}çš„åŠ¨ä½œéƒ½ç”¨æ˜Ÿå·åŒ…å›´ï¼Œå¯ä»¥å†™ï¼šå°†{{char}}çš„æ‰€æœ‰åŠ¨ä½œå’Œå™è¿°éƒ½æ”¾åœ¨æ˜Ÿå·ï¼ˆ*ï¼‰ä¹‹é—´ã€‚"></textarea>
            <div class="template-buttons" id="post-history-templates">
              <button id="btn-template-options" onclick="setPostHistoryTemplate('template-options-mode')"></button>
              <button id="btn-template-parentheses" onclick="setPostHistoryTemplate('template-parentheses-mode')"></button>
              <button id="btn-template-status-bar" onclick="setPostHistoryTemplate('template-status-bar')"></button>
              <button id="btn-template-third-person" onclick="setPostHistoryTemplate('template-third-person')"></button>
              <button id="btn-template-json-mode" onclick="setPostHistoryTemplate('template-json-mode')"></button>
              <button id="btn-template-image-prompt" onclick="setPostHistoryTemplate('template-image-prompt')"></button>
            </div>
          </div>

          <div style="display: flex; justify-content: space-between; align-items: center;">
             <h3 class="section-title" id="world-knowledge-book-title">ä¸–ç•Œ/çŸ¥è¯†ä¹¦</h3>
             <button onclick="generateFullWorldbook(this)" style="background-color: var(--ai-button-bg); color: white; padding: 8px 15px; border-radius: 5px;">ğŸ”® AIç”Ÿæˆå‚è€ƒæ¡ç›®</button>
          </div>
          <p class="help-text" id="worldbook-help-text">
              </p>
          <ul id="worldbook-entries-container" class="worldbook-list"></ul>
          <div class="action-buttons row" style="margin-top: 15px;">
            <div class="lover-switch-container">
                <span class="switch-label" id="companion-mode-label">ä¼´ä¾£æ¨¡å¼</span>
                <label class="switch">
                    <input type="checkbox" id="lover-switch">
                    <span class="slider"></span>
                </label>
            </div>
            <button onclick="addWorldbookEntry()" class="secondary" style="background-color: #e67e22; flex-grow: 1;">+ æ·»åŠ æ–°æ¡ç›®</button>
            <button onclick="sortWorldbookEntries()" class="secondary" style="flex-grow: 1;">ğŸ”„ æŒ‰IDå¤§å°æ’åº</button>
          </div>

        </div>
      </div>
    </div>
  </div>

<script>
// --- å›½é™…åŒ–æ”¯æŒ ---
let currentLanguage = localStorage.getItem('language') || 'zh';

const translations = {
    zh: {
        // æ ‡é¢˜å’ŒæŒ‰é’®
        'app-title': 'å¦®å¡è§’è‰²å·¥ä½œå®¤Pro',
        'create-new-character': 'åˆ›å»ºæ–°è§’è‰²',
        'import-character': 'ğŸ“¥ å¯¼å…¥è§’è‰²å¡',
        'edit-character': 'ç¼–è¾‘è§’è‰²',
        'save-and-return': 'ğŸ’¾ å‚¨å­˜å¹¶è¿”å›è§’è‰²åº“',
        'return-without-save': 'ğŸ”™ è¿”å› (ä¸å‚¨å­˜)',
        'download-json': 'ğŸ“¥ ä¸‹è½½ JSON',
        'download-png': 'ğŸ“¥ ä¸‹è½½ PNG è§’è‰²å¡',
        'upload-image': 'ä¸Šä¼ å›¾ç‰‡',
        'edit': 'ç¼–è¾‘',
        'add-tag': 'æ·»åŠ æ ‡ç­¾',
        'delete': 'åˆ é™¤',
        'add-new-entry': '+ æ·»åŠ æ–°æ¡ç›®',
        'sort-by-id': 'ğŸ”„ æŒ‰IDå¤§å°æ’åº',
        'ai-generate-entries': 'ğŸ”® AIç”Ÿæˆå‚è€ƒæ¡ç›®',
        'ai-help-write': 'ğŸ”® AI å¸®æˆ‘å†™',
        'undo': 'â†©ï¸ æ’¤é”€',
        'generate-companion': 'ğŸ”® ç”Ÿæˆè™šæ‹Ÿä¼´ä¾£',
        
        // æ ‡ç­¾è¿‡æ»¤
        'tag-filter': 'æ ‡ç­¾è¿‡æ»¤',
        'no-characters-found': 'æ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„è§’è‰²ã€‚å°è¯•æ¸…é™¤è¿‡æ»¤å™¨æˆ–å¯¼å…¥æ–°çš„è§’è‰²å¡ã€‚',
        
        // è¡¨å•æ ‡ç­¾
        'avatar-label': 'è§’è‰²å¤´åƒ',
        'avatar-upload': 'ä¸Šä¼ å›¾ç‰‡',
        'world-topic': 'ä¸–ç•Œè¯é¢˜',
        'topic': 'ä¸»é¢˜',
        'topic-placeholder': 'ä¾‹ï¼šèµ›åšæœ‹å…‹, å¥‡å¹», æ ¡å›­',
        'character-core': 'è§’è‰²æ ¸å¿ƒ',
        'name': 'åå­—',
        'name-placeholder': 'ä¾‹ï¼šMonika',
        'gender': 'æ€§åˆ«',
        'gender-placeholder': 'ä¾‹ï¼šå¥³',
        'character-details': 'è§’è‰²ç»†èŠ‚',
        'description': 'ç®€ä»‹',
        'description-placeholder': 'è§’è‰²çš„èº«ä»½ã€å¤–è²Œã€èƒŒæ™¯æ•…äº‹ç­‰ã€‚ä¼šæ˜¾ç¤ºåœ¨è§’è‰²å¡ä¸Šã€‚',
        'tags': 'åˆ†ç±»æ ‡ç­¾',
        'tags-placeholder': 'ä¸ºè§’è‰²æ·»åŠ æ ‡ç­¾ï¼Œæ–¹ä¾¿æŸ¥æ‰¾ã€‚ä¾‹ï¼šåŸåˆ›, æ¸¸æˆ, OOC',
        'personality': 'ä¸ªæ€§',
        'personality-placeholder': 'è¯¦ç»†æ€§æ ¼ç‰¹è´¨ã€‚ä¾‹ï¼šå–„äºè¨€è¾, æ€æƒ³æˆç†Ÿ, ç—…å¨‡ (é€—å·åˆ†éš”)',
        'settings': 'è®¾å®š',
        'system-prompt': 'äººæ ¼è®¾å®š',
        'system-prompt-placeholder': 'AIå¿…é¡»éµå®ˆçš„æ ¸å¿ƒè®¾å®šã€‚ä¾‹ï¼šä½ æ˜¯[åå­—]ï¼Œä¸€ä¸ª[èº«ä»½]ã€‚ä½ å¿…é¡»ç§°å‘¼ç”¨æˆ·ä¸ºâ€œäº²çˆ±çš„â€ã€‚',
        'scenario': 'åœºæ™¯è®¾å®š',
        'scenario-placeholder': 'è§’è‰²ä¸ç”¨æˆ·æ‰€å¤„çš„ç¯å¢ƒã€‚ä¾‹ï¼š{{char}}å’Œ{{user}}åœ¨é»„æ˜çš„æ•™å®¤é‡Œã€‚',
        'first-message': 'é—®å€™æ¶ˆæ¯',
        'first-message-placeholder': 'è§’è‰²å‡ºåœºæ—¶è¯´çš„ç¬¬ä¸€å¥è¯ã€‚',
        'message-example': 'ç¤ºä¾‹æ¶ˆæ¯',
        'message-example-placeholder': 'æä¾›å‡ æ®µå¯¹è¯èŒƒä¾‹ï¼ŒAIä¼šæ¨¡ä»¿å…¶é£æ ¼ã€‚æä¸ºé‡è¦ï¼',
        'advanced-settings': 'é«˜çº§è®¾å®š',
        'post-history-instructions': 'åæœŸæŒ‡ä»¤',
        'post-history-instructions-placeholder': 'ä¸€äº›å¹³å°ç”¨å®ƒæ¥ä¿®æ”¹AIçš„å›å¤æ ¼å¼ã€‚ä¾‹å¦‚ï¼Œè¦è®©{{char}}çš„åŠ¨ä½œéƒ½ç”¨æ˜Ÿå·åŒ…å›´ï¼Œå¯ä»¥å†™ï¼šå°†{{char}}çš„æ‰€æœ‰åŠ¨ä½œå’Œå™è¿°éƒ½æ”¾åœ¨æ˜Ÿå·ï¼ˆ*ï¼‰ä¹‹é—´ã€‚',
        'world-knowledge-book': 'ä¸–ç•Œ/çŸ¥è¯†ä¹¦',
        'companion-mode': 'ä¼´ä¾£æ¨¡å¼',
        
        // ä¸–ç•Œä¹¦ç›¸å…³
        'worldbook-help': 'â€œä¸–ç•Œä¹¦â€æ˜¯ç»™AIçš„ä¸€éƒ¨<b>å‚è€ƒå­—å…¸</b>ã€‚å¦‚æœä½ åªæ“ä¸–ç•Œä¹¦ï¼Œä¸Šé¢çš„ä¿¡æ¯åªç”¨å¡«åå­—',
        'entry-comment': 'æ¡ç›®æ³¨é‡Š',
        'entry-comment-placeholder': 'æ¡ç›®æ³¨é‡Š',
        'main-keys': 'è¯ ',
        'main-keys-placeholder': 'ä¾‹å¦‚: èª“çº¦èƒœåˆ©ä¹‹å‰‘, Excalibur',
        'secondary-keys': 'æ¬¡è¦å…³é”®è¯',
        'secondary-keys-placeholder': 'ä¾‹å¦‚: å‰‘, æ­¦å™¨',
        'injection-content': 'å†…å®¹',
        'injection-content-placeholder': 'å½“å…³é”®è¯è¢«è§¦å‘æ—¶ï¼Œè¿™æ®µå†…å®¹ä¼šè¢«å‘é€ç»™AIã€‚',
        'entry-id': 'æ¡ç›®ID',
        'entry-id-placeholder': 'æ•°å­—ï¼Œå†³å®šæ¡ç›®è¢«å‘é€çš„é¡ºåº',
        'entry-priority': 'ä¼˜å…ˆçº§',
        'entry-priority-placeholder': 'æ•°å­—ï¼Œå†³å®šæ¡ç›®è¢«å‘é€çš„é¡ºåº',
        'entry-position': 'æ³¨å…¥ä½ç½®',
        'entry-scope': 'ä½œç”¨åŸŸ',
        'priority-preset-prereq': 'å‰æ',
        'priority-preset-important': 'é‡è¦',
        'priority-preset-normal': 'æ™®é€š',
        'entry-enabled': 'å¯ç”¨',
        'entry-constant': 'æ’å®šæ³¨å…¥',
        'entry-selective': 'é€‰æ‹©æ€§æ³¨å…¥',
        'entry-use-regex': 'æ­£åˆ™åŒ¹é…',
        'entry-prevent-recursion': 'é˜»æ­¢é€’å½’',
        'entry-group': 'åˆ†ç»„',
        'entry-group-placeholder': 'åˆ†ç»„åç§°',
        'entry-probability': 'è§¦å‘æ¦‚ç‡ (%)',
        'entry-probability-placeholder': '0-100',
        'entry-depth': 'è®°å¿†æ‰«ææ·±åº¦',
        'entry-depth-placeholder': 'æ•°å­—',
        'match-whole-words': 'å…¨è¯åŒ¹é…',
        'case-sensitive': 'åŒºåˆ†å¤§å°å†™',
        
        // é”™è¯¯å’Œæç¤ºä¿¡æ¯
        'db-timeout': 'æ•°æ®åº“è¿æ¥è¶…æ—¶ã€‚è¯·å°è¯•å…³é—­æ‰€æœ‰å…¶ä»–æ ‡ç­¾é¡µï¼Œå¹¶å¼ºåˆ¶åˆ·æ–°(Ctrl+F5)ã€‚å¦‚æœé—®é¢˜ä»ç„¶å­˜åœ¨ï¼Œè¯·å°è¯•æ¸…é™¤ç½‘ç«™æ•°æ®ã€‚',
        'db-error': 'é”™è¯¯ï¼šæ— æ³•è¿æ¥åˆ°æœ¬åœ°æ•°æ®åº“ã€‚\n\nè¯¦ç»†ä¿¡æ¯: {error}\n\næ‚¨çš„è§’è‰²å°†æ— æ³•ä¿å­˜æˆ–è¯»å–ã€‚è¯·æ£€æŸ¥æµè§ˆå™¨è®¾ç½®(å¦‚éšç§ä¿æŠ¤ã€ç¦æ­¢Cookieç­‰)æˆ–å°è¯•æ¸…é™¤ç½‘ç«™æ•°æ®ã€‚',
        'db-blocked': 'æ•°æ®åº“è¿æ¥è¢«é˜»å¡ï¼\n\nè¯·å…³é—­æ‰€æœ‰å…¶ä»–æ‰“å¼€æ­¤é¡µé¢çš„æµè§ˆå™¨æ ‡ç­¾é¡µï¼Œç„¶åå¼ºåˆ¶åˆ·æ–°(Ctrl+F5)æ­¤é¡µé¢ã€‚',
        'db-not-ready': 'æ•°æ®åº“å°šæœªå‡†å¤‡å¥½ï¼Œè¯·ç¨ç­‰ç‰‡åˆ»æˆ–åˆ·æ–°é¡µé¢å†è¯•ã€‚',
        'import-png-failed': 'å¯¼å…¥ PNG è§’è‰²å¡å¤±è´¥: {error}',
        'import-image-failed': 'å¯¼å…¥å›¾ç‰‡å¤±è´¥: {error}',
        'import-json-failed': 'å¯¼å…¥å¤±è´¥ï¼ŒJSON æ–‡ä»¶æ ¼å¼æ— æ•ˆã€‚',
        'save-import-failed': 'ä¿å­˜å¯¼å…¥çš„è§’è‰²å¤±è´¥ã€‚',
        'character-saved': 'è§’è‰² "{name}" å·²ä¿å­˜ã€‚',
        'save-failed': 'ä¿å­˜è§’è‰²å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ•°æ®æˆ–å›¾ç‰‡æ ¼å¼ã€‚',
        'upload-image-only': 'è¯·ä¸Šä¼ å›¾ç‰‡æ ¼å¼çš„æ–‡ä»¶ï¼ˆæ”¯æŒPNGã€JPGã€JPEGã€WEBPã€GIFã€BMPç­‰ï¼‰ã€‚',
        'image-process-failed': 'å›¾ç‰‡å¤„ç†å¤±è´¥: {error}',
        'file-read-error': 'è¯»å–æ–‡ä»¶æ—¶å‡ºé”™ã€‚',
        'file-read-error-with-name': 'è¯»å–æ–‡ä»¶ {name} æ—¶å‡ºé”™: {error}',
        'ai-return-not-array': 'AIè¿”å›çš„ä¸æ˜¯ä¸€ä¸ªæ•°ç»„ã€‚',
        'ai-parse-failed': 'AIè¿”å›çš„æ•°æ®æ ¼å¼ä¸æ­£ç¡®ï¼Œæ— æ³•è§£æã€‚è¯·åœ¨å¼€å‘è€…æ§åˆ¶å°æŸ¥çœ‹è¯¦æƒ…ã€‚',
        'already-root-entry': 'å·²ç»æ˜¯æ ¹æ¡ç›®ï¼Œæ— æ³•é€€å‡ºï¼ˆå–æ¶ˆç¼©è¿›ï¼‰ã€‚',
        'no-description': 'æ— æè¿°',
        
        // å¸®åŠ©æ–‡æœ¬
        'help-id-drop': 'ã€æ¡ç›®æ³¨é‡Šã€‘ç»™è‡ªå·±çœ‹çš„å°æ ‡é¢˜ï¼Œæ–¹ä¾¿è¯†åˆ«æ¡ç›®ç”¨é€”ã€‚\nã€æ’åºID+ç©ºæŠ•â¡ï¸ã€‘å¯ä»¥å¿«é€Ÿç»™æ¡ç›®é‡æ–°æ’å·ã€‚',
        'help-main-keys': 'è¿™æ˜¯è§¦å‘å™¨ï¼Œå†³å®šAIä½•æ—¶â€œæŸ¥é˜…â€è¿™æ¡å†…å®¹ã€‚\nç”¨æ³•ï¼šè¾“å…¥ä¸€ä¸ªæˆ–å¤šä¸ªè¯ï¼Œç”¨é€—å·éš”å¼€ã€‚\nä¾‹ï¼šå…³é”®è¯è®¾ä¸º`è‹¹æœ,é¦™è•‰`ï¼Œå½“ç”¨æˆ·æåˆ°`è‹¹æœ`æˆ–`é¦™è•‰`æ—¶ï¼Œæ­¤æ¡ç›®å°±ä¼šè¢«è§¦å‘ã€‚',
        'help-secondary-keys': 'è¿™æ˜¯â€œäºŒæ¬¡éªŒè¯â€ï¼Œä¸ºä¸»å…³é”®è¯å¢åŠ é¢å¤–çš„è§¦å‘æ¡ä»¶ã€‚\nç”¨æ³•ï¼šå’Œä¸»å…³é”®è¯é…åˆä½¿ç”¨ï¼Œè¿›ä¸€æ­¥è¿‡æ»¤å¯¹è¯ã€‚\nä¾‹ï¼šä¸»å…³é”®è¯æ˜¯`æ”»å‡»`ï¼ŒäºŒæ¬¡éªŒè¯è®¾ä¸ºã€éä»»æ„ã€‘`å–æ¶ˆ`ï¼Œé‚£ä¹ˆåªæœ‰å½“ç”¨æˆ·è¯´äº†`æ”»å‡»`ä½†æ²¡è¯´`å–æ¶ˆ`æ—¶ï¼Œæ¡ç›®æ‰ä¼šç”Ÿæ•ˆã€‚',
        'help-injection-content': 'å½“æ¡ç›®è¢«è§¦å‘æ—¶ï¼ŒAIä¼šâ€œæŸ¥é˜…â€çš„å†…å®¹ã€‚\nç”¨æ³•ï¼šå¡«å†™å¸Œæœ›AIåœ¨ç‰¹å®šæƒ…å¢ƒä¸‹çŸ¥é“çš„ä¿¡æ¯ã€‚\nä¾‹ï¼šå…³é”®è¯æ˜¯`æˆ‘çš„å‰‘`ï¼Œè¿™é‡Œå¯ä»¥å†™`é‚£æ˜¯ä¸€æŠŠç”Ÿé”ˆçš„é“å‰‘ï¼Œæ˜¯çˆ¶äº²çš„é—ç‰©ã€‚`',
        'help-entry-id': 'å†³å®šäº†æ¡ç›®çš„åŸºç¡€æ’åˆ—é¡ºåºã€‚\nç”¨æ³•ï¼šæ•°å­—è¶Šå°ï¼Œè¶Šé å‰ã€‚\nä¾‹ï¼šIDä¸º0çš„æ¡ç›®ä¼šæ¯”IDä¸º1çš„æ¡ç›®å…ˆè¢«å¤„ç†ã€‚',
        'help-entry-priority': 'å†³å®šäº†å½“å¤šä¸ªæ¡ç›®åŒæ—¶è¢«è§¦å‘æ—¶ï¼Œå“ªä¸ªæ¡ç›®è¯´äº†ç®—ã€‚\nç”¨æ³•ï¼šæ•°å­—è¶Šå¤§ï¼ŒæƒåŠ›è¶Šå¤§ã€‚\nä¾‹ï¼š`Aæ¡ç›®(ä¼˜å…ˆçº§100)`å’Œ`Bæ¡ç›®(ä¼˜å…ˆçº§200)`éƒ½è¢«è§¦å‘ï¼ŒAIä¼šä¼˜å…ˆå¬`Bæ¡ç›®`çš„ï¼ˆéœ€å¼€å¯â€œé€‰æ‹©æ€§æ³¨å…¥â€ï¼‰ã€‚',
        'help-entry-position': 'å†³å®šäº†è¿™æ¡å†…å®¹åœ¨ç»™AIçš„â€œå‰§æœ¬â€é‡Œçš„æ‘†æ”¾ä½ç½®ã€‚\nç”¨æ³•ï¼šé€šå¸¸é»˜è®¤å³å¯ã€‚æƒ³å¼ºè°ƒæ—¶å¯é€‰â€œæœ€å¼€å¤´â€ã€‚',
        'help-entry-scope': 'å†³å®šäº†AIåœ¨ä»€ä¹ˆæ—¶å€™ä¼šå»â€œæŸ¥é˜…â€è¿™æœ¬ä¹¦ã€‚\nç”¨æ³•ï¼šä¸€èˆ¬ä¿æŒé»˜è®¤â€œèŠå¤©ä¸­â€å³å¯ã€‚å…¶ä»–é€‰é¡¹ç”¨äºç‰¹æ®Šæ ¼å¼æ§åˆ¶ã€‚',
        'help-entry-enabled': 'è¿™ä¸ªæ¡ç›®çš„â€œå¼€å…³â€ã€‚\nç”¨æ³•ï¼šå–æ¶ˆå‹¾é€‰å¯æš‚æ—¶ç¦ç”¨æ­¤æ¡ç›®ï¼Œè€Œæ— éœ€åˆ é™¤ã€‚',
        'help-entry-constant': 'å°†å†…å®¹å˜æˆAIçš„â€œè‚Œè‚‰è®°å¿†â€ã€‚\næ•ˆæœï¼šæ— è®ºå…³é”®è¯æ˜¯å¦è¢«è§¦å‘ï¼Œè¿™é‡Œçš„å†…å®¹éƒ½ä¼šåœ¨æ¯æ¬¡å¯¹è¯æ—¶æ³¨å…¥ç»™AIã€‚\nç”¨é€”ï¼šé€‚åˆå­˜æ”¾è§’è‰²ç»å¯¹ä¸èƒ½å¿˜è®°çš„æ ¸å¿ƒè®¾å®šã€‚',
        'help-entry-selective': 'å¼€å¯â€œä¼˜èƒœåŠ£æ±°â€æ¨¡å¼ã€‚\næ•ˆæœï¼šå‹¾é€‰åï¼Œåœ¨åŒæ—¶è§¦å‘çš„æ¡ç›®ä¸­ï¼Œåªæœ‰ä¼˜å…ˆçº§æœ€é«˜çš„é‚£ä¸ªä¼šè¢«æ³¨å…¥ã€‚å¦åˆ™æ‰€æœ‰è§¦å‘çš„éƒ½ä¼šæ³¨å…¥ã€‚',
        'help-entry-use-regex': 'å¯ç”¨â€œç¨‹åºå‘˜æ¨¡å¼â€æ¥è®¾ç½®å…³é”®è¯ã€‚\nç”¨æ³•ï¼šå…è®¸ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æ¥è®¾ç½®æ›´å¤æ‚çš„å…³é”®è¯åŒ¹é…è§„åˆ™ï¼Œä¸æ‡‚ç¼–ç¨‹å»ºè®®ä¸å‹¾é€‰ã€‚',
        'help-entry-prevent-recursion': 'é˜²æ­¢AIâ€œè‡ªå·±è·Ÿè‡ªå·±è¯´è¯â€ã€‚\næ•ˆæœï¼šé˜²æ­¢ä¸€ä¸ªæ¡ç›®çš„æ³¨å…¥å†…å®¹ï¼Œåˆè§¦å‘äº†å¦ä¸€ä¸ªæ¡ç›®ï¼Œå½¢æˆæ— é™å¾ªç¯ã€‚å»ºè®®ä¿æŒå‹¾é€‰ã€‚',
        'help-entry-group': 'ç»™æ¡ç›®â€œè´´æ ‡ç­¾â€ï¼Œæ–¹ä¾¿ç®¡ç†ã€‚\nç”¨æ³•ï¼šç»™é€»è¾‘ç›¸å…³çš„æ¡ç›®è®¾ç½®åŒä¸€ä¸ªåˆ†ç»„åï¼Œå¯ç”¨äºå…¶ä»–é«˜çº§åŠŸèƒ½ã€‚',
        'help-entry-probability': 'è®©AIâ€œçœ‹å¿ƒæƒ…â€æŸ¥é˜…è¿™æ¡å†…å®¹ã€‚\nç”¨æ³•ï¼šè®¾ä¸º80ï¼Œåˆ™æ­¤æ¡ç›®è¢«å…³é”®è¯è§¦å‘åï¼Œæœ‰80%çš„å‡ ç‡ç”Ÿæ•ˆã€‚\nç”¨é€”ï¼šå¯ä»¥å¢åŠ AIè¡Œä¸ºçš„éšæœºæ€§ã€‚',
        'help-entry-depth': 'å†³å®šAIâ€œè®°æ€§æœ‰å¤šå¥½â€ã€‚\nç”¨æ³•ï¼šè®¾ä¸º5ï¼ŒAIä¼šæ£€æŸ¥æœ€è¿‘5è½®å¯¹è¯é‡Œæœ‰æ²¡æœ‰å…³é”®è¯ã€‚æ•°å­—è¶Šå¤§ï¼ŒAIçœ‹å¾—è¶Šè¿œï¼Œä½†ä¹Ÿä¼šæ¶ˆè€—æ›´å¤šæ€§èƒ½ã€‚',
        'help-match-whole-words': 'å¼€å¯â€œç²¾ç¡®æŸ¥æ‰¾â€æ¨¡å¼ã€‚\næ•ˆæœï¼šè¦æ±‚å…³é”®è¯å¿…é¡»æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„è¯æ‰è§¦å‘ã€‚\nä¾‹ï¼šå…³é”®è¯ä¸º`çˆ±`ã€‚å‹¾é€‰åï¼Œåªæœ‰å½“ç”¨æˆ·è¯´`çˆ±`è¿™ä¸ªå­—æ—¶æ‰ç®—ï¼Œ`çƒ­çˆ±`ã€`çˆ±æƒ…`è¿™äº›è¯ä¸ç®—ã€‚',
        'help-case-sensitive': 'è®©AIâ€œæ³¨æ„å¤§å°å†™â€ã€‚\næ•ˆæœï¼šå‹¾é€‰åï¼Œå…³é”®è¯çš„å¤§å°å†™å¿…é¡»å®Œå…¨ä¸€æ ·æ‰èƒ½è§¦å‘ã€‚\nä¾‹ï¼šå…³é”®è¯ä¸º`Apple`ï¼Œåˆ™`apple`ä¸ä¼šè§¦å‘ã€‚ä¸€èˆ¬ç”¨äºè‹±æ–‡ã€‚',

        // APIç›¸å…³
        'api-key-placeholder': 'è¾“å…¥ DeepSeek API Key',
        
        // é»˜è®¤å€¼
        'imported-character': 'ä»å›¾ç‰‡å¯¼å…¥çš„è§’è‰²',
        'imported-lorebook': 'å¯¼å…¥çš„ä¸–ç•Œä¹¦',
        'lorebook-description': 'ä»SillyTavernå¯¼å…¥çš„ä¸–ç•Œä¹¦ã€‚',
        'lorebook-tag': 'ä¸–ç•Œä¹¦',

        // ç¡®è®¤å¯¹è¯æ¡†
        'confirm-overwrite-worldbook': 'è¿™å°†ä¼šè¦†ç›–å½“å‰æ‰€æœ‰çš„è§’è‰²ä¹¦æ¡ç›®ï¼Œä½ ç¡®å®šå—ï¼Ÿ',
        
        // æˆåŠŸæ¶ˆæ¯
        'worldbook-generated-success': 'å·²æˆåŠŸç”Ÿæˆå¹¶åŠ è½½è§’è‰²ä¹¦å‚è€ƒæ¡ç›®ï¼',
        
        // APIç›¸å…³é”™è¯¯
        'api-request-failed': 'API è¯·æ±‚å¤±è´¥: {status} - {message}',
        'ai-completion-failed': 'AIè¡¥å…¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥API Keyæˆ–ç½‘ç»œè¿æ¥ï¼Œå¹¶æŸ¥çœ‹æ§åˆ¶å°è·å–æ›´å¤šä¿¡æ¯ã€‚',
        'name-generation-failed': 'AIåå­—ç”Ÿæˆå¤±è´¥ï¼Œè¯·æ£€æŸ¥API Keyæˆ–ç½‘ç»œï¼Œå¹¶æŸ¥çœ‹æ§åˆ¶å°ã€‚',

        // çŠ¶æ€æ–‡æœ¬
        'generating': 'ç”Ÿæˆä¸­...',
        'loading': 'æ­£åœ¨åŠ è½½...',
        'choose-a-name': 'ä¸ºä½ çš„è§’è‰²é€‰æ‹©ä¸€ä¸ªåå­—',
        'regenerate': 'é‡æ–°ç”Ÿæˆ',
        'cancel': 'å–æ¶ˆ',

        // Post-history Templates
        'post-history-options-mode': 'é€‰é¡¹æ¨¡å¼',
        'post-history-parentheses-mode': 'æ‹¬å·æ¨¡å¼',
        'post-history-status-bar': 'çŠ¶æ€æ ',
        'post-history-third-person': 'ç¬¬ä¸‰äººç§°',
        'post-history-json-mode': 'JSONæ¨¡å¼',
        'template-options-mode': '[ä»¥ä¸­æ–‡å›å¤] [ç³»ç»ŸæŒ‡ä»¤]: ä½ ç°åœ¨éœ€è¦æ ¹æ®ç”¨æˆ·çš„è¾“å…¥ç”Ÿæˆå›åº”ã€‚å›åº”å¿…é¡»ä¸¥æ ¼éµå¾ªä»¥ä¸‹æ ¼å¼ï¼šä¸ºç”¨æˆ·æä¾›å‡ ä¸ªæ¸…æ™°æ˜ç¡®çš„ä¸‹ä¸€æ­¥è¡ŒåŠ¨æˆ–å¯¹è¯é€‰é¡¹ã€‚æ¯ä¸ªé€‰é¡¹å ä¸€è¡Œï¼Œå¹¶ä»¥å­—æ¯ï¼ˆAã€Bã€Cç­‰ï¼‰å¼€å¤´ã€‚åœ¨é€‰é¡¹åˆ—è¡¨å‰åä¸è¦æ·»åŠ ä»»ä½•é¢å¤–æ–‡å­—ã€‚',
        'template-parentheses-mode': '[ç³»ç»ŸæŒ‡ä»¤]: åœ¨ç”Ÿæˆå›åº”æ—¶ï¼Œè¯·ä½¿ç”¨æ‹¬å·æ¥æè¿°{{char}}çš„åŠ¨ä½œã€è¡¨æƒ…å’Œå†…å¿ƒæƒ³æ³•ã€‚å¯¹è¯æœ¬èº«åº”åœ¨æ‹¬å·ä¹‹å¤–ã€‚ä¾‹å¦‚ï¼š"ä½ åœ¨è¿™é‡Œåšä»€ä¹ˆï¼Ÿ" (å¥¹æŒ‘èµ·ä¸€è¾¹çš„çœ‰æ¯›ï¼ŒåŒè‡‚äº¤å‰ï¼Œçœ¼ç¥ä¸­å¸¦ç€ä¸€ä¸å®¡è§†)ã€‚',
        'template-status-bar': '[ç³»ç»ŸæŒ‡ä»¤]: åœ¨æ¯æ¬¡å›åº”çš„æœ«å°¾ï¼Œä½ å¿…é¡»é™„å¸¦ä¸€ä¸ªæ˜¾ç¤º{{char}}å½“å‰å…³é”®æ•°å€¼çš„çŠ¶æ€æ ã€‚çŠ¶æ€æ å¿…é¡»ç”¨ä»£ç å—(```)åŒ…è£¹ã€‚æ ¼å¼ä¸ºï¼š| ç”Ÿå‘½å€¼: [æ•°å€¼] | ç†æ™º: [æ•°å€¼] | å¯¹{{user}}çš„å¥½æ„Ÿåº¦: [æ•°å€¼] | ä½ç½®: [åœ°ç‚¹] |ã€‚ä½ å¿…é¡»æ ¹æ®å¯¹è¯å†…å®¹ï¼Œåˆä¹é€»è¾‘åœ°æ›´æ–°è¿™äº›æ•°å€¼ã€‚',
        'template-third-person': '[ç³»ç»ŸæŒ‡ä»¤]: ä½¿ç”¨ç¬¬ä¸‰äººç§°å™äº‹è§†è§’æ’°å†™æ‰€æœ‰å›åº”ã€‚åœ¨æŒ‡ä»£{{char}}æ—¶ï¼Œä¸è¦ä½¿ç”¨"æˆ‘"ã€‚åƒå°è¯´æ—ç™½ä¸€æ ·æè¿°{{char}}çš„è¡ŒåŠ¨ã€è¯­è¨€å’Œæ€æƒ³ã€‚å§‹ç»ˆç”¨è§’è‰²çš„åå­—{{char}}æ¥æŒ‡ä»£è§’è‰²ã€‚',
        'template-json-mode': '[ç³»ç»ŸæŒ‡ä»¤]: ä½ æ‰€æœ‰çš„å›åº”éƒ½å¿…é¡»æ˜¯åˆæ³•çš„JSONæ ¼å¼ã€‚è¯¥JSONå¯¹è±¡å¿…é¡»åŒ…å«ä¸‰ä¸ªé”®ï¼š"dialogue" (å­—ç¬¦ä¸²ï¼ŒåŒ…å«è§’è‰²è¯´çš„è¯), "action" (å­—ç¬¦ä¸²ï¼Œæè¿°è§’è‰²çš„åŠ¨ä½œ), "emotion" (å­—ç¬¦ä¸²ï¼Œæè¿°è§’è‰²å½“å‰çš„ä¸»è¦æƒ…ç»ª)ã€‚ä¸è¦åœ¨JSONç»“æ„ä¹‹å¤–è¾“å‡ºä»»ä½•æ–‡å­—ã€‚',
        'post-history-image-prompt': 'æ–‡ç”Ÿå›¾æç¤ºè¯',
        'template-image-prompt': '[SYSTEM]: Loraåï¼šSv5-10ï¼Œè§’è‰²å…³é”®è¯ï¼šSilverWolfV5\nYour response must have a comma-separated list of English keywords before the text for an AI image generator. Describe the character\'s appearance, action, expression, and the background. Use descriptive tagsï¼Œæœ€åè¦æ¢è¡Œ. Example: masterpiece, best quality, è§’è‰²å…³é”®è¯, solo, beautiful detailed eyes, long silver hair, smiling, school uniform, standing in a classroom, from above, <lora:Loraå>',
    },
    
    en: {
        // Titles and buttons
        'app-title': 'Nika Character Studio Pro',
        'create-new-character': 'Create New Character/Book',
        'import-character': 'ğŸ“¥ Import Character Card',
        'edit-character': 'Edit Character',
        'save-and-return': 'ğŸ’¾ Save and Return to Library',
        'return-without-save': 'ğŸ”™ Return (Don\'t Save)',
        'download-json': 'ğŸ“¥ Download JSON',
        'download-png': 'ğŸ“¥ Download PNG Character Card',
        'upload-image': 'Upload Image',
        'edit': 'Edit',
        'add-tag': 'Add Tag',
        'delete': 'Delete',
        'add-new-entry': '+ Add New Entry',
        'sort-by-id': 'ğŸ”„ Sort by ID',
        'ai-generate-entries': 'ğŸ”® AI Generate Reference Entries',
        'ai-help-write': 'ğŸ”® AI Help Me Write',
        'undo': 'â†©ï¸ Undo',
        'generate-companion': 'ğŸ”® Generate Virtual Companion',
        
        // Tag filtering
        'tag-filter': 'Tag Filter',
        'no-characters-found': 'No matching characters found. Try clearing filters or importing new character cards.',
        
        // Form labels
        'avatar-label': 'Character Avatar',
        'avatar-upload': 'Upload Image',
        'world-topic': 'World Topic',
        'topic': 'Topic',
        'topic-placeholder': 'e.g.: Cyberpunk, Fantasy, School',
        'character-core': 'Character Core',
        'name': 'Name',
        'name-placeholder': 'e.g.: Alice',
        'gender': 'Gender',
        'gender-placeholder': 'e.g.: Female',
        'character-details': 'Character Details',
        'description': 'Description',
        'description-placeholder': 'The character\'s identity, appearance, background, etc. Will be shown on the character card.',
        'tags': 'Category Tags (comma separated)',
        'tags-placeholder': 'Tags for filtering. e.g.: Original, Game, Yandere (comma separated)',
        'personality': 'Personality',
        'personality-placeholder': 'Detailed personality traits. e.g.: Eloquent, Mature, Yandere (comma separated)',
        'settings': 'Settings',
        'system-prompt': 'Personality Setting',
        'system-prompt-placeholder': 'Core rules the AI must follow. e.g.: You are [Name], a [Role]. You must call the user "darling".',
        'scenario': 'Scenario Setting',
        'scenario-placeholder': 'The environment for the scene. e.g.: {{char}} and {{user}} are in a classroom at dusk.',
        'first-message': 'Greeting Message',
        'first-message-placeholder': 'The character\'s first message to the user.',
        'message-example': 'Message Example',
        'message-example-placeholder': 'Example dialogues for the AI to imitate. Very important!',
        'advanced-settings': 'Advanced Settings',
        'post-history-instructions': 'Post Instructions',
        'post-history-instructions-placeholder': 'Some platforms use this to modify AI response format. For example, to make {{char}}\'s actions wrapped in asterisks, write: Put all {{char}}\'s actions and narration between asterisks (*).',
        'world-knowledge-book': 'World/Knowledge Book',
        'companion-mode': 'Companion Mode',
        
        // Worldbook related
        'worldbook-help': 'You can think of the "World Book" as a <b>reference dictionary</b> for AI. If you only want the world book, you only need to fill in the name in the information above this',
        'entry-comment': 'Entry Comment (Comment)',
        'entry-comment-placeholder': 'Entry Comment (Comment)',
        'main-keys': 'Main Keywords (Keys, comma separated)',
        'main-keys-placeholder': 'e.g.: Excalibur, Holy Sword',
        'secondary-keys': 'Secondary Keywords (Secondary Keys, comma separated)',
        'secondary-keys-placeholder': 'e.g.: sword, weapon',
        'injection-content': 'Injection Content (Content)',
        'injection-content-placeholder': 'When keywords are triggered, this content will be sent to AI.',
        'entry-id': 'Sort ID',
        'entry-id-placeholder': 'Number, affects order',
        'entry-priority': 'Priority',
        'entry-priority-placeholder': 'Number, determines which entry wins',
        'entry-position': 'Injection Position',
        'entry-scope': 'Scope',
        'priority-preset-prereq': 'Prereq',
        'priority-preset-important': 'Important',
        'priority-preset-normal': 'Normal',
        'entry-enabled': 'Enabled',
        'entry-constant': 'Constant',
        'entry-selective': 'Selective',
        'entry-use-regex': 'Use Regex',
        'entry-prevent-recursion': 'Prevent Recursion',
        'entry-group': 'Group',
        'entry-group-placeholder': 'Group name',
        'entry-probability': 'Trigger Probability (%)',
        'entry-probability-placeholder': '0-100',
        'entry-depth': 'Scan Depth',
        'entry-depth-placeholder': 'Number',
        'match-whole-words': 'Match Whole Words',
        'case-sensitive': 'Case-Sensitive',

        
        // Error and prompt messages
        'db-timeout': 'Database connection timeout. Please try closing all other tabs and force refresh (Ctrl+F5). If the problem persists, try clearing site data.',
        'db-error': 'Error: Unable to connect to local database.\n\nDetails: {error}\n\nYour characters cannot be saved or read. Please check browser settings (such as privacy protection, cookie blocking, etc.) or try clearing site data.',
        'db-blocked': 'Database connection blocked!\n\nPlease close all other browser tabs that have this page open, then force refresh (Ctrl+F5) this page.',
        'db-not-ready': 'Database not ready, please wait a moment or refresh the page and try again.',
        'import-png-failed': 'Failed to import PNG character card: {error}',
        'import-image-failed': 'Failed to import image: {error}',
        'import-json-failed': 'Import failed, JSON file format is invalid.',
        'save-import-failed': 'Failed to save imported character.',
        'character-saved': 'Character "{name}" saved.',
        'save-failed': 'Failed to save character, please check data or image format.',
        'upload-image-only': 'Please upload image format files (supports PNG, JPG, JPEG, WEBP, GIF, BMP, etc.).',
        'image-process-failed': 'Image processing failed: {error}',
        'file-read-error': 'Error reading file.',
        'file-read-error-with-name': 'Error reading file {name}: {error}',
        'ai-return-not-array': 'AI did not return an array.',
        'ai-parse-failed': 'AI returned data format is incorrect and cannot be parsed. Please check developer console for details.',
        'already-root-entry': 'Already at root entry, cannot exit (cancel indentation).',
        'no-description': 'No description',
        
        // Help text
        'help-id-drop': 'The [ID Box + â¡ï¸ Button] allows for an "airdrop". Enter a target position (e.g., 5) in the ID box and click â¡ï¸. This entry\'s ID will become 5, and the original entry with ID 5 and all subsequent entries will have their IDs automatically incremented by 1.\n[Entry Comment] is for your own notes, helping you identify the purpose of this entry.',
        'help-main-keys': 'Set one or more keywords, separated by commas. When the user\'s message contains any of these keywords, this entry will be activated, and its "Injection Content" will be sent to the AI.',
        'help-secondary-keys': 'This is an additional activation condition that works with the main keywords to determine if this entry takes effect.\n\n[With Any]: The filter passes if at least one word from this list is in the message.\n[Not Any]: The filter passes if none of the words from this list are in the message.\n[With All]: The filter passes only if all words from this list are in the message.\n[Not All]: The filter passes as long as there is at least one word from the list not present in the message.',
        'help-injection-content': 'When the keywords are triggered, this content will be sent to the AI.',
        'help-entry-id': '[Sort ID] determines which entry the AI sees first within the same level. A smaller number means it comes first.',
        'help-entry-priority': '[Priority] determines which entry wins when multiple triggered entries compete for injection. A higher number means higher priority. Use the quick-set buttons on the right for common values.',
        'help-entry-position': '[Injection Position] determines where this content is placed in the final prompt sent to the AI.\n[Before Character]: Default. The content appears before the character\'s core definition.\n[After Character]: The content appears after the core definition.\n[At the very beginning]: The content is placed at the absolute top of the prompt.',
        'help-entry-scope': '[Scope] determines under what circumstances this entry is checked.\n[In chat]: Default. Checked after every user message.\n[In memory summary]: Checked when generating a conversation memory summary.\n[On chat entry]: Checked every time a new conversation with the character begins.',
        'help-entry-enabled': '[Enabled] Uncheck this to temporarily disable the entry without deleting it.',
        'help-entry-constant': '[Constant] If checked, this entry will always be injected into the prompt, regardless of keywords.',
        'help-entry-selective': '[Selective] If checked, only the highest-priority entry will be injected when multiple entries are triggered. If unchecked, all triggered entries will be injected.',
        'help-entry-use-regex': '[Use Regex] Allows you to use Regular Expressions for more complex keyword matching rules. For advanced users.',
        'help-entry-prevent-recursion': '[Prevent Recursion] Prevents the content of one entry from triggering other entries, avoiding infinite loops.',
        'help-entry-group': '[Group] Assign a group name to an entry to help organize and manage a large number of entries.',
        'help-entry-probability': '[Trigger Probability] Set a number from 0 to 100. This determines the chance that the entry will actually be injected after its keywords are triggered. 100 means it always will.',
        'help-entry-depth': '[Scan Depth] Determines how many turns of conversation history the AI will look back through to check for this entry\'s keywords. A larger number means it looks further back.',
        'help-match-whole-words': '[Match Whole Words] If checked, a keyword is only triggered if it appears as a whole word. For example, if the keyword is "love", it would trigger on "I love you" but not "glove".',
        'help-case-sensitive': '[Case-Sensitive] If checked, the keyword must match the case of the text exactly to be triggered. For example, if the keyword is "Apple", it will not be triggered by "apple".',

        // API related
        'api-key-placeholder': 'Enter DeepSeek API Key',
        
        // Default values
        'imported-character': 'Character imported from image',
        'imported-lorebook': 'Imported Lorebook',
        'lorebook-description': 'A lorebook imported from SillyTavern.',
        'lorebook-tag': 'lorebook',
        
        // Confirmation dialogs
        'confirm-overwrite-worldbook': 'This will overwrite all current worldbook entries. Are you sure?',
        
        // Success messages
        'worldbook-generated-success': 'Successfully generated and loaded worldbook reference entries!',
        
        // API related errors
        'api-request-failed': 'API request failed: {status} - {message}',
        'ai-completion-failed': 'AI completion failed, please check API Key or network connection, and check console for more information.',
        'name-generation-failed': 'AI Name Generation failed. Please check your API Key or network and see the console for details.',
        
        // Status text
        'generating': 'Generating...',
        'loading': 'Loading...',
        'choose-a-name': 'Choose a Name for Your Character',
        'regenerate': 'Regenerate',
        'cancel': 'Cancel',

        // Post-history Templates
        'post-history-options-mode': 'Options Mode',
        'post-history-parentheses-mode': 'Parentheses Mode',
        'post-history-status-bar': 'Status Bar',
        'post-history-third-person': 'Third Person',
        'post-history-json-mode': 'JSON Mode',
        'template-options-mode': '[SYSTEM]: You will now generate a response based on the user\'s input. The response must follow a strict format: present the user with a few distinct choices as their next action or dialogue line. Each choice should be on a new line, starting with a letter (A, B, C, etc.). Do not add any text before or after the list of choices.',
        'template-parentheses-mode': '[SYSTEM]: When generating a response, use parentheses to describe {{char}}\'s actions, expressions, and internal thoughts. Dialogue should remain outside of the parentheses. Example: "What are you doing here?" (She raises an eyebrow, a hint of suspicion in her eyes as she crosses her arms).',
        'template-status-bar': '[SYSTEM]: At the end of every response, you must include a status bar that displays {{char}}\'s current key stats. The status bar should be enclosed in code blocks (```). The format is: | Health: [value] | Sanity: [value] | Affection for {{user}}: [value] | Location: [value] |. You must update these values logically based on the conversation.',
        'template-third-person': '[SYSTEM]: Write all responses from a third-person narrative perspective. Do not use "I" or "me" when referring to {{char}}. Describe {{char}}\'s actions, speech, and thoughts as a narrator would. Always refer to the character by their name, {{char}}.',
        'template-json-mode': '[SYSTEM]: All your responses must be in a valid JSON format. The JSON object must have three keys: "dialogue" (a string containing what the character says), "action" (a string describing the character\'s physical action), and "emotion" (a string describing the character\'s current primary emotion). Do not output any text outside of the JSON structure.',
        'post-history-image-prompt': 'Image Prompt',
        'template-image-prompt': '[SYSTEM]: Lora name: Sv5-10, character keyword: SilverWolfV5\nYour response must have a comma-separated list of English keywords before the text for an AI image generator. Describe the character\'s appearance, action, expression, and the background.',
    }
};

// è¯­è¨€åˆ‡æ¢å‡½æ•°
function switchLanguage(lang) {
    currentLanguage = lang;
    localStorage.setItem('language', lang);
    
    // æ›´æ–°æŒ‰é’®çŠ¶æ€
    document.getElementById('lang-zh').classList.toggle('active', lang === 'zh');
    document.getElementById('lang-en').classList.toggle('active', lang === 'en');
    
    // æ›´æ–°é¡µé¢å†…å®¹
    updatePageContent();
}

// è·å–ç¿»è¯‘æ–‡æœ¬
function t(key, params = {}) {
    let text = translations[currentLanguage][key] || translations['zh'][key] || key;
    
    // æ›¿æ¢å‚æ•°
    Object.keys(params).forEach(param => {
        text = text.replace(`{${param}}`, params[param]);
    });
    
    return text;
}

// æ›´æ–°é¡µé¢å†…å®¹
function updatePageContent() {
    // æ›´æ–°æ ‡é¢˜
    document.title = t('app-title');
    
    // æ›´æ–°åº“è§†å›¾
    const libraryTitle = document.querySelector('#library-view .header h1');
    if (libraryTitle) libraryTitle.textContent = t('app-title');
    
    // ç¡®ä¿è¯­è¨€åˆ‡æ¢æŒ‰é’®åœ¨æ ‡é¢˜æ—è¾¹å¹¶æ›´æ–°çŠ¶æ€
    const titleContainer = libraryTitle?.parentElement;
    let languageSwitcher = titleContainer?.querySelector('.language-switcher');
    
    if (titleContainer && !languageSwitcher) {
        languageSwitcher = document.createElement('div');
        languageSwitcher.className = 'language-switcher';
        titleContainer.appendChild(languageSwitcher);
    }
    
    if (languageSwitcher) {
        languageSwitcher.innerHTML = `
            <button onclick="switchLanguage('zh')" id="lang-zh" class="${currentLanguage === 'zh' ? 'active' : ''}">ä¸­æ–‡</button>
            <button onclick="switchLanguage('en')" id="lang-en" class="${currentLanguage === 'en' ? 'active' : ''}">English</button>
        `;
    }
    
    const createBtn = document.querySelector('#library-view .header-buttons button:first-child');
    if (createBtn) createBtn.textContent = '+ ' + t('create-new-character');
    
    const importBtn = document.querySelector('#library-view .header-buttons button:nth-child(2)');
    if (importBtn) importBtn.textContent = t('import-character');
    
    const tagFilterTitle = document.querySelector('#library-view .tag-filter-area h3');
    if (tagFilterTitle) tagFilterTitle.textContent = t('tag-filter');
    
    // æ›´æ–°ç¼–è¾‘å™¨è§†å›¾
    const editorTitle = document.getElementById('editor-title');
    if (editorTitle) {
        const isEditing = document.getElementById('charId').value !== '';
        editorTitle.textContent = isEditing ? t('edit-character') : t('create-new-character');
    }
    
    const apiKeyInput = document.getElementById('apiKey');
    if (apiKeyInput) apiKeyInput.placeholder = t('api-key-placeholder');
    
    // æ›´æ–°è¡¨å•æ ‡ç­¾å’Œå ä½ç¬¦
    updateFormLabels();
    
    // æ›´æ–°æŒ‰é’®æ–‡æœ¬
    updateButtonTexts();
    
    // æ›´æ–°ä¸–ç•Œä¹¦å¸®åŠ©æ–‡æœ¬
    const worldbookHelpText = document.getElementById('worldbook-help-text');
    if (worldbookHelpText) {
        worldbookHelpText.innerHTML = t('worldbook-help');
    }
    
    // æ›´æ–°åŠ è½½æ–‡æœ¬
    const loadingText = document.getElementById('loading-text');
    if (loadingText) {
        loadingText.textContent = t('loading');
    }

    // æ›´æ–°åå­—ç”Ÿæˆå™¨ Modal
    document.getElementById('name-modal-title').textContent = t('choose-a-name');
    document.getElementById('regenerate-names-btn').textContent = t('regenerate');
    document.getElementById('cancel-name-generation-btn').textContent = t('cancel');

    // é‡æ–°æ¸²æŸ“UIä»¥æ›´æ–°è§’è‰²å¡æ˜¾ç¤º
    if (libraryView.style.display !== 'none') {
        renderUI();
    }
    
    // é‡æ–°æ¸²æŸ“è§’è‰²ä¹¦æ¡ç›®ä»¥æ›´æ–°ç¿»è¯‘
    if (editorView.style.display !== 'none') {
        const worldbookData = buildWorldbookDataFromDOM();
        renderWorldbookFromData(worldbookData);
    }
}

// æ›´æ–°è¡¨å•æ ‡ç­¾
function updateFormLabels() {
    // æ›´æ–°sectionæ ‡é¢˜
    const sectionTitles = {
        'avatar-operation-title': t('avatar-label'),
        'world-topic-title': t('world-topic'),
        'character-core-title': t('character-core'),
        'character-details-title': t('character-details'),
        'settings-title': t('settings'),
        'advanced-settings-title': t('advanced-settings'),
        'world-knowledge-book-title': t('world-knowledge-book')
    };
    
    Object.keys(sectionTitles).forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            element.textContent = sectionTitles[id];
        }
    });
    
    // æ›´æ–°è¡¨å•æ ‡ç­¾
    const labels = {
        'topic': t('topic'),
        'name': t('name'),
        'gender': t('gender'),
        'description': t('description'),
        'tags': t('tags'),
        'personality': t('personality'),
        'system_prompt': t('system-prompt'),
        'scenario': t('scenario'),
        'first_mes': t('first-message'),
        'mes_example': t('message-example'),
        'post_history_instructions': t('post-history-instructions')
    };
    
    Object.keys(labels).forEach(id => {
        const element = document.querySelector(`label[for="${id}"]`);
        if (element) element.textContent = labels[id];
    });
    
    // æ›´æ–°å ä½ç¬¦
    const placeholders = {
        'topic': t('topic-placeholder'),
        'name': t('name-placeholder'),
        'gender': t('gender-placeholder'),
        'description': t('description-placeholder'),
        'tags': t('tags-placeholder'),
        'personality': t('personality-placeholder'),
        'system_prompt': t('system-prompt-placeholder'),
        'scenario': t('scenario-placeholder'),
        'first_mes': t('first-message-placeholder'),
        'mes_example': t('message-example-placeholder'),
        'post_history_instructions': t('post-history-instructions-placeholder')
    };
    
    Object.keys(placeholders).forEach(id => {
        const element = document.getElementById(id);
        if (element) element.placeholder = placeholders[id];
    });
    
    // æ›´æ–°ä¼´ä¾£æ¨¡å¼æ ‡ç­¾
    const companionModeLabel = document.getElementById('companion-mode-label');
    if (companionModeLabel) {
        companionModeLabel.textContent = t('companion-mode');
    }
    
    // æ›´æ–°å¤´åƒæ ‡ç­¾
    const avatarLabel = document.getElementById('avatar-input-label');
    if (avatarLabel) {
        avatarLabel.textContent = t('avatar-label');
        avatarLabel.title = currentLanguage === 'zh' ? 'ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®ä¸Šä¼ å›¾ç‰‡' : 'Click the button below to upload image';
    }
    
    // æ›´æ–°é«˜çº§è®¾å®šsummary
    const advancedSummary = document.getElementById('advanced-settings-summary');
    if (advancedSummary) {
        const subtitle = currentLanguage === 'zh' ? '(å…³é”®è¯åŒ¹é…ã€æ³¨å…¥é€»è¾‘ç­‰)' : '(Keyword matching, injection logic, etc.)';
        advancedSummary.innerHTML = `${t('advanced-settings')} <span style="font-weight: normal; font-size: 14px; color: #aaa;">${subtitle}</span>`;
    }
    
    // æ›´æ–°ä¸Šä¼ å›¾ç‰‡æŒ‰é’®
    const uploadBtn = document.querySelector('button[onclick="document.getElementById(\'avatar-input\').click()"]');
    if (uploadBtn) uploadBtn.textContent = t('upload-image');
}

// æ›´æ–°æŒ‰é’®æ–‡æœ¬
function updateButtonTexts() {
    // æ›´æ–°ä¿å­˜æŒ‰é’®
    const saveBtn = document.querySelector('button[onclick="saveCharacter()"]');
    if (saveBtn) saveBtn.textContent = t('save-and-return');
    
    const returnBtn = document.querySelector('button[onclick="showLibraryView()"]');
    if (returnBtn) returnBtn.textContent = t('return-without-save');
    
    const downloadJsonBtn = document.querySelector('button[onclick="downloadCharacter()"]');
    if (downloadJsonBtn) downloadJsonBtn.textContent = t('download-json');
    
    const downloadPngBtn = document.querySelector('button[onclick="downloadCharacterAsPng()"]');
    if (downloadPngBtn) downloadPngBtn.textContent = t('download-png');
    
    // æ›´æ–°AIæŒ‰é’®
    const aiButtons = document.querySelectorAll('.ai-button');
    aiButtons.forEach(btn => {
        btn.textContent = t('ai-help-write');
    });
    
    const undoButtons = document.querySelectorAll('.ai-undo-button');
    undoButtons.forEach(btn => {
        btn.textContent = t('undo');
    });
    
    // æ›´æ–°ä¸–ç•Œä¹¦ç›¸å…³æŒ‰é’®
    const addEntryBtn = document.querySelector('button[onclick="addWorldbookEntry()"]');
    if (addEntryBtn) addEntryBtn.textContent = t('add-new-entry');
    
    const sortBtn = document.querySelector('button[onclick="sortWorldbookEntries()"]');
    if (sortBtn) sortBtn.textContent = t('sort-by-id');
    
    const generateBtn = document.querySelector('button[onclick="generateFullWorldbook(this)"]');
    if (generateBtn) generateBtn.textContent = t('ai-generate-entries');
    
    // æ›´æ–°è§’è‰²å¡æŒ‰é’®
    const addTagBtns = document.querySelectorAll('.card-footer button[onclick*="addInternalTag"]');
    addTagBtns.forEach(btn => {
        btn.textContent = `ğŸ·ï¸ ${t('add-tag')}`;
    });
    
    const deleteBtns = document.querySelectorAll('.card-footer button[onclick*="deleteCharacter"]');
    deleteBtns.forEach(btn => {
        btn.textContent = `ğŸ—‘ï¸ ${t('delete')}`;
    });

    // æ›´æ–°Post-historyæ¨¡æ¿æŒ‰é’®
    const templateContainer = document.getElementById('post-history-templates');
    if (templateContainer) {
        document.getElementById('btn-template-options').textContent = t('post-history-options-mode');
        document.getElementById('btn-template-parentheses').textContent = t('post-history-parentheses-mode');
        document.getElementById('btn-template-status-bar').textContent = t('post-history-status-bar');
        document.getElementById('btn-template-third-person').textContent = t('post-history-third-person');
        document.getElementById('btn-template-json-mode').textContent = t('post-history-json-mode');
        document.getElementById('btn-template-image-prompt').textContent = t('post-history-image-prompt');
    }
}

// --- DB & Initialization ---
let db;
let activeFilters = new Set();
const libraryView = document.getElementById('library-view');
const editorView = document.getElementById('editor-view');
let avatarImageBase64 = null;

// --- å…¨å±€å¸®åŠ©å‡½æ•° ---
function showHelp(message) {
    alert(message);
}

// [MODIFIED] è®¾ç½®åæœŸæŒ‡ä»¤æ¨¡æ¿å‡½æ•°
function setPostHistoryTemplate(templateKey) {
    const textarea = document.getElementById('post_history_instructions');
    if (textarea) {
        const templateText = t(templateKey);
        // æ£€æŸ¥æ–‡æœ¬åŒºåŸŸæ˜¯å¦ä¸ºç©ºæˆ–ä»…åŒ…å«ç©ºç™½å­—ç¬¦
        if (textarea.value.trim() === '') {
            textarea.value = templateText;
        } else {
            // å¦‚æœå·²æœ‰å†…å®¹ï¼Œåˆ™åœ¨æ–°è¡Œè¿½åŠ ï¼Œå¹¶ç”¨ç©ºè¡Œåˆ†éš”
            textarea.value += '\n\n' + templateText;
        }
    }
}

/**
 * [NEW] Converts a SillyTavern lorebook object into the application's internal format.
 * @param {object} lorebook - The raw lorebook object from the imported JSON.
 * @returns {Array} An array of worldbook entries in the internal format.
 */
function convertTavernLorebookToInternal(lorebook) {
    const internalEntries = [];
    const entriesSource = (lorebook.entries && typeof lorebook.entries === 'object' && !Array.isArray(lorebook.entries))
        ? lorebook.entries
        : (lorebook.extensions && lorebook.extensions.entries && typeof lorebook.extensions.entries === 'object' && !Array.isArray(lorebook.extensions.entries))
            ? lorebook.extensions.entries
            : null;

    if (!entriesSource) {
        console.warn("Could not find a valid Tavern-style 'entries' object in the provided file.");
        return [];
    }

    const positionMap = {
        0: 'before_prompt',
        1: 'after_char',
        2: 'before_char'
    };

    for (const key in entriesSource) {
        const tavernEntry = entriesSource[key];
        const internalEntry = {
            id: tavernEntry.order || parseInt(key, 10) || 0,
            keys: tavernEntry.keys || tavernEntry.key || [],
            secondary_keys: tavernEntry.keysecondary || tavernEntry.secondary_keys || [],
            comment: tavernEntry.name || tavernEntry.comment || '',
            content: tavernEntry.content || '',
            priority: tavernEntry.order || 100,
            enabled: tavernEntry.disable !== undefined ? !tavernEntry.disable : (tavernEntry.enabled !== undefined ? tavernEntry.enabled : true),
            constant: tavernEntry.constant || false,
            selective: tavernEntry.selective || false,
            prevent_recursion: tavernEntry.excludeRecursion || false,
            position: positionMap[tavernEntry.position] || 'before_char',
            secondary_keys_logic: 'any',
            use_regex: tavernEntry.use_regex || false,
            group: tavernEntry.group || '',
            scope: 'chat',
            probability: tavernEntry.probability !== undefined ? tavernEntry.probability : 100,
            wb_depth: tavernEntry.depth || 4,
            match_whole_words: tavernEntry.match_whole_words || false,
            case_sensitive: tavernEntry.case_sensitive || false,
            children: []
        };
        internalEntries.push(internalEntry);
    }
    
    internalEntries.sort((a, b) => a.id - b.id);
    internalEntries.forEach((entry, index) => {
        entry.id = index;
    });
    return internalEntries;
}


window.onload = function() {
    // æ˜¾ç¤ºåŠ è½½åŠ¨ç”»
    const loadingOverlay = document.getElementById('loading-overlay');
    loadingOverlay.style.display = 'flex';
    
    // å»¶è¿Ÿåˆå§‹åŒ–ï¼Œç»™ç”¨æˆ·çœ‹åˆ°åŠ è½½åŠ¨ç”»çš„æ—¶é—´
    setTimeout(() => {
        loadApiKey();
        initializeDatabase();
        // åˆå§‹åŒ–loverå¼€å…³çš„äº‹ä»¶ç›‘å¬
        initializeLoverSwitch();
        // åˆå§‹åŒ–åå­—ç”Ÿæˆå™¨ Modal çš„äº‹ä»¶
        initializeNameGeneratorModal();
        
        // åˆå§‹åŒ–è¯­è¨€è®¾ç½®
        const savedLanguage = localStorage.getItem('language') || 'zh';
        switchLanguage(savedLanguage);
        
        // éšè—åŠ è½½åŠ¨ç”»
        loadingOverlay.style.display = 'none';
    }, 1000);
};

function initializeDatabase() {
    const dbTimeout = setTimeout(() => {
        if (!db) {
            console.warn('Database connection timeout');
        }
    }, 7000);

    const request = indexedDB.open('CharacterDB', 2);

    request.onupgradeneeded = event => {
        const tempDb = event.target.result;
        if (!tempDb.objectStoreNames.contains('characters')) {
            const objectStore = tempDb.createObjectStore('characters', { keyPath: 'id', autoIncrement: true });
            objectStore.createIndex('name', 'name', { unique: false });
            objectStore.createIndex('lastUsed', 'lastUsed', { unique: false });
        }
    };

    request.onsuccess = event => {
        clearTimeout(dbTimeout);
        db = event.target.result;
        console.log(currentLanguage === 'zh' ? "æ•°æ®åº“å·²å‡†å¤‡å°±ç»ªã€‚" : "Database ready.");
        showLibraryView();
    };

    request.onerror = event => {
        clearTimeout(dbTimeout);
        console.error(currentLanguage === 'zh' ? "æ•°æ®åº“è¿æ¥å¤±è´¥ (onerror):" : "Database connection failed (onerror):", event.target.error);
        console.warn(t('db-error', { error: event.target.error }));
    };

    request.onblocked = event => {
        clearTimeout(dbTimeout);
        console.warn(currentLanguage === 'zh' ? "æ•°æ®åº“è¿æ¥è¢«é˜»å¡ (onblocked)ã€‚æ—§ç‰ˆæœ¬å¯èƒ½åœ¨å…¶ä»–æ ‡ç­¾é¡µä¸­æ‰“å¼€ã€‚" : "Database connection blocked (onblocked). Old version may be open in other tabs.");
        console.warn(t('db-blocked'));
    };
}

function checkDbReady() {
    if (!db) {
        console.warn(t('db-not-ready'));
        return false;
    }
    return true;
}

function loadApiKey() {
    const savedKey = localStorage.getItem('deepseekApiKey');
    if (savedKey) {
        document.getElementById('apiKey').value = savedKey;
    }
}

// --- View Management ---
function showLibraryView() {
    if (!checkDbReady()) return;
    editorView.style.display = 'none';
    libraryView.style.display = 'block';
    renderUI();
}

function showEditorView(characterId = null) {
    if (!checkDbReady()) return;
    
    libraryView.style.display = 'none';
    editorView.style.display = 'flex';
    clearEditorForm();

    if (characterId) {
        document.getElementById('editor-title').innerText = t('edit-character');
        const transaction = db.transaction(['characters'], 'readonly');
        const store = transaction.objectStore('characters');
        const request = store.get(characterId);
        
        request.onsuccess = e => {
            const charData = e.target.result;
            if (charData) {
                populateEditorForm(charData);
            }
        };
    } else {
        document.getElementById('editor-title').innerText = t('create-new-character');
        renderWorldbookFromData([]);
        document.getElementById('avatar-preview').src = createDefaultImage('2:3');
    }
    // ç¡®ä¿æ¯æ¬¡è¿›å…¥ç¼–è¾‘å™¨æ—¶ï¼ŒæŒ‰é’®æ–‡æœ¬éƒ½æ ¹æ®å¼€å…³çŠ¶æ€åˆ·æ–°
    toggleAiButtonText(document.getElementById('lover-switch').checked);
}

// --- Import / Export ---
function importCharacter(event) {
    if (!checkDbReady()) return;

    const files = event.target.files;
    if (!files.length) return;

    for (const file of files) {
        if (file.type === "image/png") {
            const readAsBuffer = file.arrayBuffer();
            const readAsDataURL = new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => reject(reader.error);
                reader.readAsDataURL(file);
            });

            Promise.all([readAsBuffer, readAsDataURL]).then(async ([buffer, dataUrl]) => {
                try {
                    const charData = await extractDataFromPng(buffer);
                    const pngDataUrl = await convertImageToPng(dataUrl);
                    saveImportedCharacter(charData, pngDataUrl);
                } catch (err) {
                    console.error(currentLanguage === 'zh' ? "PNGå¯¼å…¥é”™è¯¯:" : "PNG import error:", err);
                    alert(t('import-png-failed', { error: err.message || (currentLanguage === 'zh' ? 'æœªçŸ¥é”™è¯¯ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°ã€‚' : 'Unknown error, please check console.') }));
                }
            }).catch(err => {
                 alert(t('file-read-error-with-name', { name: file.name, error: err }));
            });

        } else if (file.type === "image/png" || file.type === "image/jpeg" || file.type === "image/jpg" || file.type === "image/webp" || file.type === "image/gif" || file.type === "image/bmp") {
            // å¤„ç†å„ç§å›¾ç‰‡æ ¼å¼
            const readAsDataURL = new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => reject(reader.error);
                reader.readAsDataURL(file);
            });

            readAsDataURL.then(async (dataUrl) => {
                try {
                    // å°†ä»»ä½•æ ¼å¼çš„å›¾ç‰‡è½¬æ¢ä¸ºPNGæ ¼å¼
                    const pngDataUrl = await convertImageToPng(dataUrl);
                    // åˆ›å»ºä¸€ä¸ªæ¨¡æ‹Ÿçš„è§’è‰²æ•°æ®å¯¹è±¡
                    const charData = {
                        spec: 'chara_card_v3',
                        data: {
                            name: file.name.replace(/\.[^/.]+$/, ""), // ä½¿ç”¨æ–‡ä»¶åä½œä¸ºè§’è‰²å
                            description: t('imported-character'),
                            personality: '',
                            scenario: '',
                            first_mes: '',
                            mes_example: '',
                            system_prompt: '',
                            post_history_instructions: '',
                            tags: [],
                            character_book: { entries: [] }
                        }
                    };
                    saveImportedCharacter(charData, pngDataUrl);
                } catch (err) {
                    console.error(currentLanguage === 'zh' ? "å›¾ç‰‡å¯¼å…¥é”™è¯¯:" : "Image import error:", err);
                    alert(t('import-image-failed', { error: err.message || (currentLanguage === 'zh' ? 'æœªçŸ¥é”™è¯¯ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°ã€‚' : 'Unknown error, please check console.') }));
                }
            }).catch(err => {
                alert(t('file-read-error-with-name', { name: file.name, error: err }));
            });

        } else if (file.type === "application/json") {
            const reader = new FileReader();
            reader.onload = e => {
                try {
                    const charData = JSON.parse(e.target.result);
                    saveImportedCharacter(charData, null);
                } catch (err) {
                    console.error(currentLanguage === 'zh' ? "JSONå¯¼å…¥é”™è¯¯:" : "JSON import error:", err);
                    alert(t('import-json-failed'));
                }
            };
            reader.readAsText(file);
        }
    }
    event.target.value = '';
}

/**
 * [MODIFIED] Saves an imported character card or lorebook to the database.
 * @param {object} originalCard - The parsed data from the imported file.
 * @param {string|null} avatarBase64 - The base64-encoded avatar image, if any.
 */
function saveImportedCharacter(originalCard, avatarBase64 = null) {
    if (!checkDbReady()) return;
    
    let charDataForDb;

    const isTavernLorebook = (originalCard.entries && typeof originalCard.entries === 'object' && !Array.isArray(originalCard.entries)) ||
                             (originalCard.extensions && originalCard.extensions.entries && typeof originalCard.extensions.entries === 'object' && !Array.isArray(originalCard.extensions.entries));

    if (originalCard.spec === 'chara_card_v3' && originalCard.data) {
        const data = originalCard.data;
        const extensions = data.extensions || {};
        const book = data.character_book || {};
        
        function convertV3EntryToInternal(entry) {
            const entryExt = entry.extensions || {};
            const internalEntry = {
                id: entry.id,
                keys: entry.keys || [],
                secondary_keys: entry.secondary_keys || [],
                secondary_keys_logic: entryExt.secondary_keys_logic || 'any',
                comment: entry.comment || '',
                content: entry.content || '',
                priority: entry.insertion_order || 100,
                enabled: entry.enabled,
                position: entry.position || 'before_char',
                constant: entry.constant || false,
                selective: entry.selective === undefined ? true : entry.selective,
                use_regex: entry.use_regex || false,
                prevent_recursion: entryExt.prevent_recursion || false,
                group: entryExt.group || '',
                scope: 'chat',
                display_index: entryExt.display_index || 0,
                depth: entryExt.depth || 0,
                wb_depth: entryExt.depth || 4,
                probability: entryExt.probability === undefined ? 100 : entryExt.probability,
                match_whole_words: entryExt.match_whole_words || false,
                case_sensitive: entryExt.case_sensitive || false,
                children: []
            };
            
            if (entry.children && entry.children.length > 0) {
                internalEntry.children = entry.children.map(child => convertV3EntryToInternal(child));
            }
            
            return internalEntry;
        }
        
        const internalBookEntries = (book.entries || []).map(entry => convertV3EntryToInternal(entry));

        charDataForDb = {
            name: data.name || '',
            gender: data.gender || '',
            topic: extensions.world || '',
            description: data.description || '',
            personality: data.personality || '',
            tags: data.tags || [],
            system_prompt: data.system_prompt || '',
            scenario: data.scenario || '',
            first_mes: data.first_mes || '',
            mes_example: data.mes_example || '',
            post_history_instructions: data.post_history_instructions || '',
            worldbook: internalBookEntries,
            isFavorite: extensions.fav || false,
        };

    } else if (originalCard.spec === 'chara_card_v2' && originalCard.data) {
        const data = originalCard.data;
        charDataForDb = {
            name: data.name || '',
            gender: data.gender || '',
            topic: data.topic || '',
            description: data.description || '',
            personality: data.personality || '',
            tags: Array.isArray(data.tags) ? data.tags : (typeof data.tags === 'string' ? data.tags.split(/[,ã€ï¼Œ\s]+/).map(t => t.trim()).filter(Boolean) : []),
            system_prompt: data.system_prompt || '',
            scenario: data.scenario || '',
            first_mes: data.first_mes || '',
            mes_example: data.mes_example || '',
            post_history_instructions: data.post_history_instructions || '',
            worldbook: (data.character_book && Array.isArray(data.character_book.entries)) ? data.character_book.entries : [],
        };
    } else if (isTavernLorebook) {
        // Handle SillyTavern Lorebook JSON
        console.log("Detected SillyTavern Lorebook format. Converting...");
        const internalBookEntries = convertTavernLorebookToInternal(originalCard);

        charDataForDb = {
            name: originalCard.name || t('imported-lorebook'),
            description: originalCard.description || t('lorebook-description'),
            gender: '',
            topic: '',
            personality: '',
            tags: [t('lorebook-tag')],
            system_prompt: '',
            scenario: '',
            first_mes: '',
            mes_example: '',
            post_history_instructions: '',
            worldbook: internalBookEntries,
            isFavorite: false,
        };
        console.log("Conversion complete. Processed entries:", internalBookEntries.length);
    } else {
        charDataForDb = JSON.parse(JSON.stringify(originalCard));
        charDataForDb.tags = Array.isArray(charDataForDb.tags) ? charDataForDb.tags : (typeof charDataForDb.tags === 'string' ? charDataForDb.tags.split(/[,ã€ï¼Œ\s]+/).map(t => t.trim()).filter(Boolean) : []);
        charDataForDb.personality = charDataForDb.personality || '';
        charDataForDb.worldbook = charDataForDb.worldbook || [];
    }

    charDataForDb.avatar = avatarBase64 || originalCard.avatar || null;
    charDataForDb.internalTags = charDataForDb.internalTags || [];
    charDataForDb.isFavorite = charDataForDb.isFavorite || false;
    charDataForDb.lastUsed = Date.now();

    const transaction = db.transaction(['characters'], 'readwrite');
    const store = transaction.objectStore('characters');
    const addRequest = store.add(charDataForDb);
    
    addRequest.onsuccess = () => {
        if (document.getElementById('library-view').style.display !== 'none') {
            renderUI();
        }
    };
    addRequest.onerror = (e) => {
        console.error(currentLanguage === 'zh' ? "ä¿å­˜å¯¼å…¥è§’è‰²å¤±è´¥:" : "Failed to save imported character:", e.target.error);
        alert(t('save-import-failed'));
    }
}


function downloadCharacter() {
    if (!checkDbReady()) return;
    const v3Card = buildLiveExportCard();
    const blob = new Blob([JSON.stringify(v3Card, null, 2)], { type: 'application/json' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = (v3Card.data && v3Card.data.name ? v3Card.data.name : 'character') + '.json';
    a.click();
    URL.revokeObjectURL(a.href);
}

async function downloadCharacterAsPng() {
    if (!checkDbReady()) return;
    const v3Card = buildLiveExportCard();
    const cardData = buildCardObject();
    if (!v3Card.data || !v3Card.data.name) {
        alert("è¯·è¾“å…¥è§’è‰²åä»¥ç”ŸæˆPNGè§’è‰²å¡ã€‚");
        return;
    }
    const base64Data = btoa(unescape(encodeURIComponent(JSON.stringify(v3Card))));
    const imageToUse = cardData.avatar || document.getElementById('avatar-preview').src || createDefaultImage('2:3');
    const finalPngBlob = await embedDataInPng(imageToUse, base64Data);
    const a = document.createElement('a');
    a.href = URL.createObjectURL(finalPngBlob);
    a.download = (v3Card.data.name || 'character') + '.png';
    a.click();
    URL.revokeObjectURL(a.href);
}

// --- CRUD Operations ---
function saveCharacter() {
    if (!checkDbReady()) return;

    const card = buildCardObject();
    if (!card.name) {
        alert("è¯·è¾“å…¥è§’è‰²åç§°ã€‚");
        return;
    }

    card.internalTags = card.internalTags.filter(internalTag => card.tags.includes(internalTag));

    // --- å¼€å§‹ä¿®å¤ ---
    // åˆ›å»ºä¸€ä¸ªä¸“é—¨ç”¨äºå­˜å‚¨çš„"å¹²å‡€"ç‰ˆæœ¬çš„å¡ç‰‡æ•°æ®å¯¹è±¡
    const cardForDb = { ...card };
    // ä½¿ç”¨æ–°å‡½æ•°æ¸…ç†ä¸–ç•Œä¹¦æ•°æ®ï¼Œç§»é™¤æ‰€æœ‰å¯¹DOMå…ƒç´ çš„å¼•ç”¨
    cardForDb.worldbook = cleanWorldbookForStorage(card.worldbook);
    // --- ä¿®å¤ç»“æŸ ---

    const transaction = db.transaction(['characters'], 'readwrite');
    const store = transaction.objectStore('characters');
    
    cardForDb.lastUsed = Date.now(); // ç¡®ä¿æ›´æ–°çš„æ˜¯å¹²å‡€å¯¹è±¡çš„æ—¶é—´æˆ³
    
    // å°†æ¸…ç†è¿‡çš„ã€ä¸å«DOMå…ƒç´ çš„å¯¹è±¡å­˜å…¥æ•°æ®åº“
    const request = store.put(cardForDb);

    request.onsuccess = () => {
        alert(t('character-saved', { name: card.name }));
        // å¼ºåˆ¶åˆ·æ–°UIä»¥ç¡®ä¿å¤´åƒæ­£ç¡®æ˜¾ç¤º
        setTimeout(() => {
            showLibraryView();
        }, 100);
    };
            request.onerror = (e) => {
            alert(t('save-failed'));
            console.error(currentLanguage === 'zh' ? "ä¿å­˜å¤±è´¥:" : "Save failed:", e.target.error);
        };
}

function deleteCharacter(id) {
    if (!checkDbReady()) return;
    if (confirm("ç¡®å®šè¦åˆ é™¤è¿™ä¸ªè§’è‰²å—ï¼Ÿ")) {
        const transaction = db.transaction(['characters'], 'readwrite');
        transaction.objectStore('characters').delete(id);
        transaction.oncomplete = () => {
            renderUI();
        };
    }
}

function toggleFavorite(id, event) {
    if (!checkDbReady()) return;
    event.stopPropagation();
    const transaction = db.transaction(['characters'], 'readwrite');
    const store = transaction.objectStore('characters');
    const request = store.get(id);
    request.onsuccess = e => {
        const charData = e.target.result;
        charData.isFavorite = !charData.isFavorite;
        store.put(charData);
    };
    event.target.classList.toggle('favorited');
}

function addInternalTag(id) {
    if (!checkDbReady()) return;
    const tagName = prompt("æƒ³ä¸ºè¿™ä¸ªäººç‰©åŠ ä¸ªä»€ä¹ˆæ ·çš„æ ‡ç­¾å‘¢ï¼Ÿ");
    if (tagName && tagName.trim() !== "") {
        const transaction = db.transaction(['characters'], 'readwrite');
        const store = transaction.objectStore('characters');
        const request = store.get(id);
        request.onsuccess = e => {
            const charData = e.target.result;
            const trimmedTag = tagName.trim();

            if (!charData.internalTags) charData.internalTags = [];
            if (!charData.internalTags.includes(trimmedTag)) charData.internalTags.push(trimmedTag);

            if (!Array.isArray(charData.tags)) {
                charData.tags = (typeof charData.tags === 'string' && charData.tags)
                    ? charData.tags.split(/[,ã€ï¼Œ\s]+/).map(t => t.trim()).filter(Boolean)
                    : [];
            }
            if (!charData.tags.includes(trimmedTag)) charData.tags.push(trimmedTag);

            store.put(charData);
            transaction.oncomplete = () => renderUI();
        };
    }
}

// --- UI Rendering ---
async function renderUI() {
    if (!checkDbReady()) return;
    
    const transaction = db.transaction(['characters'], 'readonly');
    const allChars = await new Promise((resolve, reject) => {
        const req = transaction.objectStore('characters').getAll();
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
    });
    allChars.sort((a,b) => (b.isFavorite - a.isFavorite) || (b.lastUsed || 0) - (a.lastUsed || 0));

    renderTags(allChars);
    renderCharacters(allChars);
}

function renderTags(characters) {
    const tagContainer = document.getElementById('tag-container');
    const internalTags = new Set();
    const extraTags = new Set(); 

    characters.forEach(char => {
        (char.internalTags || []).forEach(tag => { if (tag) internalTags.add(tag.trim()); });
        const tags = Array.isArray(char.tags) ? char.tags : (typeof char.tags === 'string' ? char.tags.split(/[,ã€ï¼Œ\s]+/) : []);
        tags.forEach(tag => { if (tag) extraTags.add(tag.trim()); });
    });

    let tagsHtml = `<div class="tag type-special ${activeFilters.has('FAVORITE') ? 'active' : ''}" onclick="toggleFilter('FAVORITE', event)">â­ æ”¶è—</div>`;
    [...extraTags].sort().forEach(tag => { tagsHtml += `<div class="tag type-personality ${activeFilters.has(tag) ? 'active' : ''}" onclick="toggleFilter('${tag}', event)">${tag}</div>`; });
    [...internalTags].sort().forEach(tag => { tagsHtml += `<div class="tag type-internal ${activeFilters.has(tag) ? 'active' : ''}" onclick="toggleFilter('${tag}', event)">${tag}</div>`; });

    tagContainer.innerHTML = tagsHtml;
}

function renderCharacters(characters) {
    const grid = document.getElementById('character-grid');
    grid.innerHTML = '';

    let filteredChars = characters;
    if (activeFilters.size > 0) {
        filteredChars = characters.filter(char => {
            if (activeFilters.has('FAVORITE') && !char.isFavorite) return false;
            
            const regularFilters = [...activeFilters].filter(f => f !== 'FAVORITE');
            if (regularFilters.length > 0) {
                const tagSet = new Set([
                    ...(Array.isArray(char.tags) ? char.tags : (typeof char.tags === 'string' ? char.tags.split(/[,ã€ï¼Œ\s]+/) : [])),
                    ...(char.internalTags || [])
                ].map(t => t.trim()));
                return regularFilters.every(filter => tagSet.has(filter));
            }
            return true;
        });
    }

    if (filteredChars.length === 0) {
        grid.innerHTML = `<p style="grid-column: 1 / -1; text-align: center;">${t('no-characters-found')}</p>`;
        return;
    }

    filteredChars.forEach(char => {
        const card = document.createElement('div');
        card.className = 'character-card';
        // å¼ºåˆ¶æ˜¾ç¤ºä»»ä½•å›¾ç‰‡æ ¼å¼ï¼ŒåŒ…æ‹¬base64ã€URLç­‰
        let imageToDisplay;
        if (char.avatar) {
            // å¦‚æœæ˜¯base64æ ¼å¼
            if (char.avatar.startsWith('data:image/')) {
                imageToDisplay = char.avatar;
            }
            // å¦‚æœæ˜¯URLæ ¼å¼
            else if (char.avatar.startsWith('http://') || char.avatar.startsWith('https://')) {
                imageToDisplay = char.avatar;
            }
            // å¦‚æœæ˜¯ç›¸å¯¹è·¯å¾„æˆ–å…¶ä»–æ ¼å¼ï¼Œä¹Ÿå°è¯•æ˜¾ç¤º
            else if (char.avatar.trim() !== '') {
                imageToDisplay = char.avatar;
            } else {
                imageToDisplay = createDefaultImage('2:3');
            }
        } else {
            imageToDisplay = createDefaultImage('2:3');
        }
        card.style.backgroundImage = `var(--card-overlay), url('${imageToDisplay}')`;
        // è°ƒè¯•ä¿¡æ¯ï¼šè¾“å‡ºå¤´åƒæ•°æ®çŠ¶æ€
        console.log(currentLanguage === 'zh' ? `è§’è‰² "${char.name}" çš„å¤´åƒæ•°æ®:` : `Character "${char.name}" avatar data:`, {
            hasAvatar: !!char.avatar,
            avatarType: char.avatar ? (char.avatar.startsWith('data:') ? 'base64' : 'url') : 'none',
            imageToDisplay: imageToDisplay.substring(0, 50) + '...'
        });
        
        const headerDiv = document.createElement('div');
        const cardHeader = document.createElement('div');
        cardHeader.className = 'card-header';
        
        const h2 = document.createElement('h2');
        h2.textContent = char.name || 'æ— åè§’è‰²';
        
        const favButton = document.createElement('button');
        favButton.className = `favorite-btn ${char.isFavorite ? 'favorited' : ''}`;
        favButton.innerHTML = 'â˜…';
        favButton.onclick = (event) => toggleFavorite(char.id, event);
        
        cardHeader.appendChild(h2);
        cardHeader.appendChild(favButton);
        
        const descriptionP = document.createElement('p');
        descriptionP.className = 'card-description';
        descriptionP.textContent = char.description || t('no-description');
        
        const tagsDiv = document.createElement('div');
        tagsDiv.className = 'card-tags tag-group';
        const tagsArray = Array.isArray(char.tags) ? char.tags : (typeof char.tags === 'string' ? char.tags.split(/[,ã€ï¼Œ\s]+/) : []);
        const personalityTagsHtml = tagsArray.filter(t => t).map(tag => `<span class="tag type-personality">${tag.trim()}</span>`).join(' ');
        const internalTagsHtml = (char.internalTags || []).filter(t => t).map(tag => `<span class="tag type-internal">${tag.trim()}</span>`).join(' ');
        tagsDiv.innerHTML = personalityTagsHtml + ' ' + internalTagsHtml;
        
        headerDiv.appendChild(cardHeader);
        headerDiv.appendChild(descriptionP);
        headerDiv.appendChild(tagsDiv);

        const footerDiv = document.createElement('div');
        footerDiv.className = 'card-footer';
        footerDiv.innerHTML = `
            <button onclick="showEditorView(${char.id})">âœï¸ ${t('edit')}</button>
            <button onclick="addInternalTag(${char.id})">ğŸ·ï¸ ${t('add-tag')}</button>
            <button onclick="deleteCharacter(${char.id})">ğŸ—‘ï¸ ${t('delete')}</button>
        `;
        
        card.appendChild(headerDiv);
        card.appendChild(footerDiv);
        grid.appendChild(card);
    });
}


function toggleFilter(filterName, event) {
    event.stopPropagation();
    const button = event.currentTarget;
    button.classList.toggle('active');
    activeFilters.has(filterName) ? activeFilters.delete(filterName) : activeFilters.add(filterName);
    renderUI();
}

// --- Editor Form Management ---
function clearEditorForm() {
    const fields = ['charId', 'name', 'description', 'personality', 'system_prompt', 'scenario', 'first_mes', 'mes_example', 'internalTags', 'isFavorite', 'originalCardData', 'topic', 'gender', 'tags', 'post_history_instructions'];
    fields.forEach(id => { 
        const el = document.getElementById(id);
        if (el) el.value = ''; 
    });
    document.querySelectorAll('.ai-undo-button').forEach(btn => btn.style.display = 'none');
    document.getElementById('worldbook-entries-container').innerHTML = '';
    document.getElementById('avatar-input').value = '';
    document.getElementById('avatar-preview').src = createDefaultImage('2:3');
    avatarImageBase64 = null;
    document.querySelector('#editor-view .editor-body').scrollTop = 0;
}

function populateEditorForm(charData) {
    document.getElementById('charId').value = charData.id || '';
    document.getElementById('name').value = charData.name || '';
    document.getElementById('gender').value = charData.gender || '';
    document.getElementById('topic').value = charData.topic || '';
    document.getElementById('description').value = charData.description || '';
    document.getElementById('tags').value = Array.isArray(charData.tags) ? charData.tags.join(', ') : (typeof charData.tags === 'string' ? charData.tags : '');
    document.getElementById('personality').value = charData.personality || '';
    document.getElementById('system_prompt').value = charData.system_prompt || '';
    document.getElementById('scenario').value = charData.scenario || '';
    document.getElementById('first_mes').value = charData.first_mes || '';
    document.getElementById('mes_example').value = charData.mes_example || '';
    document.getElementById('post_history_instructions').value = charData.post_history_instructions || '';
    document.getElementById('internalTags').value = JSON.stringify(charData.internalTags || []);
    document.getElementById('isFavorite').value = charData.isFavorite || false;
    
    renderWorldbookFromData(charData.worldbook || []);

    if (charData.avatar) {
        // å¼ºåˆ¶æ˜¾ç¤ºä»»ä½•å›¾ç‰‡æ ¼å¼
        if (charData.avatar.startsWith('data:image/')) {
            document.getElementById('avatar-preview').src = charData.avatar;
            avatarImageBase64 = charData.avatar;
        } else if (charData.avatar.startsWith('http://') || charData.avatar.startsWith('https://')) {
            document.getElementById('avatar-preview').src = charData.avatar;
            avatarImageBase64 = charData.avatar;
        } else if (charData.avatar.trim() !== '') {
            document.getElementById('avatar-preview').src = charData.avatar;
            avatarImageBase64 = charData.avatar;
        } else {
            document.getElementById('avatar-preview').src = createDefaultImage('2:3');
            avatarImageBase64 = null;
        }
    } else {
        document.getElementById('avatar-preview').src = createDefaultImage('2:3');
        avatarImageBase64 = null;
    }
    document.querySelectorAll('.ai-undo-button').forEach(btn => btn.style.display = 'none');
    document.querySelector('#editor-view .editor-body').scrollTop = 0;
}

document.getElementById('avatar-input').addEventListener('change', function(event) {
    const file = event.target.files[0];
    if (!file) return;

    if (!file.type.startsWith("image/")) {
        alert(t('upload-image-only'));
        event.target.value = '';
        return;
    }

    const reader = new FileReader();
    reader.onload = async function(e) {
        try {
            // å°†ä»»ä½•æ ¼å¼çš„å›¾ç‰‡è½¬æ¢ä¸ºPNGæ ¼å¼
            const pngDataUrl = await convertImageToPng(e.target.result);
            avatarImageBase64 = pngDataUrl;
            document.getElementById('avatar-preview').src = pngDataUrl;
            console.log(currentLanguage === 'zh' ? 'å¤´åƒå·²è½¬æ¢ä¸ºPNGæ ¼å¼:' : 'Avatar converted to PNG format:', pngDataUrl.substring(0, 50) + '...');
        } catch (error) {
            console.error(currentLanguage === 'zh' ? 'å›¾ç‰‡è½¬æ¢å¤±è´¥:' : 'Image conversion failed:', error);
            alert(t('image-process-failed', { error: error.message }));
            event.target.value = '';
        }
    };
    reader.onerror = function() {
        alert(t('file-read-error'));
        event.target.value = '';
    };
    reader.readAsDataURL(file);
});

// ç”¨äºåœ¨ä¿å­˜åˆ°æ•°æ®åº“å‰ï¼Œæ¸…ç†ä¸–ç•Œä¹¦æ•°æ®ä¸­çš„DOMå…ƒç´ å¼•ç”¨
function cleanWorldbookForStorage(entries) {
    if (!entries) return [];
    return entries.map(entry => {
        // åˆ›å»ºä¸€ä¸ªä¸åŒ…å« 'element' å±æ€§çš„æ–°å¯¹è±¡
        const { element, ...cleanedEntry } = entry;

        // å¯¹å­æ¡ç›®è¿›è¡Œé€’å½’æ¸…ç†
        if (entry.children && entry.children.length > 0) {
            cleanedEntry.children = cleanWorldbookForStorage(entry.children);
        }
        return cleanedEntry;
    });
}

// --- Object Building ---
function buildCardObject() {
    const worldbookData = buildWorldbookDataFromDOM();
    
    const card = {
        name: document.getElementById('name').value.trim(),
        gender: document.getElementById('gender').value.trim(),
        topic: document.getElementById('topic').value.trim(),
        description: document.getElementById('description').value.trim(),
        personality: document.getElementById('personality').value.trim(),
        tags: document.getElementById('tags').value.trim().split(/[,ã€ï¼Œ\s]+/).map(t => t.trim()).filter(Boolean),
        system_prompt: document.getElementById('system_prompt').value.trim(),
        scenario: document.getElementById('scenario').value.trim(),
        first_mes: document.getElementById('first_mes').value.trim(),
        mes_example: document.getElementById('mes_example').value.trim(),
        post_history_instructions: document.getElementById('post_history_instructions').value.trim(),
        internalTags: JSON.parse(document.getElementById('internalTags').value || '[]'),
        isFavorite: (document.getElementById('isFavorite').value === 'true'),
        avatar: avatarImageBase64 || document.getElementById('avatar-preview').src || null,
        worldbook: worldbookData
    };
    const charId = parseInt(document.getElementById('charId').value, 10);
    if (!isNaN(charId)) card.id = charId;
    
    return card;
}


function buildLiveExportCard() {
    const currentCardState = buildCardObject();
    return buildV3Card(currentCardState);
}

function buildV3Card(cardData) {
    // é€’å½’å‡½æ•°ï¼šå°†æ¡ç›®åŠå…¶å­æ¡ç›®è½¬æ¢ä¸ºV3æ ¼å¼
    function convertEntryToV3(entry) {
        const v3Entry = {
            id: entry.id,
            keys: entry.keys || [],
            secondary_keys: entry.secondary_keys || [],
            comment: entry.comment || '',
            content: entry.content || '',
            constant: entry.constant || false,
            selective: entry.selective === undefined ? true : entry.selective,
            insertion_order: entry.priority || 100,
            enabled: entry.enabled === undefined ? true : entry.enabled,
            position: entry.position || 'before_char',
            use_regex: entry.use_regex || false,
            extensions: {
                position: 0,
                exclude_recursion: false,
                display_index: entry.display_index,
                probability: entry.probability === undefined ? 100 : entry.probability,
                useProbability: true,
                depth: entry.wb_depth || 4,
                selectiveLogic: 0,
                group: entry.group || "",
                group_override: false,
                group_weight: 100,
                prevent_recursion: entry.prevent_recursion || false,
                delay_until_recursion: false,
                scan_depth: null,
                match_whole_words: entry.match_whole_words || null,
                use_group_scoring: false,
                case_sensitive: entry.case_sensitive || null,
                automation_id: "",
                role: 0,
                vectorized: false,
                sticky: 0,
                cooldown: 0,
                delay: 0,
                secondary_keys_logic: entry.secondary_keys_logic || 'any'
            }
        };
        
        // é€’å½’å¤„ç†å­æ¡ç›®
        if (entry.children && entry.children.length > 0) {
            v3Entry.children = entry.children.map(child => convertEntryToV3(child));
        }
        
        return v3Entry;
    }
    
    const v3BookEntries = (cardData.worldbook || []).map(entry => convertEntryToV3(entry));

    const dataObject = {
        name: cardData.name || '',
        description: cardData.description || '',
        personality: cardData.personality || '',
        scenario: cardData.scenario || '',
        first_mes: cardData.first_mes || '',
        mes_example: cardData.mes_example || '',
        creator_notes: 'Created with Nika Character Studio',
        system_prompt: cardData.system_prompt || '',
        post_history_instructions: cardData.post_history_instructions || '',
        tags: cardData.tags || [],
        creator: 'Nika Studio User',
        character_version: '1.0',
        alternate_greetings: [],
        group_only_greetings: [],
        extensions: {
            talkativeness: "0.5",
            fav: cardData.isFavorite || false,
            world: cardData.topic || '',
            depth_prompt: { prompt: "", depth: 4, role: "system" }
        },
        character_book: {
            name: `(ä¸–ç•Œä¹¦) ${cardData.name || 'Character Book'}`,
            description: `Character book for ${cardData.name}.`,
            scan_depth: 10,
            token_budget: 2048,
            recursive_scanning: false,
            entries: v3BookEntries,
        },
    };

    return {
        spec: 'chara_card_v3',
        spec_version: '3.0',
        name: dataObject.name,
        description: dataObject.description,
        personality: dataObject.personality,
        scenario: dataObject.scenario,
        first_mes: dataObject.first_mes,
        mes_example: dataObject.mes_example,
        creatorcomment: dataObject.creator_notes,
        tags: dataObject.tags,
        create_date: new Date().toISOString(),
        avatar: "none",
        talkativeness: "0.5",
        fav: dataObject.extensions.fav,
        data: dataObject,
    };
}


// ====================================================================================
// --- LOVER & AI HELPER FUNCTIONS ---
// ====================================================================================

function initializeLoverSwitch() {
    const loverSwitch = document.getElementById('lover-switch');
    if (loverSwitch) {
        loverSwitch.addEventListener('change', (event) => {
            toggleAiButtonText(event.target.checked);
        });
    }
}

function toggleAiButtonText(isLover) {
    const aiButtons = document.querySelectorAll('.ai-button');
    const newText = isLover ? t('generate-companion') : t('ai-help-write');
    aiButtons.forEach(button => {
        button.textContent = newText;
    });
}

function getLoverPromptPrefix() {
    return `é‡è¦æŒ‡ä»¤ï¼šä½ æ˜¯ä¸€ä¸ªå°è¯´è§’è‰²åˆ›ä½œå®¶ï¼Œä½ è¦ç”Ÿæˆçš„è§’è‰²æŠŠè¯»è€…å½“æ‹äººæˆ–è€…å¯†å‹ï¼Œå¹¶ä¸”è¯»è€…çš„ä»£è¯ä¸º"{{user}}"ï¼Œè§’è‰²çš„ä»£è¯ä¸º"{{char}}ï¼Œç”Ÿæˆç›¸å…³è§’è‰²çš„ä¿¡æ¯\n\n`;
}

// æ–°å¢: æ’¤é”€AIè¡¥å…¨çš„åŠŸèƒ½
function undoAiCompletion(undoButton) {
    const container = undoButton.closest('.field-group');
    if (!container) return;

    const targetElement = container.querySelector('textarea, input:not([type=file]):not([type=checkbox])');
    if (targetElement && targetElement.dataset.aiBackup !== undefined) {
        targetElement.value = targetElement.dataset.aiBackup;
        delete targetElement.dataset.aiBackup; // æ¸…é™¤å¤‡ä»½
        undoButton.style.display = 'none'; // éšè—è‡ªå·±
    }
}


async function callApi(prompt, button) {
    const apiKey = document.getElementById('apiKey').value.trim();
    if (!apiKey) {
        alert(t('api-key-placeholder'));
        return null;
    }

    const isLover = document.getElementById('lover-switch').checked;
    const finalPrompt = isLover ? getLoverPromptPrefix() + prompt : prompt;

    console.log(currentLanguage === 'zh' ? "å‘é€ç»™APIçš„æœ€ç»ˆæç¤º:" : "Final prompt being sent to API:", finalPrompt);

    const originalText = button.textContent;
    button.disabled = true;
    button.textContent = t('generating');

    // éšè—å¯¹åº”çš„æ’¤é”€æŒ‰é’®ï¼ˆå¦‚æœå®ƒæ­£æ˜¾ç¤ºï¼‰
    const undoButton = button.nextElementSibling;
    if (undoButton && undoButton.classList.contains('ai-undo-button')) {
        undoButton.style.display = 'none';
    }


    try {
        const response = await fetch("https://api.deepseek.com/chat/completions", {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({ model: "deepseek-chat", messages: [{ "role": "user", "content": finalPrompt }] })
        });

        if (!response.ok) {
            const errorBody = await response.json();
            throw new Error(t('api-request-failed', { status: response.statusText, message: errorBody.error.message }));
        }

        const data = await response.json();
        return data.choices[0].message.content;
    } catch (error) {
        console.error(currentLanguage === 'zh' ? "DeepSeek APIé”™è¯¯:" : "DeepSeek API error:", error);
        alert(t('ai-completion-failed'));
        return null;
    } finally {
        button.disabled = false;
        button.textContent = originalText;
    }
}
async function callDeepSeek(fieldId) {
    const button = event.target;
    const targetElement = document.getElementById(fieldId);
    if (!targetElement) return;

    // å¤‡ä»½å½“å‰æ–‡æœ¬
    targetElement.dataset.aiBackup = targetElement.value;

    const currentCard = buildCardObject();
    const labelText = document.querySelector(`label[for='${fieldId}']`).innerText.replace(' (é€—å·åˆ†éš”)','');
    let prompt = `ä½ æ˜¯ä¸€ä½ä¸“ä¸šçš„è§’è‰²è®¾å®šå¸ˆã€‚è¯·æ ¹æ®ä»¥ä¸‹å·²ç»æä¾›çš„è§’è‰²ä¿¡æ¯ï¼Œä¸ºæˆ‘ç”Ÿæˆæˆ–è¡¥å…¨ã€${labelText}ã€‘è¿™ä¸€é¡¹ã€‚
è¯·ç›´æ¥è¿”å›æœ€é€‚åˆå¡«å…¥è¯¥é¡¹çš„å†…å®¹ï¼Œè¯­è¨€é£æ ¼è¦è‡ªç„¶ï¼Œä¸è¦åŒ…å«ä»»ä½•é¢å¤–è§£é‡Šã€æ ‡é¢˜æˆ–æ ‡ç­¾ã€‚

å·²æä¾›ä¿¡æ¯:
- ä¸»é¢˜/ä¸–ç•Œè§‚: ${currentCard.topic || 'æœªæŒ‡å®š'}
- è§’è‰²å: ${currentCard.name || 'æœªæŒ‡å®š'}
- æ€§åˆ«: ${currentCard.gender || 'æœªæŒ‡å®š'}
- è§’è‰²æè¿°: ${currentCard.description || 'æœªæŒ‡å®š'}
- åˆ†ç±»æ ‡ç­¾: ${(currentCard.tags && currentCard.tags.length > 0) ? currentCard.tags.join(', ') : 'æœªæŒ‡å®š'}
- ä¸ªæ€§: ${currentCard.personality || 'æœªæŒ‡å®š'}
- åœºæ™¯è®¾å®š: ${currentCard.scenario || 'æœªæŒ‡å®š'}
- é¦–æ¬¡å‘è¨€: ${currentCard.first_mes || 'æœªæŒ‡å®š'}
- èŒƒä¾‹å¯¹è¯: ${currentCard.mes_example || 'æœªæŒ‡å®š'}

ç°åœ¨ï¼Œè¯·ç”Ÿæˆã€${labelText}ã€‘çš„å†…å®¹ã€‚`;
    
    const result = await callApi(prompt, button);
    if (result) {
        targetElement.value = result;
        // æ˜¾ç¤ºæ’¤é”€æŒ‰é’®
        const undoButton = button.nextElementSibling;
        if (undoButton && undoButton.classList.contains('ai-undo-button')) {
            undoButton.style.display = 'inline-block';
        }
    }
}
async function generateFullWorldbook(button) {
    if (!confirm(t('confirm-overwrite-worldbook'))) return;

    const characterContext = buildCardObject();
    let prompt = `ä½ æ˜¯ä¸€ä½ä¸“ä¸šçš„AIè§’è‰²æ‰®æ¼”è§’è‰²ä¹¦ï¼ˆCharacter Bookï¼‰æ¶æ„å¸ˆã€‚è¯·åˆ†æä»¥ä¸‹è§’è‰²è®¾å®šï¼Œå¹¶ä¸ºè¯¥è§’è‰²åˆ›å»º3åˆ°5ä¸ªæœ€æ ¸å¿ƒã€æœ€èƒ½å¢å¼ºè§’è‰²æ‰®æ¼”æ·±åº¦çš„è§’è‰²ä¹¦æ¡ç›®ã€‚

**è§’è‰²è®¾å®š:**
- è§’è‰²å: ${characterContext.name || 'æœªæŒ‡å®š'}
- æ€§åˆ«: ${characterContext.gender || 'æœªæŒ‡å®š'}
- ä¸»é¢˜/ä¸–ç•Œè§‚: ${characterContext.topic || 'æœªæŒ‡å®š'}
- è§’è‰²æè¿°: ${characterContext.description || 'æœªæŒ‡å®š'}
- ä¸ªæ€§: ${characterContext.personality || 'æœªæŒ‡å®š'}ï¼ˆé€—å·åˆ†éš”ï¼‰
- åœºæ™¯è®¾å®š: ${characterContext.scenario || 'æœªæŒ‡å®š'}

**ä½ çš„ä»»åŠ¡:**
1. è¯†åˆ«å‡ºè§’è‰²èƒŒæ™¯ä¸­æœ€é‡è¦çš„æ¦‚å¿µã€äººç‰©ã€åœ°ç‚¹ã€ç‰©å“æˆ–å…³é”®èƒ½åŠ›ã€‚
2. ä¸ºè¿™äº›æ¦‚å¿µåˆ›å»ºè§’è‰²ä¹¦æ¡ç›®ã€‚
3. **ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹JSONæ ¼å¼è¿”å›ä½ çš„ç­”æ¡ˆï¼Œä¸è¦åŒ…å«ä»»ä½•JSONæ ¼å¼ä¹‹å¤–çš„é¢å¤–æ–‡å­—ã€è§£é‡Šæˆ–Markdownæ ‡è®°ã€‚**

**JSONæ ¼å¼è¦æ±‚:**
è¿”å›ä¸€ä¸ªJSONæ•°ç»„ï¼Œå…¶ä¸­æ¯ä¸ªå¯¹è±¡ä»£è¡¨ä¸€ä¸ªæ¡ç›®ï¼Œä¸”å¿…é¡»åŒ…å« "id" (æ•°å­—), "keys" (å­—ç¬¦ä¸²æ•°ç»„), "content" (å­—ç¬¦ä¸²), å’Œ "comment" (å­—ç¬¦ä¸²) å››ä¸ªé”®ã€‚"id" ä»0å¼€å§‹é€’å¢ã€‚`;

    const result = await callApi(prompt, button);
    if (result) {
        try {
            const cleanedResult = result.replace(/^```json\s*|```$/g, '');
            const generatedEntries = JSON.parse(cleanedResult);
            
            if (Array.isArray(generatedEntries)) {
                renderWorldbookFromData(generatedEntries);
                alert(t('worldbook-generated-success'));
            } else {
                throw new Error(t('ai-return-not-array'));
            }
        } catch (e) {
            console.error(currentLanguage === 'zh' ? "è§£æAIè¿”å›çš„JSONå¤±è´¥:" : "Failed to parse AI returned JSON:", e);
            console.error(currentLanguage === 'zh' ? "æ”¶åˆ°çš„åŸå§‹æ•°æ®:" : "Received raw data:", result);
            alert(t('ai-parse-failed'));
        }
    }
}
async function callWorldbookDeepSeek(button) {
    const currentEntryElement = button.closest('.worldbook-entry');
    const targetElement = currentEntryElement.querySelector('.wb-content');
    if (!targetElement) return;

    // å¤‡ä»½å½“å‰æ–‡æœ¬
    targetElement.dataset.aiBackup = targetElement.value;

    const characterContext = buildCardObject(); 
    const currentComment = currentEntryElement.querySelector('.entry-comment').value || 'æœªå‘½åæ¡ç›®';
    const currentKeys = currentEntryElement.querySelector('.wb-keys').value;
    let prompt = `ä½ æ˜¯ä¸€ä½ä¸“ä¸šçš„è§’è‰²ä¹¦ï¼ˆCharacter Bookï¼‰å†…å®¹å¡«å……ä¸“å®¶ã€‚è¯·åŸºäºä»¥ä¸‹æä¾›çš„è§’è‰²ä¿¡æ¯å’Œè§’è‰²ä¹¦ç»“æ„ï¼Œä¸ºæˆ‘æ’°å†™æ¡ç›®ã€${currentComment}ã€‘çš„"æ³¨å…¥å†…å®¹"ã€‚å†…å®¹éœ€è¦è¯¦ç»†ã€å¯Œæœ‰æƒ³è±¡åŠ›ï¼Œå¹¶ä¸è§’è‰²è®¾å®šä¿æŒé«˜åº¦ä¸€è‡´ã€‚

---
**è§’è‰²æ ¸å¿ƒè®¾å®š:**
- è§’è‰²å: ${characterContext.name || 'æœªæŒ‡å®š'}
- æè¿°: ${characterContext.description || 'æœªæŒ‡å®š'}
- ä¸ªæ€§: ${characterContext.personality || 'æœªæŒ‡å®š'}

**è§’è‰²ä¹¦ä¸Šä¸‹æ–‡:**
- **å½“å‰æ¡ç›®æ ‡é¢˜ (Comment):** ${currentComment}
- **å½“å‰æ¡ç›®ä¸»è¦å…³é”®è¯ (Keys):** ${currentKeys || 'æœªæŒ‡å®š'}

---
**ä½ çš„ä»»åŠ¡:**
ç°åœ¨ï¼Œè¯·ä¸ºæ¡ç›®ã€${currentComment}ã€‘ç”Ÿæˆè¯¦ç»†çš„"æ³¨å…¥å†…å®¹"ã€‚
**è¦æ±‚ï¼š** ç›´æ¥è¿”å›å†…å®¹æœ¬èº«ï¼Œä¸è¦åŒ…å«ä»»ä½•é¢å¤–è§£é‡Šã€æ ‡é¢˜æˆ–å¼•ç”¨ã€‚`;

    const result = await callApi(prompt, button);
    if (result) {
        targetElement.value = result;
        // æ˜¾ç¤ºæ’¤é”€æŒ‰é’®
        const undoButton = button.nextElementSibling;
        if (undoButton && undoButton.classList.contains('ai-undo-button')) {
            undoButton.style.display = 'inline-block';
        }
    }
}

// ====================================================================================
// --- NEW AI NAME GENERATOR ---
// ====================================================================================

function initializeNameGeneratorModal() {
    const modal = document.getElementById('name-generator-modal');
    const cancelButton = document.getElementById('cancel-name-generation-btn');
    const regenerateButton = document.getElementById('regenerate-names-btn');

    // ç‚¹å‡»èƒŒæ™¯å…³é—­
    modal.addEventListener('click', (event) => {
        if (event.target === modal) {
            modal.style.display = 'none';
        }
    });
    // å–æ¶ˆæŒ‰é’®
    cancelButton.addEventListener('click', () => {
        modal.style.display = 'none';
    });
    // é‡æ–°ç”ŸæˆæŒ‰é’®
    regenerateButton.addEventListener('click', (event) => {
        const generatorButton = document.querySelector('.name-generator-btn'); // æ‰¾åˆ°åŸå§‹è§¦å‘æŒ‰é’®
        generateAiNames(generatorButton);
    });
}

async function generateAiNames(button) {
    const modal = document.getElementById('name-generator-modal');
    const optionsContainer = document.getElementById('name-options-container');
    const regenerateButton = document.getElementById('regenerate-names-btn');
    
    // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
    optionsContainer.innerHTML = `<div class="loading-spinner" style="margin: 20px auto;"></div>`;
    modal.style.display = 'flex';

    const currentCard = buildCardObject();
    const prompt = `ä½ æ˜¯ä¸€ä½å¯Œæœ‰åˆ›é€ åŠ›çš„å‘½åå¤§å¸ˆã€‚è¯·æ ¹æ®ä»¥ä¸‹è§’è‰²è®¾å®šï¼Œä¸ºè§’è‰²ç”Ÿæˆ5ä¸ªå¥½å¬ã€è´´åˆ‡çš„åå­—ã€‚
è¯·ä¸¥æ ¼æŒ‰ç…§JSONæ•°ç»„çš„æ ¼å¼è¿”å›ï¼Œä¾‹å¦‚ï¼š["åå­—A", "åå­—B", "åå­—C", "åå­—D", "åå­—E"]ã€‚ä¸è¦åŒ…å«ä»»ä½•é¢å¤–çš„è§£é‡Šæˆ–æ–‡æœ¬ã€‚

è§’è‰²è®¾å®š:
- ä¸»é¢˜/ä¸–ç•Œè§‚: ${currentCard.topic || 'æœªæŒ‡å®š'}
- æ€§åˆ«: ${currentCard.gender || 'æœªæŒ‡å®š'}
- è§’è‰²æè¿°: ${currentCard.description || 'æœªæŒ‡å®š'}
- ä¸ªæ€§: ${currentCard.personality || 'æœªæŒ‡å®š'}`;

    const originalRegenerateText = regenerateButton.textContent;
    regenerateButton.disabled = true;
    regenerateButton.textContent = t('generating');

    try {
        const result = await callApi(prompt, button); // ä½¿ç”¨åŸå§‹æŒ‰é’®æ¥æ˜¾ç¤ºä¸»ç¼–è¾‘é¡µçš„åŠ è½½çŠ¶æ€
        if (result) {
            const cleanedResult = result.replace(/^```json\s*|```$/g, '').trim();
            const names = JSON.parse(cleanedResult);

            if (Array.isArray(names) && names.length > 0) {
                optionsContainer.innerHTML = ''; // æ¸…ç©ºåŠ è½½åŠ¨ç”»
                names.forEach(name => {
                    const nameButton = document.createElement('button');
                    nameButton.textContent = name;
                    nameButton.onclick = () => {
                        document.getElementById('name').value = name;
                        modal.style.display = 'none';
                    };
                    optionsContainer.appendChild(nameButton);
                });
            } else {
                throw new Error("AI did not return a valid array of names.");
            }
        } else {
            optionsContainer.innerHTML = `<p>${t('name-generation-failed')}</p>`;
        }
    } catch (e) {
        console.error("Failed to parse AI-generated names:", e);
        console.error("Raw response:", result);
        optionsContainer.innerHTML = `<p>${t('name-generation-failed')}</p>`;
    } finally {
        regenerateButton.disabled = false;
        regenerateButton.textContent = originalRegenerateText;
    }
}


// ====================================================================================
// --- REFACTORED WORLD BOOK MANAGEMENT (DATA-DRIVEN APPROACH) ---
// ====================================================================================

// [æ–°åŠŸèƒ½] æ–°å¢çš„è¾…åŠ©å‡½æ•°ï¼Œç”¨äºåœ¨æ•°æ®ç»“æ„ä¸­æŸ¥æ‰¾æ¡ç›®
function findEntryRecursive(list, elementToFind, parent = null) {
    for (let i = 0; i < list.length; i++) {
        const item = list[i];
        if (item.element === elementToFind) {
            return {
                entry: item,
                parentList: list,
                index: i,
                parentEntry: parent
            };
        }
        if (item.children && item.children.length > 0) {
            const found = findEntryRecursive(item.children, elementToFind, item);
            if (found) {
                return found;
            }
        }
    }
    return null;
}

function parseEntryFromElement(element) {
    return {
        id: parseInt(element.querySelector('.wb-sort-id').value, 10) || 0,
        keys: element.querySelector('.wb-keys').value.split(/[,ã€ï¼Œ\s]+/).map(k => k.trim()).filter(Boolean),
        secondary_keys: element.querySelector('.wb-secondary-keys').value.split(/[,ã€ï¼Œ\s]+/).map(k => k.trim()).filter(Boolean),
        secondary_keys_logic: element.querySelector('.wb-secondary-keys-logic').value,
        comment: element.querySelector('.entry-comment').value,
        content: element.querySelector('.wb-content').value,
        priority: parseInt(element.querySelector('.wb-priority').value, 10) || 100,
        enabled: element.querySelector('.wb-enabled').checked,
        prevent_recursion: element.querySelector('.wb-prevent-recursion').checked,
        group: element.querySelector('.wb-group').value.trim(),
        position: element.querySelector('.wb-position').value,
        scope: element.querySelector('.wb-scope').value,
        constant: element.querySelector('.wb-constant').checked,
        selective: element.querySelector('.wb-selective').checked,
        use_regex: element.querySelector('.wb-use-regex').checked,
        match_whole_words: element.querySelector('.wb-match-whole-words').checked,
        case_sensitive: element.querySelector('.wb-case-sensitive').checked,
        probability: parseInt(element.querySelector('.wb-probability').value, 10),
        wb_depth: parseInt(element.querySelector('.wb-depth').value, 10) || 4,
        element: element,
        children: []
    };
}

function buildWorldbookDataFromDOM(parentElement = document.getElementById('worldbook-entries-container')) {
    const entries = [];
    const childElements = Array.from(parentElement.children);

    for (const el of childElements) {
        if (el.matches('li.worldbook-entry')) {
            const entryData = parseEntryFromElement(el);
            const childContainer = el.querySelector('.child-entries');
            if (childContainer && childContainer.children.length > 0) {
                entryData.children = buildWorldbookDataFromDOM(childContainer);
            }
            entries.push(entryData);
        }
    }
    return entries;
}

function renderWorldbookFromData(data) {
    const container = document.getElementById('worldbook-entries-container');
    container.innerHTML = ''; 

    function renderLevel(entries, parentElement) {
        entries.forEach(entryData => {
            const entryElement = createWorldbookEntryElement(entryData);
            parentElement.appendChild(entryElement);
            if (entryData.children && entryData.children.length > 0) {
                const childContainer = entryElement.querySelector('.child-entries');
                renderLevel(entryData.children, childContainer);
            }
        });
    }
    
    renderLevel(data, container);
    updateAllEntryAttributes();
}

function sortDataTree(data) {
    data.sort((a, b) => (a.id || 0) - (b.id || 0));
    data.forEach(entry => {
        if (entry.children && entry.children.length > 0) {
            sortDataTree(entry.children);
        }
    });
}

function sortWorldbookEntries() {
    const worldbookData = buildWorldbookDataFromDOM();
    sortDataTree(worldbookData);
    renderWorldbookFromData(worldbookData);
    alert('æ¡ç›®å·²æŒ‰IDé‡æ–°æ’åˆ—ï¼');
}

function airdropEntry(button) {
    const currentEntryElement = button.closest('.worldbook-entry');
    if (!currentEntryElement) return;

    const idInput = currentEntryElement.querySelector('.wb-sort-id');
    if (!idInput) return;

    const targetId = parseInt(idInput.value, 10);
    if (isNaN(targetId)) {
        alert("è¯·è¾“å…¥ä¸€ä¸ªæœ‰æ•ˆçš„æ•°å­—IDã€‚");
        return;
    }
    const worldbookData = buildWorldbookDataFromDOM();
    let entryToMove = null;
    let parentList = null;

    function findEntryAndParent(data, parent) {
        for (const entry of data) {
            if (entry.element === currentEntryElement) {
                entryToMove = entry;
                parentList = parent;
                return;
            }
            if (entry.children.length > 0) {
                findEntryAndParent(entry.children, entry.children);
            }
        }
    }
    findEntryAndParent(worldbookData, worldbookData);
    if (!entryToMove || !parentList) return;
    parentList.forEach(sibling => {
        if (sibling !== entryToMove && sibling.id >= targetId) {
            sibling.id += 1;
        }
    });
    entryToMove.id = targetId;
    sortDataTree(worldbookData);
    renderWorldbookFromData(worldbookData);
    alert(`æ“ä½œå®Œæˆï¼åˆ—è¡¨å·²æ ¹æ®æ–°IDæ’åˆ—ã€‚`);
}

function createDefaultImage(ratio = '2:3') {
    const canvas = document.createElement('canvas');
    const [width, height] = ratio === '2:3' ? [512, 768] : [768, 512];
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');
    const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
    gradient.addColorStop(0, '#2d2d2d');
    gradient.addColorStop(1, '#1c1c1c');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    return canvas.toDataURL('image/png');
}

function addWorldbookEntry() {
    const worldbookData = buildWorldbookDataFromDOM();
    const newId = (worldbookData.length > 0) ? Math.max(...worldbookData.map(e => e.id)) + 1 : 0;
    worldbookData.push({ id: newId, comment: 'æ–°æ¡ç›®', keys: [], content: '', children: [] });
    renderWorldbookFromData(worldbookData);
}

// æ–°å¢ï¼šè®¾ç½®ä¼˜å…ˆçº§çš„è¾…åŠ©å‡½æ•°
function setPriority(button, value) {
    const priorityInput = button.closest('.field-group').querySelector('.wb-priority');
    if (priorityInput) {
        priorityInput.value = value;
    }
}

function createWorldbookEntryElement(entryData = {}) {
    const entryLi = document.createElement('li');
    entryLi.className = 'worldbook-entry';
    const uniqueId = `wb-entry-${Date.now()}-${Math.random()}`;
    entryLi.dataset.uniqueId = uniqueId;
    
    const defaultEntry = {
        comment: 'æ–°æ¡ç›®', keys: [], secondary_keys: [], content: '',
        secondary_keys_logic: 'any',
        priority: 100, enabled: true, prevent_recursion: false,
        group: '', position: 'before_char', scope: 'chat',
        id: 0,
        constant: false, selective: true, use_regex: false,
        match_whole_words: true, case_sensitive: false, probability: 100,
        wb_depth: 4,
        ...entryData
    };
    
    entryLi.innerHTML = `
        <div class="entry-content-wrapper">
            <div class="entry-header">
                <div class="entry-title-group">
                    <div style="display: flex; align-items: center; gap: 5px;">
                        <input type="number" class="wb-sort-id" title="${t('help-entry-id')}" placeholder="${t('entry-id')}" value="${defaultEntry.id}" style="width: 65px; flex-shrink: 0;">
                        <button title="å°†æ­¤æ¡ç›®æ’å…¥åˆ°å·¦ä¾§æ¡†ä¸­æŒ‡å®šçš„IDä½ç½®ï¼Œå¹¶é¡ºå»¶åç»­æ¡ç›®" onclick="airdropEntry(this)" style="padding: 5px 8px; font-size: 14px; background-color: #6c757d; color: white;">â¡ï¸</button>
                    </div>
                    <input type="text" class="entry-comment" placeholder="${t('entry-comment-placeholder')}" value="${defaultEntry.comment}">
                    <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-id-drop'))">?</span>
                </div>
                <div class="entry-actions">
                    <button title="æ·»åŠ å­æ¡ç›®" onclick="addChildEntry(this)">â•</button>
                    <button title="å°†æ­¤æ¡ç›®ç§»å‡ºçˆ¶æ¡ç›®" onclick="indentEntry(this, -1)">â†“é€€å‡º</button>
                    <button title="å°†æ­¤æ¡ç›®è®¾ä¸ºä¸Šæ–¹åŒçº§æ¡ç›®çš„å­æ¡ç›®" onclick="indentEntry(this, 1)">â†‘åŠ å…¥</button>
                    <button class="delete-entry-btn" onclick="this.closest('.worldbook-entry').remove();">${t('delete')}</button>
                </div>
            </div>
            <div class="entry-grid">
                <div class="field-group full-width">
                    <label>${t('main-keys')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-main-keys'))">?</span></label>
                    <input type="text" class="wb-keys" placeholder="${t('main-keys-placeholder')}" value="${(defaultEntry.keys || []).join(', ')}">
                </div>
                <div class="field-group full-width">
                    <label>${t('injection-content')} <button class="ai-button" onclick="callWorldbookDeepSeek(this)" style="padding: 2px 8px; font-size: 12px; width: auto; margin-left: 10px;">${t('ai-help-write')}</button><button class="ai-undo-button" onclick="undoAiCompletion(this)">${t('undo')}</button></label>
                    <textarea class="wb-content" rows="3" placeholder="${t('injection-content-placeholder')}">${defaultEntry.content}</textarea>
                </div>

                <div class="field-group full-width">
                    <details>
                        <summary id="advanced-settings-summary">${t('advanced-settings')} <span style="font-weight: normal; font-size: 14px; color: #aaa;">(å…³é”®è¯åŒ¹é…ã€æ³¨å…¥é€»è¾‘ç­‰)</span></summary>
                        <div class="advanced-grid">
                            <div class="field-group full-width">
                                <label>å…³é”®å­—è¿‡æ»¤å™¨ 
                                    <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-secondary-keys'))">?</span>
                                </label>
                                <div style="display: flex; gap: 10px; align-items: center;">
                                    <select class="wb-secondary-keys-logic" style="flex: 1; padding: 12px;">
                                        <option value="any" ${defaultEntry.secondary_keys_logic === 'any' ? 'selected' : ''}>ä¸ä»»æ„</option>
                                        <option value="none" ${defaultEntry.secondary_keys_logic === 'none' ? 'selected' : ''}>éä»»æ„</option>
                                        <option value="all" ${defaultEntry.secondary_keys_logic === 'all' ? 'selected' : ''}>ä¸æ‰€æœ‰</option>
                                        <option value="not_all" ${defaultEntry.secondary_keys_logic === 'not_all' ? 'selected' : ''}>éæ‰€æœ‰</option>
                                    </select>
                                    <input type="text" class="wb-secondary-keys" placeholder="${t('secondary-keys-placeholder')}" value="${(defaultEntry.secondary_keys || []).join(', ')}" style="flex: 3;">
                                </div>
                            </div>
                            <div class="field-group">
                                <label>${t('entry-position')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-entry-position'))">?</span></label>
                                <select class="wb-position">
                                    <option value="before_char" ${defaultEntry.position === 'before_char' ? 'selected' : ''}>è§’è‰²å®šä¹‰å‰</option>
                                    <option value="after_char" ${defaultEntry.position === 'after_char' ? 'selected' : ''}>è§’è‰²å®šä¹‰å</option>
                                    <option value="before_prompt" ${defaultEntry.position === 'before_prompt' ? 'selected' : ''}>æœ€å¼€å¤´</option>
                                </select>
                            </div>
                            <div class="field-group">
                                <label>${t('entry-scope')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-entry-scope'))">?</span></label>
                                <select class="wb-scope">
                                    <option value="chat" ${defaultEntry.scope === 'chat' ? 'selected' : ''}>èŠå¤©ä¸­</option>
                                    <option value="summary" ${defaultEntry.scope === 'summary' ? 'selected' : ''}>è®°å¿†æ‘˜è¦ä¸­</option>
                                    <option value="discovery" ${defaultEntry.scope === 'discovery' ? 'selected' : ''}>æ¯æ¬¡è¿›å…¥èŠå¤©æ—¶</option>
                                </select>
                            </div>
                            <div class="field-group" style="display: flex; flex-direction: column; align-items: flex-start;">
                                <label style="margin-bottom: 8px;">${t('entry-priority')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-entry-priority'))">?</span></label>
                                <div style="display: flex; align-items: center; width: 100%;">
                                    <input type="number" class="wb-priority" value="${defaultEntry.priority}" style="flex-grow: 1;">
                                    <div class="priority-buttons">
                                        <button onclick="setPriority(this, 999)" title="999">${t('priority-preset-prereq')}</button>
                                        <button onclick="setPriority(this, 666)" title="666">${t('priority-preset-important')}</button>
                                        <button onclick="setPriority(this, 100)" title="100">${t('priority-preset-normal')}</button>
                                    </div>
                                </div>
                            </div>
                            <div class="field-group"><label>${t('entry-group')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-entry-group'))">?</span></label><input type="text" class="wb-group" value="${defaultEntry.group}" placeholder="${t('entry-group-placeholder')}"></div>
                            <div class="field-group"><label>${t('entry-probability')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-entry-probability'))">?</span></label><input type="number" class="wb-probability" value="${defaultEntry.probability}" min="0" max="100"></div>
                            <div class="field-group"><label>${t('entry-depth')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-entry-depth'))">?</span></label><input type="number" class="wb-depth" value="${defaultEntry.wb_depth}"></div>
                            <div class="field-group logic-group full-width">
                                <label><input type="checkbox" class="wb-enabled" ${defaultEntry.enabled ? 'checked' : ''}>${t('entry-enabled')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-entry-enabled'))">?</span></label>
                                <label><input type="checkbox" class="wb-constant" ${defaultEntry.constant ? 'checked' : ''}>${t('entry-constant')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-entry-constant'))">?</span></label>
                                <label><input type="checkbox" class="wb-selective" ${defaultEntry.selective ? 'checked' : ''}>${t('entry-selective')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-entry-selective'))">?</span></label>
                                <label><input type="checkbox" class="wb-prevent-recursion" ${defaultEntry.prevent_recursion ? 'checked' : ''}>${t('entry-prevent-recursion')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-entry-prevent-recursion'))">?</span></label>
                                <label><input type="checkbox" class="wb-use-regex" ${defaultEntry.use_regex ? 'checked' : ''}>${t('entry-use-regex')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-entry-use-regex'))">?</span></label>
                                <label><input type="checkbox" class="wb-match-whole-words" ${defaultEntry.match_whole_words ? 'checked' : ''}>${t('match-whole-words')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-match-whole-words'))">?</span></label>
                                <label><input type="checkbox" class="wb-case-sensitive" ${defaultEntry.case_sensitive ? 'checked' : ''}>${t('case-sensitive')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-case-sensitive'))">?</span></label>
                            </div>
                        </div>
                    </details>
                </div>
            </div>
        </div>
        <ul class="child-entries"></ul>
    `;
    return entryLi;
}

function addChildEntry(button) {
    const worldbookData = buildWorldbookDataFromDOM();
    const parentEntryElement = button.closest('.worldbook-entry');
    
    function findAndAdd(data) {
        for (const entry of data) {
            if (entry.element === parentEntryElement) {
                const newId = (entry.children.length > 0) ? Math.max(...entry.children.map(e => e.id)) + 1 : 0;
                entry.children.push({ id: newId, comment: 'æ–°å­æ¡ç›®', keys: [], content: '', children: [] });
                return true;
            }
            if (entry.children.length > 0) {
                if(findAndAdd(entry.children)) return true;
            }
        }
        return false;
    }

    findAndAdd(worldbookData);
    renderWorldbookFromData(worldbookData);
}

// [å·²ä¿®å¤] æ›¿æ¢ä¸ºä¿®å¤åçš„å‡½æ•°
function indentEntry(button, direction) {
    const worldbookData = buildWorldbookDataFromDOM();
    const currentEntryElement = button.closest('.worldbook-entry');
    if (!currentEntryElement) return;

    const found = findEntryRecursive(worldbookData, currentEntryElement);

    if (!found) {
        console.error(currentLanguage === 'zh' ? "æ— æ³•åœ¨æ•°æ®ç»“æ„ä¸­æ‰¾åˆ°å¯¹åº”çš„æ¡ç›®ã€‚" : "Unable to find corresponding entry in data structure.");
        return;
    }

    const { entry, parentList, index, parentEntry } = found;

    if (direction > 0) { // Indent (â†‘åŠ å…¥): å°†æ¡ç›®è®¾ä¸ºä¸Šæ–¹åŒçº§æ¡ç›®çš„å­æ¡ç›®
        if (index > 0) {
            const newParent = parentList[index - 1];
            parentList.splice(index, 1); // ä»å½“å‰åˆ—è¡¨ä¸­ç§»é™¤
            newParent.children.push(entry); // æ·»åŠ åˆ°æ–°çˆ¶çº§çš„ children æ•°ç»„ä¸­
        } else {
            alert('å·²ç»æ˜¯åŒçº§ä¸­çš„ç¬¬ä¸€ä¸ªæ¡ç›®ï¼Œæ— æ³•åŠ å…¥ï¼ˆç¼©è¿›ï¼‰ã€‚');
            return;
        }
    } else { // Un-indent (â†“é€€å‡º): å°†å­æ¡ç›®ç§»å‡ºï¼Œæˆä¸ºçˆ¶æ¡ç›®çš„åŒçº§
        if (parentEntry) {
            const parentFound = findEntryRecursive(worldbookData, parentEntry.element);
            if (parentFound) {
                const grandParentList = parentFound.parentList;
                const parentIndex = parentFound.index;

                parentList.splice(index, 1); // ä»å½“å‰çˆ¶çº§çš„ children æ•°ç»„ä¸­ç§»é™¤
                grandParentList.splice(parentIndex + 1, 0, entry); // æ·»åŠ åˆ°ç¥–çˆ¶çº§åˆ—è¡¨ï¼Œç´§è·Ÿåœ¨åŸçˆ¶çº§ä¹‹å
            }
        } else {
            alert(t('already-root-entry'));
            return;
        }
    }

    // ä»ä¿®æ”¹åçš„æ•°æ®ç»“æ„ï¼Œé‡æ–°æ¸²æŸ“æ•´ä¸ªè§’è‰²ä¹¦UI
    renderWorldbookFromData(worldbookData);
}

function updateAllEntryAttributes() {
    const container = document.getElementById('worldbook-entries-container');
    
    function traverse(element, depth, indexRef) {
        if (element.matches('li.worldbook-entry')) {
            element.dataset.depth = depth;
            element.dataset.displayIndex = indexRef.index++;
            const childContainer = element.querySelector('.child-entries');
            if (childContainer) {
                Array.from(childContainer.children).forEach(child => traverse(child, depth + 1, indexRef));
            }
        } else if (element.children) {
             Array.from(element.children).forEach(child => traverse(child, 0, indexRef));
        }
    }
    
    let indexCounter = { index: 0 };
    traverse(container, -1, indexCounter);
}

// --- PNG EMBEDDING FUNCTIONS ---
async function cleanImageAndGetDataURL(base64Str) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            resolve(canvas.toDataURL('image/png'));
        };
        img.onerror = () => reject(new Error('æ— æ³•åŠ è½½å›¾ç‰‡ï¼Œå¯èƒ½ä¸æ˜¯æœ‰æ•ˆçš„å›¾ç‰‡æ ¼å¼ã€‚'));
        img.src = base64Str;
    });
}

// æ–°å¢ï¼šå°†ä»»ä½•æ ¼å¼çš„å›¾ç‰‡è½¬æ¢ä¸ºPNGæ ¼å¼
async function convertImageToPng(imageDataUrl) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = 'anonymous'; // å…è®¸è·¨åŸŸå›¾ç‰‡
        
        img.onload = () => {
            try {
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                
                // ç»˜åˆ¶å›¾ç‰‡åˆ°canvas
                ctx.drawImage(img, 0, 0);
                
                // è½¬æ¢ä¸ºPNGæ ¼å¼
                const pngDataUrl = canvas.toDataURL('image/png', 0.9);
                resolve(pngDataUrl);
            } catch (error) {
                reject(new Error(`å›¾ç‰‡è½¬æ¢å¤±è´¥: ${error.message}`));
            }
        };
        
        img.onerror = () => {
            reject(new Error('æ— æ³•åŠ è½½å›¾ç‰‡ï¼Œå¯èƒ½ä¸æ˜¯æœ‰æ•ˆçš„å›¾ç‰‡æ ¼å¼ã€‚'));
        };
        
        img.src = imageDataUrl;
    });
}
async function embedDataInPng(imageBase64, textData) {
    const response = await fetch(imageBase64);
    const imageBuffer = await response.arrayBuffer();
    const imageData = new Uint8Array(imageBuffer);
    
    const textEncoder = new TextEncoder();
    const encodedText = textEncoder.encode("chara\x00" + textData);

    const chunk = createTextChunk('tEXt', encodedText);
    
    const iendPosition = findIend(imageData);
    if (iendPosition === -1) throw new Error("Invalid PNG: IEND chunk not found.");
    
    const newPngData = new Uint8Array(imageData.length + chunk.length);
    newPngData.set(imageData.slice(0, iendPosition));
    newPngData.set(chunk, iendPosition);
    newPngData.set(imageData.slice(iendPosition), iendPosition + chunk.length);
    
    return new Blob([newPngData], { type: 'image/png' });
}

function createTextChunk(type, data) {
    const chunkType = new TextEncoder().encode(type);
    const chunkData = data;
    const chunkLength = new Uint8Array(4);
    new DataView(chunkLength.buffer).setUint32(0, chunkData.length);

    const toCrc = new Uint8Array(chunkType.length + chunkData.length);
    toCrc.set(chunkType);
    toCrc.set(chunkData, chunkType.length);
    const crcValue = crc32(toCrc);
    const crc = new Uint8Array(4);
    new DataView(crc.buffer).setUint32(0, crcValue);

    const chunk = new Uint8Array(12 + chunkData.length);
    chunk.set(chunkLength);
    chunk.set(chunkType, 4);
    chunk.set(chunkData, 8);
    chunk.set(crc, 8 + chunkData.length);

    return chunk;
}

function findIend(imageData) {
    const IEND_SIGNATURE = [0x49, 0x45, 0x4E, 0x44];
    for (let i = imageData.length - 12; i >= 8; i--) {
        if (imageData[i+4] === IEND_SIGNATURE[0] && imageData[i+5] === IEND_SIGNATURE[1] && imageData[i+6] === IEND_SIGNATURE[2] && imageData[i+7] === IEND_SIGNATURE[3]) {
           return i;
        }
    }
    return -1;
}

const crc32 = (function() {
    const table = new Uint32Array(256);
    for (let i = 0; i < 256; i++) {
        let c = i;
        for (let j = 0; j < 8; j++) {
            c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
        }
        table[i] = c;
    }
    return function(bytes) {
        let crc = -1;
        for (let i = 0; i < bytes.length; i++) {
            crc = (crc >>> 8) ^ table[(crc ^ bytes[i]) & 0xFF];
        }
        return (crc ^ -1) >>> 0;
    };
})();

async function extractDataFromPng(arrayBuffer) {
    const bytes = new Uint8Array(arrayBuffer);
    const keyword = 'chara';
    
    let i = 8;
    while(i < bytes.length) {
        const view = new DataView(bytes.buffer, i);
        const length = view.getUint32(0);
        const type = new TextDecoder().decode(bytes.slice(i + 4, i + 8));

        if (type === 'tEXt' || type === 'iTXt') {
            const data_start = i + 8;
            let currentKeyword = '';
            let k_end = data_start;
            while(k_end < data_start + length && bytes[k_end] !== 0) {
              currentKeyword += String.fromCharCode(bytes[k_end]);
              k_end++;
            }
            
            if (currentKeyword === keyword) {
                const dataBytes = bytes.slice(k_end + 1, data_start + length);
                const base64String = new TextDecoder("utf-8").decode(dataBytes);
                const jsonString = decodeURIComponent(escape(atob(base64String)));
                return JSON.parse(jsonString);
            }
        }
        i += 12 + length;
    }
    throw new Error('åœ¨PNGä¸­æœªæ‰¾åˆ°è§’è‰²æ•°æ®ã€‚');
}

</script>

</body>
</html>