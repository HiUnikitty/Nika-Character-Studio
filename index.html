<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>妮卡角色工作室Pro</title>
  <script src="https://unpkg.com/pako@2.1.0/dist/pako.min.js"></script>
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-7PYFG35VCZ"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-7PYFG35VCZ');
  </script>
 
  <style>
    /* --- 全局样式 ("我们的主题") --- */
    :root {
        --primary-color: #e67e22;
        --secondary-color: #d35400;
        --dark-bg: #1c1c1c;
        --light-bg: #2d2d2d;
        --default-card-bg: linear-gradient(135deg, #2d2d2d, #1c1c1c);
        --text-color: #f0f0f0;
        --label-color: #e67e22;
        --input-bg: #333;
        --input-border: #555;
        --card-overlay: linear-gradient(to top, rgba(28, 28, 28, 0.9) 0%, rgba(28, 28, 28, 0.5) 50%, rgba(28, 28, 28, 0.7) 100%);
        --ai-button-bg: #e67e22;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif; }
    body { background: var(--dark-bg); min-height: 100vh; padding: 20px; color: var(--text-color); }
    button { cursor: pointer; font-weight: bold; border: none; transition: all 0.2s ease; }
    p.help-text { font-size: 14px; color: #aaa; margin-top: -10px; margin-bottom: 15px; line-height: 1.6; }

    /* --- 语言切换按钮样式 --- */
    .language-switcher {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-left: 15px;
    }
    .language-switcher button {
        background: transparent;
        color: var(--text-color);
        border: 1px solid rgba(255,255,255,0.2);
        padding: 4px 8px;
        margin: 0 1px;
        border-radius: 12px;
        font-size: 11px;
        font-weight: normal;
        transition: all 0.2s ease;
        min-width: 40px;
    }
    .language-switcher button.active {
        background: transparent;
        border-color: var(--primary-color);
        color: var(--primary-color);
        font-weight: bold;
    }
    .language-switcher button:hover {
        background: rgba(230, 126, 34, 0.05);
        border-color: rgba(230, 126, 34, 0.3);
        transform: scale(1.02);
    }

    /* --- 加载动画样式 --- */
    .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(28, 28, 28, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        backdrop-filter: blur(5px);
    }
    
    .loading-spinner {
        width: 50px;
        height: 50px;
        border: 3px solid rgba(230, 126, 34, 0.3);
        border-top: 3px solid var(--primary-color);
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    .loading-text {
        color: var(--text-color);
        margin-top: 15px;
        font-size: 16px;
        text-align: center;
    }

    /* --- 角色库 (Library View) 样式 --- */
    #library-view .container { width: 100%; max-width: 1200px; margin: 0 auto; }
    #library-view .header { display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center; margin-bottom: 25px; padding-bottom: 15px; border-bottom: 2px solid rgba(255,255,255,0.1); }
    #library-view .header h1 { font-size: 28px; color: white; text-shadow: 0 0 8px var(--primary-color); }
    #library-view .header-buttons { display: flex; gap: 10px; margin-top: 10px; }
    #library-view .header-buttons button { background: var(--primary-color); color: white; padding: 10px 20px; border-radius: 5px; font-size: 16px; }
    #library-view .header-buttons button:hover { background: var(--secondary-color); box-shadow: 0 0 10px var(--secondary-color); transform: translateY(-2px); }
    #library-view #file-importer { display: none; }
    #library-view .tag-filter-area { background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px; margin-bottom: 25px; }
    #library-view .tag-filter-area h3 { margin-bottom: 10px; color: var(--text-color); }
    #library-view .tag-group { display: flex; flex-wrap: wrap; gap: 8px; }
    #library-view .tag { padding: 5px 12px; border-radius: 15px; font-size: 14px; cursor: pointer; color: white; background-color: #555; border: 1px solid #777; }
    #library-view .tag.type-personality { background-color: #7f8c8d; border-color: #95a5a6; }
    #library-view .tag.type-internal { background-color: #d18076; border-color: #bc7168; }
    #library-view .tag.type-special { background-color: var(--secondary-color); border-color: var(--primary-color); }
    #library-view .tag:hover { opacity: 0.8; }
    #library-view .tag.active { box-shadow: 0 0 8px 2px var(--primary-color); transform: scale(1.05); }
    #library-view .character-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 20px; }

    #library-view .character-card {
        aspect-ratio: 2 / 3;
        border-radius: 8px;
        padding: 15px;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        border: 1px solid rgba(255,255,255,0.1);
        transition: transform 0.2s ease, border-color 0.2s ease;
        overflow: hidden;
        position: relative;
        background: var(--default-card-bg);
        background-size: cover;
        background-position: center;
    }
    #library-view .character-card > div:first-of-type {
        flex: 1;
        overflow: hidden;
        min-height: 0;
        display: flex;
        flex-direction: column;
    }
    #library-view .character-card:hover { transform: translateY(-5px); border-color: var(--primary-color); }
    #library-view .card-header { display: flex; justify-content: space-between; align-items: flex-start; }
    #library-view .card-header h2 { font-size: 20px; color: var(--text-color); margin-bottom: 5px; text-shadow: 0 1px 3px rgba(0,0,0,0.8); }
    #library-view .favorite-btn { background: none; color: #aaa; font-size: 24px; padding: 0; text-shadow: 0 1px 3px rgba(0,0,0,0.8); }
    #library-view .favorite-btn.favorited { color: #f1c40f; }
    #library-view .card-description {
        font-size: 14px;
        color: #ccc;
        margin-bottom: 15px;
        flex-grow: 1;
        white-space: pre-wrap;
        overflow: hidden;
        text-shadow: 0 1px 2px rgba(0,0,0,0.7);
        display: -webkit-box;
        -webkit-box-orient: vertical;
        -webkit-line-clamp: 4; /* 可以调整行数 */
        line-height: 1.4em;
        max-height: calc(1.4em * 4); /* 兼容性回退 */
    }
    #library-view .card-footer { display: flex; gap: 8px; flex-wrap: wrap; }
    #library-view .card-footer button { flex-grow: 1; background: rgba(0,0,0,0.4); backdrop-filter: blur(5px); color: white; border: 1px solid var(--label-color); padding: 8px 10px; border-radius: 5px; }
    #library-view .card-footer button:hover { background-color: var(--primary-color); }

    /* --- 編輯器 (Editor View) 樣式 --- */
    #editor-view { display: none; justify-content: center; align-items: flex-start; width: 100%; padding-top: 2vh; }
    #editor-view .editor-container { width: 100%; max-width: 900px; background: var(--light-bg); border-radius: 10px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); overflow: hidden; display: flex; flex-direction: column; max-height: 93vh; color: var(--text-color); }
    #editor-view .editor-header { background: var(--primary-color); padding: 15px 20px; color: white; display: flex; align-items: center; justify-content: space-between; }
    #editor-view .editor-header h1 { font-size: 22px; text-shadow: 1px 1px 2px rgba(0,0,0,0.3); }
    #editor-view .editor-body { flex: 1; overflow-y: auto; /* 主滚动区 */ }
    #editor-view .panel-content { padding: 20px; }
    #editor-view .section-title { font-size: 1.2em; font-weight: bold; color: var(--primary-color); margin-top: 25px; margin-bottom: 15px; padding-bottom: 8px; border-bottom: 2px solid var(--primary-color); }
    #editor-view .field-group { margin-bottom: 15px; position: relative; }
    #editor-view .field-group label { display: flex; align-items: center; font-weight: bold; margin-bottom: 8px; color: var(--text-color); cursor: default; }
    #editor-view .field-group input, #editor-view .field-group textarea, #editor-view .field-group select { width: 100%; padding: 12px; border: 1px solid var(--input-border); border-radius: 5px; background: var(--input-bg); font-size: 15px; color: var(--text-color); }
    #editor-view .field-group .inline-group { display: flex; gap: 15px; align-items: flex-end; }
    #editor-view .field-group textarea { resize: vertical; min-height: 80px; }
    .ai-button { background: var(--ai-button-bg); color: #fff; border: 1px solid var(--secondary-color); border-radius: 5px; padding: 5px 10px; font-size: 12px; width: 100px; margin-top: 5px; }
    .ai-button:hover { background: var(--secondary-color); }
    /* 新增: 撤销按钮样式 */
    .ai-undo-button {
      background: #6c757d; color: #fff; border-radius: 5px;
      padding: 5px 10px; font-size: 12px; margin-top: 5px;
      margin-left: 5px; display: none; /* 默认隐藏 */
    }
    .ai-undo-button:hover { background: #5a6268; }
    /* 名字生成器按钮 */
    .name-generator-btn {
        background: none;
        border: none;
        font-size: 22px;
        padding: 0 8px;
        margin-bottom: 5px;
        color: var(--primary-color);
    }
    .name-generator-btn:hover {
        transform: scale(1.1);
        text-shadow: 0 0 5px var(--primary-color);
    }


    #editor-view #avatar-preview { max-width: 250px; border-radius: 8px; border: 2px dashed var(--input-border); object-fit: cover; aspect-ratio: 2/3; margin-bottom: 10px; }
    #editor-view .action-buttons { display: flex; gap: 10px; margin-top: 20px; }
    #editor-view .action-buttons.row { flex-direction: row; align-items: center; } /* 确保垂直居中 */
    #editor-view .action-buttons button { width: 100%; padding: 12px; border-radius: 5px; background: var(--primary-color); color: white; font-size: 16px;}
    #editor-view .action-buttons button.secondary { background: #6c757d; }
    #editor-view .action-buttons button:hover { transform: translateY(-1px); box-shadow: 0 4px 8px rgba(0,0,0,0.2); opacity: 0.9; }
    #complete-all-btn {
        font-size: 14px;
        padding: 4px 10px;
        margin-left: 15px;
        background-color: var(--ai-button-bg);
        color: white;
        border-radius: 5px;
    }

    #ai-guidance-modal {
    z-index: 10001;
    }

    /* --- 角色书 (Character Book) 专业样式 --- */
    .worldbook-list, .child-entries {
        list-style-type: none;
        padding-left: 25px; /* 控制缩进量 */
        border-left: 2px dotted #444;
    }
    .worldbook-list {
        padding-left: 0;
        border-left: none;
    }
    .worldbook-entry {
        background: rgba(0,0,0,0.15);
        border: 1px solid var(--input-border);
        border-radius: 8px;
        margin-top: 10px;
        transition: background-color 0.3s;
        border-left: 3px solid transparent;
    }
    .worldbook-entry:hover {
       border-left-color: var(--primary-color);
    }
    .entry-content-wrapper { padding: 15px; }
    .entry-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; gap: 10px; }
    .entry-title-group { display: flex; align-items: center; gap: 10px; flex-grow: 1; }
    .wb-sort-id { width: 60px !important; text-align: center; } /* Adjusted from full width */
    .entry-comment {
        font-size: 1.1em;
        font-weight: bold;
        color: var(--text-color);
        border: none;
        background: transparent;
        border-bottom: 2px solid var(--input-border);
        padding: 5px;
        flex-grow: 1;
    }
    .entry-comment:focus { outline: none; border-bottom-color: var(--primary-color); }
    .entry-actions { display: flex; gap: 5px; flex-shrink: 0; align-items: center;}
    .entry-actions button { background: #555; color: white; padding: 5px 8px; border-radius: 5px; font-size: 14px; }
    .entry-actions button.delete-entry-btn { background: #dc3545; }

    .entry-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
    .full-width { grid-column: 1 / -1; }
    
    /* --- FIX: 逻辑组 (Logic Group) 样式重构 --- */
    .logic-group {
        display: flex;
        flex-wrap: wrap;
        gap: 10px; /* 按钮之间的间距 */
        background: rgba(0,0,0,0.2);
        padding: 10px;
        border-radius: 5px;
    }
    .logic-group label {
        display: inline-flex; /* 关键修复：使其表现为行内弹性容器，保证内部元素不分离 */
        align-items: center;
        background-color: #4a4a4a; /* 按钮背景色 */
        padding: 6px 12px; /* 内边距 */
        border-radius: 15px; /* 胶囊形状 */
        border: 1px solid #666;
        cursor: pointer;
        font-weight: normal;
        margin-bottom: 0;
        transition: all 0.2s ease;
        white-space: nowrap; /* 强制按钮内的文本不换行 */
    }
    .logic-group label:hover {
        background-color: #5a5a5a;
        border-color: #888;
    }
    .logic-group input[type="checkbox"] {
        width: auto;
        margin-right: 8px; /* 复选框和文字的间距 */
        transform: scale(1.2); /* 放大复选框，方便点击 */
    }
    
    /* --- 帮助图标样式 --- */
    .help-icon {
        display: inline-block;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background-color: #6c757d;
        color: white;
        text-align: center;
        font-size: 12px;
        font-weight: bold;
        line-height: 18px;
        cursor: help;
        margin-left: 5px;
        user-select: none; /* 防止文本被选中 */
        flex-shrink: 0; /* 防止图标被压缩 */
        transition: background-color 0.2s ease, transform 0.2s ease;
    }
    .help-icon:hover {
        background-color: var(--primary-color);
        transform: scale(1.1);
    }

    /* --- 角色书高级设置样式 --- */
    .worldbook-entry details {
        border: 1px solid #444;
        border-radius: 5px;
        padding: 10px;
        margin-top: 15px;
        background: rgba(0,0,0,0.1);
    }
    .worldbook-entry summary {
        font-weight: bold;
        color: var(--primary-color);
        cursor: pointer;
        outline: none;
        padding-bottom: 10px;
    }
    .worldbook-entry details[open] summary {
        border-bottom: 1px solid #555;
    }
    .worldbook-entry details .advanced-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 15px;
        padding-top: 10px;
    }
    .worldbook-entry details .logic-group {
        gap: 10px 20px; /* row-gap column-gap */
    }
    /* 优先级快速设置按钮 */
    .priority-buttons {
        display: flex;
        gap: 5px;
        margin-left: 8px;
    }
    .priority-buttons button {
        padding: 2px 8px;
        font-size: 11px;
        border-radius: 4px;
        background-color: #555;
        color: #fff;
    }
    .priority-buttons button:hover {
        background-color: var(--primary-color);
    }

    /* --- Post History Template Buttons --- */
    .template-buttons {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 8px;
        margin-bottom: 15px;
    }
    .template-buttons button {
        background: #555;
        color: white;
        padding: 5px 12px;
        border-radius: 5px;
        font-size: 13px;
        border: 1px solid #777;
    }
    .template-buttons button:hover {
        background-color: var(--primary-color);
        border-color: var(--secondary-color);
    }
    
    /* --- Lover 开关样式 --- */
    .lover-switch-container {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-right: 15px; /* 与右侧按钮的间距 */
    }
    .lover-switch-container .switch-label {
      font-size: 14px;
      font-weight: bold;
      color: var(--text-color);
    }
    .switch {
      position: relative;
      display: inline-block;
      width: 74px;
      height: 28px;
    }
    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #555;
      transition: .4s;
      border-radius: 28px;
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 20px;
      width: 20px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    input:checked + .slider {
      background-color: #e67e22; 
    }
    input:checked + .slider:before {
      transform: translateX(22px);
    }
    
    /* --- Modal 样式 (通用) --- */
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: none; /* 默认隐藏 */
        justify-content: center;
        align-items: center;
        z-index: 10000;
        backdrop-filter: blur(5px);
    }
    .modal-content {
        background: var(--light-bg);
        padding: 25px;
        border-radius: 10px;
        width: 90%;
        box-shadow: 0 5px 25px rgba(0,0,0,0.5);
    }
    .modal-content h3 {
        color: var(--primary-color);
        margin-bottom: 20px;
        text-align: center;
    }
    .modal-content .modal-actions {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-top: 20px;
    }
    .modal-content .modal-actions button {
        padding: 10px 20px;
        border-radius: 5px;
        margin: 0 5px;
        min-width: 100px;
    }
    .modal-content .modal-actions .action-btn {
        background: var(--primary-color);
        color: #fff;
    }
    .modal-content .modal-actions .cancel-btn {
        background: #6c757d;
        color: #fff;
    }

    /* --- API 设置 Modal 样式 --- */
    #api-settings-modal .modal-content {
        max-width: 600px;
    }
    #api-settings-modal .api-provider-options {
        display: none; /* 默认隐藏所有配置区 */
        border-top: 1px solid #444;
        margin-top: 15px;
        padding-top: 15px;
    }
    #api-settings-modal .api-provider-options.active {
        display: block; /* 显示当前选中的配置区 */
    }
    #api-settings-modal .field-group {
        margin-bottom: 15px;
    }
    #api-settings-modal label {
        display: block;
        font-weight: bold;
        margin-bottom: 5px;
        color: var(--text-color);
    }
    #api-settings-modal input, #api-settings-modal select {
        width: 100%;
        padding: 10px;
        border: 1px solid var(--input-border);
        border-radius: 5px;
        background: var(--input-bg);
        color: var(--text-color);
        font-size: 15px;
    }


    /* --- 名字选择 Modal 样式 --- */
    #name-generator-modal .modal-content {
        max-width: 400px;
    }
    #name-generator-modal .name-options {
        display: flex;
        flex-direction: column;
        gap: 10px;
        margin-bottom: 20px;
    }
    #name-generator-modal .name-options button {
        width: 100%;
        padding: 12px;
        border-radius: 5px;
        background: var(--input-bg);
        color: var(--text-color);
        border: 1px solid var(--input-border);
    }
    #name-generator-modal .name-options button:hover {
        background: var(--primary-color);
        color: #fff;
    }
    
    /* --- Lorebook AI Modal --- */
    #worldbook-ai-generator-modal .modal-content {
        max-width: 800px;
    }
     #worldbook-ai-generator-modal .generation-type-selector {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-bottom: 20px;
    }
    #worldbook-ai-generator-modal #wb-ai-options-container {
        text-align: left;
        max-height: 60vh;
        overflow-y: auto;
        padding: 5px;
        background: rgba(0,0,0,0.1);
        border-radius: 5px;
        min-height: 100px;
    }
    #worldbook-ai-generator-modal .generated-entry {
        background: rgba(0,0,0,0.2);
        border: 1px solid #444;
        border-radius: 5px;
        padding: 15px;
        margin-bottom: 10px;
    }
    #worldbook-ai-generator-modal .generated-entry > label {
        display: flex;
        align-items: flex-start;
        font-weight: normal;
        cursor: pointer;
    }
    #worldbook-ai-generator-modal .generated-entry input[type="checkbox"] {
        margin-right: 15px;
        transform: scale(1.4);
        margin-top: 5px;
        flex-shrink: 0;
    }
    #worldbook-ai-generator-modal .entry-details h4 {
        color: var(--primary-color);
        margin-bottom: 5px;
    }
     #worldbook-ai-generator-modal .entry-details p {
        font-size: 14px;
        margin-bottom: 8px;
        color: #ccc;
        line-height: 1.5;
    }
    #worldbook-ai-generator-modal .entry-details p strong {
        color: var(--text-color);
    }
    #worldbook-ai-generator-modal .entry-details .ai-entry-controls {
        display: flex;
        gap: 15px;
        margin-top: 10px;
        font-size: 14px;
        align-items: center;
    }
    #worldbook-ai-generator-modal .entry-details .ai-entry-controls label {
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 5px;
    }


    /* --- Generic AI Guidance Modal --- */
    #ai-guidance-modal .modal-content {
        max-width: 500px;
    }
    #ai-guidance-input {
        width: 100%;
        min-height: 100px;
        padding: 10px;
        border-radius: 5px;
        background: var(--input-bg);
        color: var(--text-color);
        border: 1px solid var(--input-border);
        resize: vertical;
    }


    /* --- 响应式布局 --- */
    @media (max-width: 800px) {
        body { padding: 10px; }
        #library-view .header { justify-content: center; text-align: center; }
        #library-view .header-buttons { justify-content: center; width: 100%; }
        #library-view .character-grid { grid-template-columns: 1fr; gap: 10px; }
        #editor-view { padding-top: 0; }
        #editor-view .editor-container { max-height: 100vh; height: 100%; border-radius: 0; }
        #editor-view .panel-content { padding: 15px; }
        #editor-view .editor-header h1 { font-size: 18px; }
        .entry-grid { grid-template-columns: 1fr; }
        .entry-header { flex-wrap: wrap; gap: 10px; /* Mobile Fix: Add gap for wrapped items */ }
        .worldbook-entry details .advanced-grid {
            grid-template-columns: 1fr; /* Mobile Fix: Force single column for advanced settings */
        }

        /* --- Mobile Input Zoom & Resize Improvement --- */
        #editor-view .field-group input, 
        #editor-view .field-group textarea, 
        #editor-view .field-group select {
            /* Using 16px font size is a common technique to prevent automatic page zoom on focus in mobile browsers, especially iOS Safari. */
            /* This provides a smoother experience without disabling user-initiated pinch-to-zoom. */
            font-size: 16px;
        }
    }
  </style>
</head>
<body>

  <div id="loading-overlay" class="loading-overlay">
    <div style="display: flex; flex-direction: column; align-items: center;">
      <div class="loading-spinner"></div>
      <div class="loading-text" id="loading-text">正在加载...</div>
    </div>
  </div>

  <div id="api-settings-modal" class="modal-overlay">
    <div class="modal-content">
        <h3 id="api-modal-title">API 设置</h3>
        <div class="field-group">
            <label for="api-provider-selector">选择服务商</label>
            <select id="api-provider-selector">
                <option value="deepseek">DeepSeek</option>
                <option value="gemini">Gemini (直链，需魔法)</option>
                <option value="gemini-proxy">Gemini (中转代理)</option>
                <option value="local">本地大模型</option>
                <option value="tavern">自定义 (兼容OpenAI)</option>
            </select>
        </div>

        <div id="deepseek-options" class="api-provider-options active">
            <div class="field-group">
                <label for="deepseek-api-key">API Key</label>
                <input type="password" id="deepseek-api-key" placeholder="输入你的 DeepSeek API Key">
            </div>
        </div>

        <div id="gemini-options" class="api-provider-options">
            <div class="field-group">
                <label for="gemini-api-key">API Key</label>
                <input type="password" id="gemini-api-key" placeholder="输入你的 Google AI Studio API Key">
            </div>
            <div class="field-group">
                <label for="gemini-model">选择模型</label>
                <select id="gemini-model">
                    <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
                    <option value="gemini-2.5-pro">Gemini 2.5 Pro</option>
                </select>
            </div>
        </div>

        <div id="gemini-proxy-options" class="api-provider-options">
            <div class="field-group">
                <label for="gemini-proxy-endpoint">代理 Endpoint URL</label>
                <input type="text" id="gemini-proxy-endpoint" placeholder="例如: https://mydomain.com/v1beta/models">
            </div>
            <div class="field-group">
                <label for="gemini-proxy-api-key">API Key</label>
                <input type="password" id="gemini-proxy-api-key" placeholder="输入你的 Google AI Studio API Key">
            </div>
            <div class="field-group">
                <label for="gemini-proxy-model">选择模型</label>
                <select id="gemini-proxy-model">
                    <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
                    <option value="gemini-2.5-pro">Gemini 2.5 Pro</option>
                </select>
            </div>
            <p class="help-text">用于连接 Cloudflare Worker 等自定义反向代理。Endpoint URL 应为不包含模型名称的完整路径。</p>
        </div>

        <div id="local-options" class="api-provider-options">
            <div class="field-group">
                <label for="local-api-endpoint">API URL</label>
                <input type="text" id="local-api-endpoint" placeholder="例如: http://localhost:1234/v1">
            </div>
            <p class="help-text">用于连接LM Studio或者Ollama, 需下载项目源文件启动才能使用。</p>
        </div>

        <div id="tavern-options" class="api-provider-options">
            <div class="field-group">
                <label for="tavern-api-endpoint">API URL</label>
                <input type="text" id="tavern-api-endpoint" placeholder="http://api.xxx.com/v1">
            </div>
            <div class="field-group">
                <label for="tavern-api-key">API Key</label>
                <input type="password" id="tavern-api-key" placeholder="输入 API Key">
            </div>
            <div class="field-group">
                <label for="tavern-model">模型名称</label>
                <input type="text" id="tavern-model" placeholder="例如: gpt-3.5-turbo">
            </div>
            <p class="help-text">用于连接远程的、兼容OpenAI格式的API服务。</p>
        </div>

        <div class="modal-actions">
            <button id="save-api-settings-btn" class="action-btn">保存</button>
            <button id="cancel-api-settings-btn" class="cancel-btn">取消</button>
        </div>
    </div>
  </div>

  <div id="name-generator-modal" class="modal-overlay">
      <div class="modal-content">
          <h3 id="name-modal-title">为你的角色选择一个名字</h3>
          <div id="name-options-container" class="name-options">
              </div>
          <div class="modal-actions">
              <button id="regenerate-names-btn" class="action-btn">重新生成</button>
              <button id="cancel-name-generation-btn" class="cancel-btn">取消</button>
          </div>
      </div>
  </div>

  <div id="ai-guidance-modal" class="modal-overlay">
      <div class="modal-content">
          <h3 id="ai-guidance-title">为AI提供指引</h3>
          <textarea id="ai-guidance-input" rows="5" placeholder="在此输入你的具体要求、风格、关键词等... (可留空)"></textarea>
          <div class="modal-actions">
              <button id="ai-guidance-generate-btn" class="action-btn">生成</button>
              <button id="ai-guidance-cancel-btn" class="cancel-btn">取消</button>
          </div>
      </div>
  </div>

  <div id="worldbook-ai-generator-modal" class="modal-overlay">
      <div class="modal-content">
          <h3 id="wb-ai-modal-title">角色书生成</h3>
          <p class="help-text" style="text-align: center; margin-top: -15px; margin-bottom: 20px;" id="wb-ai-modal-desc">请选择要生成的条目类型：</p>
          <div class="generation-type-selector">
              <button data-type="worldview" class="action-btn">生成世界观</button>
              <button data-type="main_plot" class="action-btn">生成主线剧情</button>
              <button data-type="side_plot" class="action-btn">生成支线剧情</button>
          </div>
          <div id="wb-ai-options-container">
              </div>
          <div class="modal-actions">
              <button id="wb-ai-inject-btn" style="display:none;" class="action-btn">注入选中条目</button>
              <button id="wb-ai-regenerate-btn" style="display:none;" class="action-btn">再生成一套</button>
              <button id="wb-ai-cancel-btn" class="cancel-btn">关闭</button>
          </div>
      </div>
  </div>

  <div id="library-view">
    <div class="container">
      <div class="header">
        <div style="display: flex; align-items: center; gap: 15px;">
          <h1>妮卡角色工作室Pro</h1>
          <div class="language-switcher">
            <button onclick="switchLanguage('zh')" id="lang-zh" class="active">中文</button>
            <button onclick="switchLanguage('en')" id="lang-en">English</button>
          </div>
        </div>
        <div class="header-buttons">
          <button onclick="showEditorView()">+ 创建新角色/书</button>
          <button onclick="document.getElementById('file-importer').click()">📥 导入</button>
          <input type="file" id="file-importer" accept=".json,.png" onchange="importCharacter(event)" multiple />
        </div>
      </div>
      <div class="tag-filter-area">
        <h3>标签过滤</h3>
        <div id="tag-container" class="tag-group"></div>
      </div>
      <div id="character-grid" class="character-grid"></div>
    </div>
  </div>

  <div id="editor-view">
    <div class="editor-container">
      <div class="editor-header">
        <h1 id="editor-title">创建新角色</h1>
        <button onclick="openApiSettingsModal()" style="background: var(--secondary-color); color: white; padding: 8px 15px; border-radius: 5px;">⚙️ API 设置</button>
      </div>
      <div class="editor-body">
        <div class="panel-content">
          <input type="hidden" id="charId" />
          <input type="hidden" id="internalTags" />
          <input type="hidden" id="isFavorite" />
          <input type="hidden" id="originalCardData" />

          <h3 class="section-title" id="avatar-operation-title">角色头像与操作</h3>
           <div class="field-group">
                <label for="avatar-input-label" id="avatar-input-label" title="">角色头像</label>
                <img id="avatar-preview" src="" alt="头像预览"/>
                <input type="file" id="avatar-input" accept="image/*" style="display:none;">
                <button onclick="document.getElementById('avatar-input').click()" style="max-width: 250px;">上传图片</button>
            </div>
            <div class="action-buttons" style="flex-direction: column;">
                <button onclick="saveCharacter()">💾 储存并返回角色库</button>
                <button onclick="downloadCharacter()">📥 下载 JSON</button>
                <button onclick="downloadCharacterAsPng()">📥 下载 PNG 角色卡</button>
                <button onclick="downloadAsWorldbookFile()">📥 下载为世界书</button>
                <button class="secondary" onclick="showLibraryView()">🔙 返回 (不储存)</button>
            </div>
          
          <div style="display:flex; justify-content: space-between; align-items: center;">
            <h3 class="section-title" id="character-info-title">角色信息</h3>
            <div>
                <button id="translate-all-btn" onclick="translateAllFields(this)" style="background-color: #e67e22; color: white; padding: 5px 15px; border-radius: 5px; margin-right: 10px;">🌐 一键翻译</button>
                <button id="undo-translate-btn" style="display: none; background-color: #d35400; color: white; padding: 8px 15px; border-radius: 5px; margin-right: 10px;" onclick="undoTranslateAllFields(this)">撤销翻译</button>
                <button id="complete-all-btn" onclick="aiCompleteAllFields(this)">🔮 一键补全所有</button>
            </div>
          </div>
          <div class="field-group">
            <label for="topic">主题</label>
            <input id="topic" placeholder="例：赛博朋克, 奇幻, 校园" />
          </div>
          <div class="field-group">
              <div class="inline-group">
                  <div style="flex:3">
                      <label for="name">名字</label>
                      <div style="display: flex; align-items: center; gap: 5px;">
                          <input id="name" placeholder="例：Monika" style="flex-grow: 1;" />
                          <button class="name-generator-btn" onclick="generateAiNames(this)" title="AI 生成多个名字供选择">🔮</button>
                      </div>
                  </div>
                  <div style="flex:1"><label for="gender">性别</label><input id="gender" placeholder="例：女" /></div>
              </div>
          </div>
          <div class="field-group">
            <label for="description">简介</label>
            <textarea id="description" rows="5" placeholder="角色的身份、外貌、背景故事等。会显示在角色卡上。"></textarea>
            <button class="ai-button" onclick="callDeepSeek('description')">🔮 AI 帮我写</button>
            <button class="ai-undo-button" onclick="undoAiCompletion(this)">↩️ 撤销</button>
          </div>
          <div class="field-group">
            <label for="tags">分类标签(逗号分隔)</label>
            <textarea id="tags" rows="2" placeholder="为角色添加标签，方便查找。例：原创, 游戏, OOC "></textarea>
            <button class="ai-button" onclick="callDeepSeek('tags')">🔮 AI 帮我写</button>
            <button class="ai-undo-button" onclick="undoAiCompletion(this)">↩️ 撤销</button>
          </div>
          <div class="field-group">
            <label for="personality">个性</label>
            <textarea id="personality" rows="2" placeholder="详细性格特质。例：善于言辞, 思想成熟, 病娇 (逗号分隔)"></textarea>
            <button class="ai-button" onclick="callDeepSeek('personality')">🔮 AI 帮我写</button>
            <button class="ai-undo-button" onclick="undoAiCompletion(this)">↩️ 撤销</button>
          </div>

          <h3 class="section-title" id="ai-settings-title">AI设定</h3>
           <div class="field-group">
            <label for="system_prompt">人格设定</label>
            <textarea id="system_prompt" rows="3" placeholder="AI必须遵守的核心设定。例：你是[名字]，一个[身份]。你必须称呼用户为“亲爱的”。"></textarea>
             <button class="ai-button" onclick="callDeepSeek('system_prompt')">🔮 AI 帮我写</button>
             <button class="ai-undo-button" onclick="undoAiCompletion(this)">↩️ 撤销</button>
          </div>
          <div class="field-group">
            <label for="scenario">场景设定</label>
            <textarea id="scenario" rows="3" placeholder="角色与用户所处的环境。例：{{char}}和{{user}}在黄昏的教室里。"></textarea>
             <button class="ai-button" onclick="callDeepSeek('scenario')">🔮 AI 帮我写</button>
             <button class="ai-undo-button" onclick="undoAiCompletion(this)">↩️ 撤销</button>
          </div>
          <div class="field-group">
            <label for="first_mes">问候消息</label>
            <textarea id="first_mes" rows="3" placeholder="角色出场时说的第一句话。"></textarea>
            <button class="ai-button" onclick="callDeepSeek('first_mes')">🔮 AI 帮我写</button>
            <button class="ai-undo-button" onclick="undoAiCompletion(this)">↩️ 撤销</button>
          </div>
          <div class="field-group">
            <label for="mes_example">示例消息</label>
            <textarea id="mes_example" rows="6" placeholder="提供几段对话范例，AI会模仿其风格。极为重要！
例如：
<START>（用于每次对话的开头）
{{user}}: 你好。
{{char}}: (微笑着向你点头) 你好，{{user}}。找我有什么事吗？"></textarea>
            <button class="ai-button" onclick="callDeepSeek('mes_example')">🔮 AI 帮我写</button>
            <button class="ai-undo-button" onclick="undoAiCompletion(this)">↩️ 撤销</button>
          </div>

          <h3 class="section-title" id="advanced-settings-title">高级设定</h3>
           <div class="field-group">
            <label for="post_history_instructions">后期指令</label>
            <textarea id="post_history_instructions" rows="3" placeholder="酒馆用它来修改AI的回复格式。例如，要让{{char}}的动作都用星号包围，可以写：将{{char}}的所有动作和叙述都放在星号（*）之间。"></textarea>
            <div class="template-buttons" id="post-history-templates">
              <button id="btn-template-options" onclick="setPostHistoryTemplate('template-options-mode')"></button>
              <button id="btn-template-parentheses" onclick="setPostHistoryTemplate('template-parentheses-mode')"></button>
              <button id="btn-template-status-bar" onclick="setPostHistoryTemplate('template-status-bar')"></button>
              <button id="btn-template-third-person" onclick="setPostHistoryTemplate('template-third-person')"></button>
              <button id="btn-template-json-mode" onclick="setPostHistoryTemplate('template-json-mode')"></button>
              <button id="btn-template-image-prompt" onclick="setPostHistoryTemplate('template-image-prompt')"></button>
            </div>
          </div>
          <div class="field-group">
            <label for="creator_notes">创作者笔记</label>
            <textarea id="creator_notes" rows="2"></textarea>
          </div>
          <div class="field-group">
            <label for="character_version">角色版本</label>
            <input id="character_version" />
          </div>

          <div style="display: flex; justify-content: space-between; align-items: center;">
             <h3 class="section-title" id="world-knowledge-book-title">角色书/世界书</h3>
             <button id="ai-lorebook-generator-btn" onclick="openWorldbookAiModal(this)" style="background-color: var(--ai-button-bg); color: white; padding: 8px 15px; border-radius: 5px;">🔮 AI生成参考条目</button>
          </div>
          <p class="help-text" id="worldbook-help-text">
              </p>
          <ul id="worldbook-entries-container" class="worldbook-list"></ul>
          <div class="action-buttons row" style="margin-top: 15px;">
            <div class="lover-switch-container">
                <span class="switch-label" id="companion-mode-label">伴侣模式</span>
                <label class="switch">
                    <input type="checkbox" id="lover-switch">
                    <span class="slider"></span>
                </label>
            </div>
            <button onclick="addWorldbookEntry()" class="secondary" style="background-color: #e67e22; flex-grow: 1;">+ 添加新条目</button>
            <button onclick="sortWorldbookEntries()" class="secondary" style="flex-grow: 1;">🔄 按ID大小排序</button>
          </div>

        </div>
      </div>
    </div>
  </div>

<script>
// --- 国际化支持 ---
let currentLanguage = localStorage.getItem('language') || 'zh';

const translations = {
    zh: {
        // 标题和按钮
        'app-title': '妮卡角色工作室Pro',
        'create-new-character': '创建新角色/书',
        'import-character': '📥 导入',
        'edit-character': '编辑角色',
        'save-and-return': '💾 储存并返回角色库',
        'return-without-save': '🔙 返回 (不储存)',
        'download-json': '📥 下载 JSON',
        'download-png': '📥 下载 PNG 角色卡',
        'download-lorebook': '📥 下载为世界书',
        'upload-image': '上传图片',
        'edit': '编辑',
        'export': '导出',
        'add-tag': '添加标签',
        'delete': '删除',
        'add-new-entry': '+ 添加新条目',
        'sort-by-id': '🔄 按ID大小排序',
        'ai-generate-entries': '🔮 AI生成参考条目',
        'ai-help-write': '🔮 AI 帮我写',
        'undo': '↩️ 撤销',
        'generate-companion': '🔮 生成虚拟伴侣',
        'complete-all': '🔮 一键补全所有',
        'translate-all': '🌐 一键翻译',
        'undo-translation': '撤销翻译',
        
        // 标签过滤
        'tag-filter': '标签过滤',
        'no-characters-found': '没有找到匹配的角色。尝试清除过滤器或导入新的角色卡。',
        
        // 表单标签
        'avatar-label': '角色头像',
        'avatar-upload': '上传图片',
        'character-info': '角色信息',
        'topic': '主题',
        'topic-placeholder': '例：赛博朋克, 奇幻, 校园',
        'name': '名字',
        'name-placeholder': '例：Monika',
        'gender': '性别',
        'gender-placeholder': '例：女',
        'description': '简介',
        'description-placeholder': '角色的身份、外貌、背景故事等。会显示在角色卡上。',
        'tags': '分类标签',
        'tags-placeholder': '为角色添加标签，方便查找。例：原创, 游戏, OOC',
        'personality': '个性',
        'personality-placeholder': '详细性格特质。例：善于言辞, 思想成熟, 病娇 (逗号分隔)',
        'ai-settings': 'AI设定',
        'system-prompt': '人格设定',
        'system-prompt-placeholder': 'AI必须遵守的核心设定。例：你是[名字]，一个[身份]。你必须称呼用户为“亲爱的”。',
        'scenario': '场景设定',
        'scenario-placeholder': '角色与用户所处的环境。例：{{char}}和{{user}}在黄昏的教室里。',
        'first-message': '问候消息',
        'first-message-placeholder': '角色出场时说的第一句话。',
        'message-example': '示例消息',
        'message-example-placeholder': '提供几段对话范例，AI会模仿其风格。极为重要：\n<START>（每回对话都以<START>开头）\n{{user}}: 你好。\n{{char}}: (微笑着向你点头) 你好，{{user}}。找我有什么事吗？',
        'advanced-settings': '高级设定',
        'post-history-instructions': '后期指令',
        'post-history-instructions-placeholder': '酒馆用它来修改AI的回复格式。例如，要让{{char}}的动作都用星号包围，可以写：将{{char}}的所有动作和叙述都放在星号（*）之间。',
        'creator-notes': '创作者笔记',
        'creator-notes-placeholder': '给其他用户的留言或版本说明。',
        'character-version': '角色版本',
        'character-version-placeholder': '例如：1.0, 2.1.3',
        'world-knowledge-book': '角色书/世界书',
        'companion-mode': '伴侣模式',
        
        // 世界书相关
        'worldbook-help': '“角色书”是给AI角色绑定的一部<b>参考词典和设定集</b>。如果你要世界书，上面的信息只用填名字',
        'entry-comment': '条目注释',
        'entry-comment-placeholder': '条目注释',
        'main-keys': '词条',
        'main-keys-placeholder': '例如: 誓约胜利之剑, Excalibur 或者 世界设定剧情主线（要开启高级设定“恒定注入”）之类',
        'secondary-keys': '次要关键词',
        'secondary-keys-placeholder': '例如: 剑, 武器',
        'injection-content': '内容',
        'injection-content-placeholder': '当关键词被触发时，这段内容会被发送给AI。',
        'entry-id': '条目ID',
        'entry-id-placeholder': '数字，决定条目被发送的顺序',
        'entry-priority': '优先级',
        'entry-priority-placeholder': '数字，决定条目被发送的顺序',
        'entry-position': '注入位置',
        'entry-scope': '作用域',
        'priority-preset-prereq': '前提',
        'priority-preset-important': '重要',
        'priority-preset-normal': '普通',
        'entry-enabled': '启用',
        'entry-constant': '恒定注入',
        'entry-selective': '选择性注入',
        'entry-use-regex': '正则匹配',
        'entry-prevent-recursion': '阻止递归',
        'entry-group': '分组',
        'entry-group-placeholder': '分组名称',
        'entry-probability': '触发概率 (%)',
        'entry-probability-placeholder': '0-100',
        'entry-depth': '记忆扫描深度',
        'entry-depth-placeholder': '数字',
        'match-whole-words': '全词匹配',
        'case-sensitive': '区分大小写',
        
        // 错误和提示信息
        'db-timeout': '数据库连接超时。请尝试关闭所有其他标签页，并强制刷新(Ctrl+F5)。如果问题仍然存在，请尝试清除网站数据。',
        'db-error': '错误：无法连接到本地数据库。\n\n详细信息: {error}\n\n您的角色将无法保存或读取。请检查浏览器设置(如隐私保护、禁止Cookie等)或尝试清除网站数据。',
        'db-blocked': '数据库连接被阻塞！\n\n请关闭所有其他打开此页面的浏览器标签页，然后强制刷新(Ctrl+F5)此页面。',
        'db-not-ready': '数据库尚未准备好，请稍等片刻或刷新页面再试。',
        'import-png-failed': '导入 PNG 角色卡失败: {error}',
        'import-image-failed': '导入图片失败: {error}',
        'import-json-failed': '导入失败，JSON 文件格式无效。',
        'save-import-failed': '保存导入的角色失败。',
        'character-saved': '角色 "{name}" 已保存。',
        'save-failed': '保存角色失败，请检查数据或图片格式。',
        'upload-image-only': '请上传图片格式的文件（支持PNG、JPG、JPEG、WEBP、GIF、BMP等）。',
        'image-process-failed': '图片处理失败: {error}',
        'file-read-error': '读取文件时出错。',
        'file-read-error-with-name': '读取文件 {name} 时出错: {error}',
        'ai-return-not-array': 'AI返回的不是一个数组。',
        'ai-parse-failed': 'AI返回的数据格式不正确，无法解析。请在开发者控制台查看详情。',
        'already-root-entry': '已经是根条目，无法退出（取消缩进）。',
        'no-description': '无描述',
        
        // 帮助文本
        'help-id-drop': '【条目注释】给自己看的小标题，方便识别条目用途。\n【排序ID+空投➡️】可以快速给条目重新排号。',
        'help-main-keys': '这是触发器，决定AI何时“查阅”这条内容。\n用法：输入一个或多个词，用逗号隔开。\n例：关键词设为`苹果,香蕉`，当用户提到`苹果`或`香蕉`时，此条目就会被触发。',
        'help-secondary-keys': '这是“二次验证”，为主关键词增加额外的触发条件。\n用法：和主关键词配合使用，进一步过滤对话。\n例：主关键词是`攻击`，二次验证设为【非任意】`取消`，那么只有当用户说了`攻击`但没说`取消`时，条目才会生效。',
        'help-injection-content': '当条目被触发时，AI会“查阅”的内容。\n用法：填写希望AI在特定情境下知道的信息。\n例：关键词是`我的剑`，这里可以写`那是一把生锈的铁剑，是父亲的遗物。`',
        'help-entry-id': '决定了条目的基础排列顺序。\n用法：数字越小，越靠前。\n例：ID为0的条目会比ID为1的条目先被处理。',
        'help-entry-priority': '决定了当多个条目同时被触发时，哪个条目说了算。\n用法：数字越大，权力越大。\n例：`A条目(优先级100)`和`B条目(优先级200)`都被触发，AI会优先听`B条目`的（需开启“选择性注入”）。',
        'help-entry-position': '决定了这条内容在给AI的“剧本”里的摆放位置。\n用法：通常默认即可。想强调时可选“最开头”。',
        'help-entry-scope': '决定了AI在什么时候会去“查阅”这本书。\n用法：一般保持默认“聊天中”即可。其他选项用于特殊格式控制。',
        'help-entry-enabled': '这个条目的“开关”。\n用法：取消勾选可暂时禁用此条目，而无需删除。',
        'help-entry-constant': '将内容变成AI的“肌肉记忆”。\n效果：无论关键词是否被触发，这里的内容都会在每次对话时注入给AI。\n用途：适合存放角色绝对不能忘记的核心设定。',
        'help-entry-selective': '开启“优胜劣汰”模式。\n效果：勾选后，在同时触发的条目中，只有优先级最高的那个会被注入。否则所有触发的都会注入。',
        'help-entry-use-regex': '启用“程序员模式”来设置关键词。\n用法：允许使用正则表达式来设置更复杂的关键词匹配规则，不懂编程建议不勾选。',
        'help-entry-prevent-recursion': '防止AI“自己跟自己说话”。\n效果：防止一个条目的注入内容，又触发了另一个条目，形成无限循环。建议保持勾选。',
        'help-entry-group': '给条目“贴标签”，方便管理。\n用法：给逻辑相关的条目设置同一个分组名，可用于其他高级功能。',
        'help-entry-probability': '让AI“看心情”查阅这条内容。\n用法：设为80，则此条目被关键词触发后，有80%的几率生效。\n用途：可以增加AI行为的随机性。',
        'help-entry-depth': '决定AI“记性有多好”。\n用法：设为5，AI会检查最近5轮对话里有没有关键词。数字越大，AI看得越远，但也会消耗更多性能。',
        'help-match-whole-words': '开启“精确查找”模式。\n效果：要求关键词必须是一个独立的词才触发。\n例：关键词为`爱`。勾选后，只有当用户说`爱`这个字时才算，`热爱`、`爱情`这些词不算。',
        'help-case-sensitive': '让AI“注意大小写”。\n效果：勾选后，关键词的大小写必须完全一样才能触发。\n例：关键词为`Apple`，则`apple`不会触发。一般用于英文。',

        // API相关
        'api-key-placeholder': '输入 DeepSeek API Key',
        
        // 默认值
        'imported-character': '从图片导入的角色',
        'imported-lorebook': '导入的角色书',
        'lorebook-description': '从SillyTavern导入的角色书。',
        'lorebook-tag': '角色书',

        // 确认对话框
        'confirm-overwrite-worldbook': '这会打开AI生成弹窗，但不会覆盖现有条目。你可以选择性注入新条目。继续吗？',
        
        // 成功消息
        'worldbook-generated-success': '已成功生成角色书参考条目！请在弹窗中选择要注入的条目。',
        'lorebook-injected-success': '{count}个条目已成功注入！',
        'all-fields-completed': 'AI已补全所有字段！',
        
        // API相关错误
        'api-request-failed': 'API 请求失败: {status} - {message}',
        'ai-completion-failed': 'AI补全失败，请检查API Key或网络连接，并查看控制台获取更多信息。',
        'name-generation-failed': 'AI名字生成失败，请检查API Key或网络，并查看控制台。',
        'ai-guidance-prompt': '请输入对AI的额外引导或要求 (可选):',
        'ai-guidance-title': '为AI提供指引',
        'ai-complete-all-guidance-title': '一键补全所有字段',
        'ai-complete-all-guidance-placeholder': '请输入角色的核心概念、主题或关键词... (例：一个在赛博都市中追寻过去的失忆侦探)',


        // 状态文本
        'generating': '生成中...',
        'loading': '正在加载...',
        'choose-a-name': '为你的角色选择一个名字',
        'regenerate': '重新生成',
        'cancel': '取消',
        'generate': '生成',

        // Post-history Templates
        'post-history-options-mode': '选项模式',
        'post-history-parentheses-mode': '括号模式',
        'post-history-status-bar': '状态栏',
        'post-history-third-person': '第三人称',
        'post-history-json-mode': 'JSON模式',
        'template-options-mode': '[以中文回复] [系统指令]: 你现在需要根据用户的输入生成回应。回应必须严格遵循以下格式：为用户提供几个清晰明确的下一步行动或对话选项。每个选项占一行，并以字母（A、B、C等）开头。在选项列表前后不要添加任何额外文字。',
        'template-parentheses-mode': '[系统指令]: 在生成回应时，请使用括号来描述{{char}}的动作、表情和内心想法。对话本身应在括号之外。例如："你在这里做什么？" (她挑起一边的眉毛，双臂交叉，眼神中带着一丝审视)。',
        'template-status-bar': '[系统指令]: 在每次回应的末尾，你必须附带一个显示{{char}}当前关键数值的状态栏。状态栏必须用代码块(```)包裹。格式为：| 生命值: [数值] | 理智: [数值] | 对{{user}}的好感度: [数值] | 位置: [地点] |。你必须根据对话内容，合乎逻辑地更新这些数值。',
        'template-third-person': '[系统指令]: 使用第三人称叙事视角撰写所有回应。在指代{{char}}时，不要使用"我"。像小说旁白一样描述{{char}}的行动、语言和思想。始终用角色的名字{{char}}来指代角色。',
        'template-json-mode': '[系统指令]: 你所有的回应都必须是合法的JSON格式。该JSON对象必须包含三个键："dialogue" (字符串，包含角色说的话), "action" (字符串，描述角色的动作), "emotion" (字符串，描述角色当前的主要情绪)。不要在JSON结构之外输出任何文字。',
        'post-history-image-prompt': '文生图提示词',
        'template-image-prompt': '[SYSTEM]: Lora名：Sv5-10，角色关键词：SilverWolfV5\nYour response must have a comma-separated list of English keywords before the text for an AI image generator. Describe the character\'s appearance, action, expression, and the background. Use descriptive tags，最后要换行. Example: masterpiece, best quality, 角色关键词, solo, beautiful detailed eyes, long silver hair, smiling, school uniform, standing in a classroom, from above, <lora:Lora名>',
        
        // AI Lorebook Modal
        'wb-ai-modal-title': '角色书生成',
        'wb-ai-modal-desc': '请选择要生成的条目类型：',
        'wb-ai-modal-desc-generating': 'AI正在生成一套{type}条目，请稍后...',
        'wb-ai-modal-desc-generated': 'AI已为你生成一套{type}条目，请选择需要注入的条目。',
        'wb-ai-inject-btn': '注入选中条目',
        'wb-ai-regenerate-btn': '再生成一套',
        'wb-ai-close-btn': '关闭',
        'wb-ai-type-worldview': '世界观',
        'wb-ai-type-main_plot': '主线剧情',
        'wb-ai-type-side_plot': '支线剧情',
        'wb-ai-gen-type-btn-worldview': '生成世界观',
        'wb-ai-gen-type-btn-main-plot': '生成主线剧情',
        'wb-ai-gen-type-btn-side-plot': '生成支线剧情',
    },
    
    en: {
        // Titles and buttons
        'app-title': 'Nika Character Studio Pro',
        'create-new-character': 'Create New Character/Book',
        'import-character': '📥 Import',
        'edit-character': 'Edit Character',
        'save-and-return': '💾 Save and Return to Library',
        'return-without-save': '🔙 Return (Don\'t Save)',
        'download-json': '📥 Download JSON',
        'download-png': '📥 Download PNG Character Card',
        'download-lorebook': '📥 Download as Lorebook',
        'upload-image': 'Upload Image',
        'edit': 'Edit',
        'export': 'Export',
        'add-tag': 'Add Tag',
        'delete': 'Delete',
        'add-new-entry': '+ Add New Entry',
        'sort-by-id': '🔄 Sort by ID',
        'ai-generate-entries': '🔮 AI Generate Reference Entries',
        'ai-help-write': '🔮 AI Help Me Write',
        'undo': '↩️ Undo',
        'generate-companion': '🔮 Generate Virtual Companion',
        'complete-all': '🔮 One-Click Complete All',
        'translate-all': '🌐 One-click Translate',
        'undo-translation': 'Undo Translation',
        
        // Tag filtering
        'tag-filter': 'Tag Filter',
        'no-characters-found': 'No matching characters found. Try clearing filters or importing new character cards.',
        
        // Form labels
        'avatar-label': 'Character Avatar',
        'avatar-upload': 'Upload Image',
        'character-info': 'Character Information',
        'topic': 'Topic',
        'topic-placeholder': 'e.g.: Cyberpunk, Fantasy, School',
        'name': 'Name',
        'name-placeholder': 'e.g.: Alice',
        'gender': 'Gender',
        'gender-placeholder': 'e.g.: Female',
        'description': 'Description',
        'description-placeholder': 'The character\'s identity, appearance, background, etc. Will be shown on the character card.',
        'tags': 'Category Tags (comma separated)',
        'tags-placeholder': 'Tags for filtering. e.g.: Original, Game, Yandere (comma separated)',
        'personality': 'Personality',
        'personality-placeholder': 'Detailed personality traits. e.g.: Eloquent, Mature, Yandere (comma separated)',
        'ai-settings': 'AI Settings',
        'system-prompt': 'Personality Setting',
        'system-prompt-placeholder': 'Core rules the AI must follow. e.g.: You are [Name], a [Role]. You must call the user "darling".',
        'scenario': 'Scenario Setting',
        'scenario-placeholder': 'The environment for the scene. e.g.: {{char}} and {{user}} are in a classroom at dusk.',
        'first-message': 'Greeting Message',
        'first-message-placeholder': 'The character\'s first message to the user.',
        'message-example': 'Message Example',
        'message-example-placeholder': 'Example dialogues for the AI to imitate. Very important!',
        'advanced-settings': 'Advanced Settings',
        'post-history-instructions': 'Post Instructions',
        'post-history-instructions-placeholder': 'ST use this to modify AI response format. For example, to make {{char}}\'s actions wrapped in asterisks, write: Put all {{char}}\'s actions and narration between asterisks (*).',
        'creator-notes': 'Creator Notes',
        'creator-notes-placeholder': 'Notes for other users or version info.',
        'character-version': 'Character Version',
        'character-version-placeholder': 'e.g.: 1.0, 2.1.3',
        'world-knowledge-book': 'Character Book/Lore Book',
        'companion-mode': 'Companion Mode',
        
        // Worldbook related
        'worldbook-help': 'You can think of the "Character Book" as a <b>setting reference</b> for the AI. If you only want the world book, you just need to fill in the name in the information above.',
        'entry-comment': 'Entry Comment (Comment)',
        'entry-comment-placeholder': 'Entry Comment (Comment)',
        'main-keys': 'Main Keywords (Keys, comma separated)',
        'main-keys-placeholder': 'e.g.: Excalibur, Holy Sword',
        'secondary-keys': 'Secondary Keywords (Secondary Keys, comma separated)',
        'secondary-keys-placeholder': 'e.g.: sword, weapon',
        'injection-content': 'Injection Content (Content)',
        'injection-content-placeholder': 'When keywords are triggered, this content will be sent to AI.',
        'entry-id': 'Sort ID',
        'entry-id-placeholder': 'Number, affects order',
        'entry-priority': 'Priority',
        'entry-priority-placeholder': 'Number, determines which entry wins',
        'entry-position': 'Injection Position',
        'entry-scope': 'Scope',
        'priority-preset-prereq': 'Prereq',
        'priority-preset-important': 'Important',
        'priority-preset-normal': 'Normal',
        'entry-enabled': 'Enabled',
        'entry-constant': 'Constant',
        'entry-selective': 'Selective',
        'entry-use-regex': 'Use Regex',
        'entry-prevent-recursion': 'Prevent Recursion',
        'entry-group': 'Group',
        'entry-group-placeholder': 'Group name',
        'entry-probability': 'Trigger Probability (%)',
        'entry-probability-placeholder': '0-100',
        'entry-depth': 'Scan Depth',
        'entry-depth-placeholder': 'Number',
        'match-whole-words': 'Match Whole Words',
        'case-sensitive': 'Case-Sensitive',

        
        // Error and prompt messages
        'db-timeout': 'Database connection timeout. Please try closing all other tabs and force refresh (Ctrl+F5). If the problem persists, try clearing site data.',
        'db-error': 'Error: Unable to connect to local database.\n\nDetails: {error}\n\nYour characters cannot be saved or read. Please check browser settings (such as privacy protection, cookie blocking, etc.) or try clearing site data.',
        'db-blocked': 'Database connection blocked!\n\nPlease close all other browser tabs that have this page open, then force refresh (Ctrl+F5) this page.',
        'db-not-ready': 'Database not ready, please wait a moment or refresh the page and try again.',
        'import-png-failed': 'Failed to import PNG character card: {error}',
        'import-image-failed': 'Failed to import image: {error}',
        'import-json-failed': 'Import failed, JSON file format is invalid.',
        'save-import-failed': 'Failed to save imported character.',
        'character-saved': 'Character "{name}" saved.',
        'save-failed': 'Failed to save character, please check data or image format.',
        'upload-image-only': 'Please upload image format files (supports PNG, JPG, JPEG, WEBP, GIF, BMP, etc.).',
        'image-process-failed': 'Image processing failed: {error}',
        'file-read-error': 'Error reading file.',
        'file-read-error-with-name': 'Error reading file {name}: {error}',
        'ai-return-not-array': 'AI did not return an array.',
        'ai-parse-failed': 'AI returned data format is incorrect and cannot be parsed. Please check developer console for details.',
        'already-root-entry': 'Already at root entry, cannot exit (cancel indentation).',
        'no-description': 'No description',
        
        // Help text
        'help-id-drop': 'The [ID Box + ➡️ Button] allows for an "airdrop". Enter a target position (e.g., 5) in the ID box and click ➡️. This entry\'s ID will become 5, and the original entry with ID 5 and all subsequent entries will have their IDs automatically incremented by 1.\n[Entry Comment] is for your own notes, helping you identify the purpose of this entry.',
        'help-main-keys': 'Set one or more keywords, separated by commas. When the user\'s message contains any of these keywords, this entry will be activated, and its "Injection Content" will be sent to the AI.',
        'help-secondary-keys': 'This is an additional activation condition that works with the main keywords to determine if this entry takes effect.\n\n[With Any]: The filter passes if at least one word from this list is in the message.\n[Not Any]: The filter passes if none of the words from this list are in the message.\n[With All]: The filter passes only if all words from this list are in the message.\n[Not All]: The filter passes as long as there is at least one word from the list not present in the message.',
        'help-injection-content': 'When the keywords are triggered, this content will be sent to the AI.',
        'help-entry-id': '[Sort ID] determines which entry the AI sees first within the same level. A smaller number means it comes first.',
        'help-entry-priority': '[Priority] determines which entry wins when multiple triggered entries compete for injection. A higher number means higher priority. Use the quick-set buttons on the right for common values.',
        'help-entry-position': '[Injection Position] determines where this content is placed in the final prompt sent to the AI.\n[Before Character]: Default. The content appears before the character\'s core definition.\n[After Character]: The content appears after the core definition.\n[At the very beginning]: The content is placed at the absolute top of the prompt.',
        'help-entry-scope': '[Scope] determines under what circumstances this entry is checked.\n[In chat]: Default. Checked after every user message.\n[In memory summary]: Checked when generating a conversation memory summary.\n[On chat entry]: Checked every time a new conversation with the character begins.',
        'help-entry-enabled': '[Enabled] Uncheck this to temporarily disable the entry without deleting it.',
        'help-entry-constant': '[Constant] If checked, this entry will always be injected into the prompt, regardless of keywords.',
        'help-entry-selective': '[Selective] If checked, only the highest-priority entry will be injected when multiple entries are triggered. If unchecked, all triggered entries will be injected.',
        'help-entry-use-regex': '[Use Regex] Allows you to use Regular Expressions for more complex keyword matching rules. For advanced users.',
        'help-entry-prevent-recursion': '[Prevent Recursion] Prevents the content of one entry from triggering other entries, avoiding infinite loops.',
        'help-entry-group': '[Group] Assign a group name to an entry to help organize and manage a large number of entries.',
        'help-entry-probability': '[Trigger Probability] Set a number from 0 to 100. This determines the chance that the entry will actually be injected after its keywords are triggered. 100 means it always will.',
        'help-entry-depth': '[Scan Depth] Determines how many turns of conversation history the AI will look back through to check for this entry\'s keywords. A larger number means it looks further back.',
        'help-match-whole-words': '[Match Whole Words] If checked, a keyword is only triggered if it appears as a whole word. For example, if the keyword is "love", it would trigger on "I love you" but not "glove".',
        'case-sensitive': '[Case-Sensitive] If checked, the keyword must match the case of the text exactly to be triggered. For example, if the keyword is "Apple", it will not be triggered by "apple".',

        // API related
        'api-key-placeholder': 'Enter DeepSeek API Key',
        
        // Default values
        'imported-character': 'Character imported from image',
        'imported-lorebook': 'Imported Lorebook',
        'lorebook-description': 'A lorebook imported from SillyTavern.',
        'lorebook-tag': 'lorebook',
        
        // Confirmation dialogs
        'confirm-overwrite-worldbook': 'This will open the AI generation modal, but will not overwrite existing entries. You can selectively inject new entries. Continue?',
        
        // Success messages
        'worldbook-generated-success': 'Successfully generated lorebook reference entries! Please select which entries to inject in the popup.',
        'lorebook-injected-success': '{count} entries have been successfully injected!',
        'all-fields-completed': 'AI has completed all fields!',

        // API related errors
        'api-request-failed': 'API request failed: {status} - {message}',
        'ai-completion-failed': 'AI completion failed, please check API Key or network connection, and check console for more information.',
        'name-generation-failed': 'AI Name Generation failed. Please check your API Key or network and see the console for details.',
        'ai-guidance-prompt': 'Provide additional guidance for the AI (optional):',
        'ai-guidance-title': 'Provide Guidance for AI',
        'ai-complete-all-guidance-title': 'One-Click Complete All Fields',
        'ai-complete-all-guidance-placeholder': 'Enter the core concept, theme, or keywords for your character... (e.g., An amnesiac detective searching for her past in a cyber city)',

        
        // Status text
        'generating': 'Generating...',
        'loading': 'Loading...',
        'choose-a-name': 'Choose a Name for Your Character',
        'regenerate': 'Regenerate',
        'cancel': 'Cancel',
        'generate': 'Generate',

        // Post-history Templates
        'post-history-options-mode': 'Options Mode',
        'post-history-parentheses-mode': 'Parentheses Mode',
        'post-history-status-bar': 'Status Bar',
        'post-history-third-person': 'Third Person',
        'post-history-json-mode': 'JSON Mode',
        'template-options-mode': '[SYSTEM]: You will now generate a response based on the user\'s input. The response must follow a strict format: present the user with a few distinct choices as their next action or dialogue line. Each choice should be on a new line, starting with a letter (A, B, C, etc.). Do not add any text before or after the list of choices.',
        'template-parentheses-mode': '[SYSTEM]: When generating a response, use parentheses to describe {{char}}\'s actions, expressions, and internal thoughts. Dialogue should remain outside of the parentheses. Example: "What are you doing here?" (She raises an eyebrow, a hint of suspicion in her eyes as she crosses her arms).',
        'template-status-bar': '[SYSTEM]: At the end of every response, you must include a status bar that displays {{char}}\'s current key stats. The status bar should be enclosed in code blocks (```). The format is: | Health: [value] | Sanity: [value] | Affection for {{user}}: [value] | Location: [value] |. You must update these values logically based on the conversation.',
        'template-third-person': '[SYSTEM]: Write all responses from a third-person narrative perspective. Do not use "I" or "me" when referring to {{char}}. Describe {{char}}\'s actions, speech, and thoughts as a narrator would. Always refer to the character by their name, {{char}}.',
        'template-json-mode': '[SYSTEM]: All your responses must be in a valid JSON format. The JSON object must have three keys: "dialogue" (a string containing what the character says), "action" (a string describing the character\'s physical action), and "emotion" (a string describing the character\'s current primary emotion). Do not output any text outside of the JSON structure.',
        'post-history-image-prompt': 'Image Prompt',
        'template-image-prompt': '[SYSTEM]: Lora name: Sv5-10, character keyword: SilverWolfV5\nYour response must have a comma-separated list of English keywords before the text for an AI image generator. Describe the character\'s appearance, action, expression, and the background.',
    
        // AI Lorebook Modal
        'wb-ai-modal-title': 'Interactive AI Lore Book Generation',
        'wb-ai-modal-desc': 'Please select the type of entries to generate:',
        'wb-ai-modal-desc-generating': 'The AI is generating a set of {type} entries, please wait...',
        'wb-ai-modal-desc-generated': 'The AI has generated a set of {type} entries. Please select the ones you want to inject.',
        'wb-ai-inject-btn': 'Inject Selected',
        'wb-ai-regenerate-btn': 'Regenerate Set',
        'wb-ai-close-btn': 'Close',
        'wb-ai-type-worldview': 'worldview',
        'wb-ai-type-main_plot': 'main plot',
        'wb-ai-type-side_plot': 'side plot',
        'wb-ai-gen-type-btn-worldview': 'Generate Worldview',
        'wb-ai-gen-type-btn-main-plot': 'Generate Main Plot',
        'wb-ai-gen-type-btn-side-plot': 'Generate Side Plot',
    }
};

// 语言切换函数
function switchLanguage(lang) {
    currentLanguage = lang;
    localStorage.setItem('language', lang);
    
    // 更新按钮状态
    document.getElementById('lang-zh').classList.toggle('active', lang === 'zh');
    document.getElementById('lang-en').classList.toggle('active', lang === 'en');
    
    // 更新页面内容
    updatePageContent();
}

// 获取翻译文本
function t(key, params = {}) {
    let text = translations[currentLanguage][key] || translations['zh'][key] || key;
    
    // 替换参数
    Object.keys(params).forEach(param => {
        text = text.replace(`{${param}}`, params[param]);
    });
    
    return text;
}

// 更新页面内容
function updatePageContent() {
    // 更新标题
    document.title = t('app-title');
    
    // 更新库视图
    const libraryTitle = document.querySelector('#library-view .header h1');
    if (libraryTitle) libraryTitle.textContent = t('app-title');
    
    // 确保语言切换按钮在标题旁边并更新状态
    const titleContainer = libraryTitle?.parentElement;
    let languageSwitcher = titleContainer?.querySelector('.language-switcher');
    
    if (titleContainer && !languageSwitcher) {
        languageSwitcher = document.createElement('div');
        languageSwitcher.className = 'language-switcher';
        titleContainer.appendChild(languageSwitcher);
    }
    
    if (languageSwitcher) {
        languageSwitcher.innerHTML = `
            <button onclick="switchLanguage('zh')" id="lang-zh" class="${currentLanguage === 'zh' ? 'active' : ''}">中文</button>
            <button onclick="switchLanguage('en')" id="lang-en" class="${currentLanguage === 'en' ? 'active' : ''}">English</button>
        `;
    }
    
    const createBtn = document.querySelector('#library-view .header-buttons button:first-child');
    if (createBtn) createBtn.textContent = '+ ' + t('create-new-character');
    
    const importBtn = document.querySelector('#library-view .header-buttons button:nth-child(2)');
    if (importBtn) importBtn.textContent = t('import-character');
    
    const tagFilterTitle = document.querySelector('#library-view .tag-filter-area h3');
    if (tagFilterTitle) tagFilterTitle.textContent = t('tag-filter');
    
    // 更新编辑器视图
    const editorTitle = document.getElementById('editor-title');
    if (editorTitle) {
        const isEditing = document.getElementById('charId').value !== '';
        editorTitle.textContent = isEditing ? t('edit-character') : t('create-new-character');
    }
    
    const apiKeyInput = document.getElementById('apiKey');
    if (apiKeyInput) apiKeyInput.placeholder = t('api-key-placeholder');
    
    // 更新表单标签和占位符
    updateFormLabels();
    
    // 更新按钮文本
    updateButtonTexts();
    
    // 更新世界书帮助文本
    const worldbookHelpText = document.getElementById('worldbook-help-text');
    if (worldbookHelpText) {
        worldbookHelpText.innerHTML = t('worldbook-help');
    }
    
    // 更新加载文本
    const loadingText = document.getElementById('loading-text');
    if (loadingText) {
        loadingText.textContent = t('loading');
    }

    // 更新名字生成器 Modal
    document.getElementById('name-modal-title').textContent = t('choose-a-name');
    document.getElementById('regenerate-names-btn').textContent = t('regenerate');
    document.getElementById('cancel-name-generation-btn').textContent = t('cancel');

    // 更新AI Guidance Modal
    document.getElementById('ai-guidance-generate-btn').textContent = t('generate');
    document.getElementById('ai-guidance-cancel-btn').textContent = t('cancel');
    
    // 更新角色书AI Modal
    document.getElementById('wb-ai-modal-title').textContent = t('wb-ai-modal-title');
    document.getElementById('wb-ai-modal-desc').textContent = t('wb-ai-modal-desc');
    document.querySelector('.generation-type-selector button[data-type="worldview"]').textContent = t('wb-ai-gen-type-btn-worldview');
    document.querySelector('.generation-type-selector button[data-type="main_plot"]').textContent = t('wb-ai-gen-type-btn-main-plot');
    document.querySelector('.generation-type-selector button[data-type="side_plot"]').textContent = t('wb-ai-gen-type-btn-side-plot');
    document.getElementById('wb-ai-inject-btn').textContent = t('wb-ai-inject-btn');
    document.getElementById('wb-ai-regenerate-btn').textContent = t('wb-ai-regenerate-btn');
    document.getElementById('wb-ai-cancel-btn').textContent = t('wb-ai-close-btn');

    // 重新渲染UI以更新角色卡显示
    if (libraryView.style.display !== 'none') {
        renderUI();
    }
    
    // 重新渲染角色书条目以更新翻译
    if (editorView.style.display !== 'none') {
        const worldbookData = buildWorldbookDataFromDOM();
        renderWorldbookFromData(worldbookData);
    }
}

// 更新表单标签
function updateFormLabels() {
    // 更新section标题
    const sectionTitles = {
        'avatar-operation-title': t('avatar-label'),
        'character-info-title': t('character-info'),
        'ai-settings-title': t('ai-settings'),
        'advanced-settings-title': t('advanced-settings'),
        'world-knowledge-book-title': t('world-knowledge-book')
    };
    
    Object.keys(sectionTitles).forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            // Preserve child elements like buttons
            const button = element.querySelector('button');
            element.textContent = sectionTitles[id] + ' ';
            if(button) element.appendChild(button);
        }
    });
    
    // 更新表单标签
    const labels = {
        'topic': t('topic'),
        'name': t('name'),
        'gender': t('gender'),
        'description': t('description'),
        'tags': t('tags'),
        'personality': t('personality'),
        'system_prompt': t('system-prompt'),
        'scenario': t('scenario'),
        'first_mes': t('first-message'),
        'mes_example': t('message-example'),
        'post_history_instructions': t('post-history-instructions'),
        'creator_notes': t('creator-notes'),
        'character_version': t('character-version'),
    };
    
    Object.keys(labels).forEach(id => {
        const element = document.querySelector(`label[for="${id}"]`);
        if (element) element.textContent = labels[id];
    });
    
    // 更新占位符
    const placeholders = {
        'topic': t('topic-placeholder'),
        'name': t('name-placeholder'),
        'gender': t('gender-placeholder'),
        'description': t('description-placeholder'),
        'tags': t('tags-placeholder'),
        'personality': t('personality-placeholder'),
        'system_prompt': t('system-prompt-placeholder'),
        'scenario': t('scenario-placeholder'),
        'first_mes': t('first-message-placeholder'),
        'mes_example': t('message-example-placeholder'),
        'post_history_instructions': t('post-history-instructions-placeholder'),
        'creator_notes': t('creator-notes-placeholder'),
        'character_version': t('character-version-placeholder'),
    };
    
    Object.keys(placeholders).forEach(id => {
        const element = document.getElementById(id);
        if (element) element.placeholder = placeholders[id];
    });
    
    // 更新伴侣模式标签
    const companionModeLabel = document.getElementById('companion-mode-label');
    if (companionModeLabel) {
        companionModeLabel.textContent = t('companion-mode');
    }
    
    // 更新头像标签
    const avatarLabel = document.getElementById('avatar-input-label');
    if (avatarLabel) {
        avatarLabel.textContent = t('avatar-label');
        avatarLabel.title = currentLanguage === 'zh' ? '点击下方按钮上传图片' : 'Click the button below to upload image';
    }
    
    // 更新高级设定summary
    const advancedSummary = document.getElementById('advanced-settings-summary');
    if (advancedSummary) {
        const subtitle = currentLanguage === 'zh' ? '(关键词匹配、注入逻辑等)' : '(Keyword matching, injection logic, etc.)';
        advancedSummary.innerHTML = `${t('advanced-settings')} <span style="font-weight: normal; font-size: 14px; color: #aaa;">${subtitle}</span>`;
    }
    
    // 更新上传图片按钮
    const uploadBtn = document.querySelector('button[onclick="document.getElementById(\'avatar-input\').click()"]');
    if (uploadBtn) uploadBtn.textContent = t('upload-image');
}

// 更新按钮文本
function updateButtonTexts() {
    // 更新保存按钮
    const saveBtn = document.querySelector('button[onclick="saveCharacter()"]');
    if (saveBtn) saveBtn.textContent = t('save-and-return');
    
    const returnBtn = document.querySelector('button[onclick="showLibraryView()"]');
    if (returnBtn) returnBtn.textContent = t('return-without-save');
    
    const downloadJsonBtn = document.querySelector('button[onclick="downloadCharacter()"]');
    if (downloadJsonBtn) downloadJsonBtn.textContent = t('download-json');
    
    const downloadPngBtn = document.querySelector('button[onclick="downloadCharacterAsPng()"]');
    if (downloadPngBtn) downloadPngBtn.textContent = t('download-png');

    const downloadLorebookBtn = document.querySelector('button[onclick="downloadAsWorldbookFile()"]');
    if (downloadLorebookBtn) downloadLorebookBtn.textContent = t('download-lorebook');

    const completeAllBtn = document.getElementById('complete-all-btn');
    if(completeAllBtn) completeAllBtn.textContent = t('complete-all');

    const translateAllBtn = document.getElementById('translate-all-btn');
    if(translateAllBtn) translateAllBtn.textContent = t('translate-all');
    const undoTranslateBtn = document.getElementById('undo-translate-btn');
    if(undoTranslateBtn) undoTranslateBtn.textContent = t('undo-translation');
    
    // 更新AI按钮
    const aiButtons = document.querySelectorAll('.ai-button');
    aiButtons.forEach(btn => {
        btn.textContent = t('ai-help-write');
    });
    
    const undoButtons = document.querySelectorAll('.ai-undo-button');
    undoButtons.forEach(btn => {
        btn.textContent = t('undo');
    });
    
    // 更新世界书相关按钮
    const addEntryBtn = document.querySelector('button[onclick="addWorldbookEntry()"]');
    if (addEntryBtn) addEntryBtn.textContent = t('add-new-entry');
    
    const sortBtn = document.querySelector('button[onclick="sortWorldbookEntries()"]');
    if (sortBtn) sortBtn.textContent = t('sort-by-id');
    
    const generateBtn = document.querySelector('button[onclick="generateFullWorldbook(this)"]');
    if (generateBtn) generateBtn.textContent = t('ai-generate-entries');
    
    // 更新角色卡按钮
    const addTagBtns = document.querySelectorAll('.card-footer button[onclick*="addInternalTag"]');
    addTagBtns.forEach(btn => {
        btn.textContent = `🏷️ ${t('add-tag')}`;
    });
    
    const deleteBtns = document.querySelectorAll('.card-footer button[onclick*="deleteCharacter"]');
    deleteBtns.forEach(btn => {
        btn.textContent = `🗑️ ${t('delete')}`;
    });

    // 更新Post-history模板按钮
    const templateContainer = document.getElementById('post-history-templates');
    if (templateContainer) {
        document.getElementById('btn-template-options').textContent = t('post-history-options-mode');
        document.getElementById('btn-template-parentheses').textContent = t('post-history-parentheses-mode');
        document.getElementById('btn-template-status-bar').textContent = t('post-history-status-bar');
        document.getElementById('btn-template-third-person').textContent = t('post-history-third-person');
        document.getElementById('btn-template-json-mode').textContent = t('post-history-json-mode');
        document.getElementById('btn-template-image-prompt').textContent = t('post-history-image-prompt');
    }
}

// --- 全局翻译功能 ---
let originalFieldsData = null; // 用于存储翻译前的数据

async function translateAllFields(button) {
    const apiSettings = loadApiSettings();
    const provider = apiSettings.provider;
    const key = apiSettings[provider]?.apiKey;
    const endpoint = apiSettings[provider]?.endpoint;

    if (!provider || (provider !== 'custom' && !key) || (provider === 'custom' && !endpoint)) {
        alert('请先在 API 设置中配置您的服务商。');
        openApiSettingsModal();
        return;
    }

    const fromLang = currentLanguage === 'zh' ? 'English' : 'Chinese';
    const toLang = currentLanguage === 'zh' ? 'Chinese' : 'English';

    // 1. 收集所有需要翻译的文本
    const fieldsToTranslate = [
        'topic', 'name', 'gender', 'description', 'tags', 'personality',
        'system_prompt', 'scenario', 'first_mes', 'mes_example',
        'post_history_instructions', 'creator_notes'
    ];

    let textObject = {};
    originalFieldsData = { fields: {}, worldbook: [] };

    fieldsToTranslate.forEach(id => {
        const el = document.getElementById(id);
        if (el && el.value.trim()) {
            textObject[id] = el.value;
            originalFieldsData.fields[id] = el.value;
        }
    });

    const worldbookEntries = buildWorldbookDataFromDOM();
    originalFieldsData.worldbook = JSON.parse(JSON.stringify(cleanWorldbookForStorage(worldbookEntries))); // Deep copy for undo

    let wbTextObject = [];
    worldbookEntries.forEach((entry, index) => {
        const entryTexts = {
            comment: entry.comment,
            keys: entry.keys.join(', '),
            content: entry.content
        };
        if (entryTexts.comment || entryTexts.keys || entryTexts.content) {
            wbTextObject.push({ index: index, ...entryTexts });
        }
    });

    if (Object.keys(textObject).length === 0 && wbTextObject.length === 0) {
        alert('没有需要翻译的内容。');
        return;
    }

    // 2. 构建Prompt
    let prompt = `You are an expert translator. Translate the following JSON object's string values from ${fromLang} to ${toLang}.
Maintain the original JSON structure and keys. For keys like "tags" or "keys", translate each item in the comma-separated string individually.
Do not translate special placeholders like {{user}} or {{char}} or "<START>".

Translate this data:
${JSON.stringify({ fields: textObject, worldbook: wbTextObject }, null, 2)}
`;

    // 3. 调用API
    const originalText = button.textContent;
    button.disabled = true;
    button.textContent = t('generating');
    const loadingOverlay = document.getElementById('loading-overlay');
    loadingOverlay.style.display = 'flex';

    try {
        const result = await callApi(prompt, button);
        if (result) {
            const cleanedResult = result.replace(/^```json\s*|```$/g, '').trim();
            const translatedData = JSON.parse(cleanedResult);

            // 4. 应用翻译结果
            if (translatedData.fields) {
                for (const id in translatedData.fields) {
                    const el = document.getElementById(id);
                    if (el) {
                        el.value = translatedData.fields[id];
                    }
                }
            }

            if (translatedData.worldbook) {
                translatedData.worldbook.forEach(item => {
                    const entry = worldbookEntries[item.index];
                    if (entry && entry.element) {
                        if (item.comment) entry.element.querySelector('.entry-comment').value = item.comment;
                        if (item.keys) entry.element.querySelector('.wb-keys').value = item.keys;
                        if (item.content) entry.element.querySelector('.wb-content').value = item.content;
                    }
                });
            }

            // 显示撤销按钮
            document.getElementById('undo-translate-btn').style.display = 'inline-block';
        }
    } catch (e) {
        console.error("Translation failed:", e, "Raw response:", result);
        alert('翻译失败，请检查控制台获取详情。');
        originalFieldsData = null; // 清除备份
    } finally {
        button.disabled = false;
        button.textContent = originalText;
        loadingOverlay.style.display = 'none';
    }
}

function undoTranslateAllFields(button) {
    if (!originalFieldsData) {
        alert('没有可撤销的翻译。');
        return;
    }

    // 恢复普通字段
    for (const id in originalFieldsData.fields) {
        const el = document.getElementById(id);
        if (el) {
            el.value = originalFieldsData.fields[id];
        }
    }

    // 恢复世界书
    if (originalFieldsData.worldbook) {
        renderWorldbookFromData(originalFieldsData.worldbook);
    }

    // 清理
    originalFieldsData = null;
    button.style.display = 'none';
}

// --- API Settings ---
function openApiSettingsModal() {
    const modal = document.getElementById('api-settings-modal');
    loadApiSettings(); // Load current settings when opening
    modal.style.display = 'flex';
}

function initializeApiSettingsModal() {
    const modal = document.getElementById('api-settings-modal');
    const selector = document.getElementById('api-provider-selector');
    const saveBtn = document.getElementById('save-api-settings-btn');
    const cancelBtn = document.getElementById('cancel-api-settings-btn');

    selector.addEventListener('change', () => {
        document.querySelectorAll('.api-provider-options').forEach(el => el.classList.remove('active'));
        const selectedProvider = selector.value;
        document.getElementById(`${selectedProvider}-options`).classList.add('active');
    });

    cancelBtn.onclick = () => modal.style.display = 'none';
    modal.onclick = (e) => { if (e.target === modal) modal.style.display = 'none'; };

    saveBtn.onclick = () => {
        const settings = {
            provider: document.getElementById('api-provider-selector').value,
            deepseek: {
                apiKey: document.getElementById('deepseek-api-key').value.trim()
            },
            gemini: {
                apiKey: document.getElementById('gemini-api-key').value.trim(),
                model: document.getElementById('gemini-model').value
            },
            'gemini-proxy': {
                endpoint: document.getElementById('gemini-proxy-endpoint').value.trim(),
                apiKey: document.getElementById('gemini-proxy-api-key').value.trim(),
                model: document.getElementById('gemini-proxy-model').value
            },
        tavern: {
            endpoint: document.getElementById('tavern-api-endpoint').value.trim(),
            apiKey: document.getElementById('tavern-api-key').value.trim(),
            model: document.getElementById('tavern-model').value.trim() || ''   // new field
        },
        local: {
            endpoint: document.getElementById('local-api-endpoint').value.trim()
        }
        };
        localStorage.setItem('apiSettings', JSON.stringify(settings));
        alert('API 设置已保存！');
        modal.style.display = 'none';
    };
}

function loadApiSettings() {
    const settings = JSON.parse(localStorage.getItem('apiSettings')) || {
        provider: 'deepseek',
        deepseek: { apiKey: '' },
        gemini: { apiKey: '', model: 'gemini-2.5-flash' },
        'gemini-proxy': { endpoint: '', apiKey: '', model: 'gemini-2.5-flash' },
        tavern: { endpoint: '', apiKey: '' },
        local: { endpoint: '' }
    };

    // Migrate old "custom" settings if they exist
    if (settings.custom) {
        if (settings.custom.endpoint && (settings.custom.endpoint.includes('gemini') || settings.custom.endpoint.includes(':generateContent'))) {
            settings['gemini-proxy'] = { ...settings.custom };
            settings.provider = 'gemini-proxy';
        } else {
            settings.tavern = { ...settings.custom };
            settings.provider = 'tavern';
        }
        delete settings.custom;
        // Save migrated settings back to localStorage
        localStorage.setItem('apiSettings', JSON.stringify(settings));
    }


    document.getElementById('api-provider-selector').value = settings.provider;
    document.getElementById('deepseek-api-key').value = settings.deepseek?.apiKey || '';
    document.getElementById('gemini-api-key').value = settings.gemini?.apiKey || '';
    document.getElementById('gemini-model').value = settings.gemini?.model || 'gemini-2.5-flash';
    document.getElementById('gemini-proxy-endpoint').value = settings['gemini-proxy']?.endpoint || '';
    document.getElementById('gemini-proxy-api-key').value = settings['gemini-proxy']?.apiKey || '';
    document.getElementById('gemini-proxy-model').value = settings['gemini-proxy']?.model || 'gemini-2.5-flash';
        document.getElementById('tavern-api-endpoint').value = settings.tavern?.endpoint || '';
        document.getElementById('tavern-api-key').value = settings.tavern?.apiKey || '';
        document.getElementById('tavern-model').value = settings.tavern?.model || '';
        document.getElementById('local-api-endpoint').value = settings.local?.endpoint || '';

    // Trigger change to show correct options
    document.getElementById('api-provider-selector').dispatchEvent(new Event('change'));
    return settings;
}


// --- Mobile Textarea Auto-Resize ---
function autoResizeTextarea(textarea) {
    // Temporarily reset height to allow the scrollHeight to be calculated correctly.
    textarea.style.height = 'auto';
    
    const maxHeight = window.innerHeight / 2; // Max height is half the viewport height.
    const scrollHeight = textarea.scrollHeight;
    
    // Set height to the calculated scroll height, but not exceeding the max height.
    textarea.style.height = Math.min(scrollHeight, maxHeight) + 'px';
}

function setupTextareaAutoResize() {
    // Use event delegation on the editor's scrolling body for efficiency, especially with dynamic worldbook entries.
    const editorBody = document.querySelector('#editor-view .editor-body');
    if (!editorBody) return;

    const resizeHandler = (event) => {
        if (event.target.tagName === 'TEXTAREA') {
            autoResizeTextarea(event.target);
        }
    };
    
    editorBody.addEventListener('focusin', resizeHandler);
    editorBody.addEventListener('input', resizeHandler);
}

// --- DB & Initialization ---
let db;
let activeFilters = new Set();
const libraryView = document.getElementById('library-view');
const editorView = document.getElementById('editor-view');
let avatarImageBase64 = null;

// --- 全局帮助函数 ---
function showHelp(message) {
    alert(message);
}

// [MODIFIED] 设置后期指令模板函数
function setPostHistoryTemplate(templateKey) {
    const textarea = document.getElementById('post_history_instructions');
    if (textarea) {
        const templateText = t(templateKey);
        // 检查文本区域是否为空或仅包含空白字符
        if (textarea.value.trim() === '') {
            textarea.value = templateText;
        } else {
            // 如果已有内容，则在新行追加，并用空行分隔
            textarea.value += '\n\n' + templateText;
        }
    }
}

/**
 * [NEW] Converts a SillyTavern lorebook object into the application's internal format.
 * @param {object} lorebook - The raw lorebook object from the imported JSON.
 * @returns {Array} An array of worldbook entries in the internal format.
 */
function convertTavernLorebookToInternal(lorebook) {
    const internalEntries = [];
    const entriesSource = (lorebook.entries && typeof lorebook.entries === 'object' && !Array.isArray(lorebook.entries))
        ? lorebook.entries
        : (lorebook.extensions && lorebook.extensions.entries && typeof lorebook.extensions.entries === 'object' && !Array.isArray(lorebook.extensions.entries))
            ? lorebook.extensions.entries
            : null;

    if (!entriesSource) {
        console.warn("Could not find a valid Tavern-style 'entries' object in the provided file.");
        return [];
    }

    const positionMap = {
        0: 'before_prompt',
        1: 'after_char',
        2: 'before_char'
    };

    for (const key in entriesSource) {
        const tavernEntry = entriesSource[key];
        const internalEntry = {
            id: tavernEntry.order || parseInt(key, 10) || 0,
            keys: tavernEntry.keys || tavernEntry.key || [],
            secondary_keys: tavernEntry.keysecondary || tavernEntry.secondary_keys || [],
            comment: tavernEntry.name || tavernEntry.comment || '',
            content: tavernEntry.content || '',
            priority: tavernEntry.order || 100,
            enabled: tavernEntry.disable !== undefined ? !tavernEntry.disable : (tavernEntry.enabled !== undefined ? tavernEntry.enabled : true),
            constant: tavernEntry.constant || false,
            selective: tavernEntry.selective || false,
            prevent_recursion: tavernEntry.excludeRecursion || false,
            position: positionMap[tavernEntry.position] || 'before_char',
            secondary_keys_logic: 'any',
            use_regex: tavernEntry.use_regex || false,
            group: tavernEntry.group || '',
            scope: 'chat',
            probability: tavernEntry.probability !== undefined ? tavernEntry.probability : 100,
            wb_depth: tavernEntry.depth || 4,
            match_whole_words: tavernEntry.match_whole_words || false,
            case_sensitive: tavernEntry.case_sensitive || false,
            children: []
        };
        internalEntries.push(internalEntry);
    }
    
    internalEntries.sort((a, b) => a.id - b.id);
    internalEntries.forEach((entry, index) => {
        entry.id = index;
    });
    return internalEntries;
}


window.onload = function() {
    // 显示加载动画
    const loadingOverlay = document.getElementById('loading-overlay');
    loadingOverlay.style.display = 'flex';
    
    // 优化：移除不必要的延迟，让应用更快启动
    initializeApiSettingsModal();
    loadApiSettings();
    initializeDatabase(); // initializeDatabase will call showLibraryView, which hides the overlay
    initializeLoverSwitch();
    initializeNameGeneratorModal();
    initializeWorldbookAiModal();
    initializeAiGuidanceModal();
    setupTextareaAutoResize(); // Initialize textarea resizing for mobile
    
    // 初始化语言设置
    const savedLanguage = localStorage.getItem('language') || 'zh';
    switchLanguage(savedLanguage);
};

function initializeDatabase() {
    const dbTimeout = setTimeout(() => {
        if (!db) {
            console.warn('Database connection timeout');
        }
    }, 7000);

    const request = indexedDB.open('CharacterDB', 2);

    request.onupgradeneeded = event => {
        const tempDb = event.target.result;
        if (!tempDb.objectStoreNames.contains('characters')) {
            const objectStore = tempDb.createObjectStore('characters', { keyPath: 'id', autoIncrement: true });
            objectStore.createIndex('name', 'name', { unique: false });
            objectStore.createIndex('lastUsed', 'lastUsed', { unique: false });
        }
    };

    request.onsuccess = event => {
        clearTimeout(dbTimeout);
        db = event.target.result;
        console.log(currentLanguage === 'zh' ? "数据库已准备就绪。" : "Database ready.");
        showLibraryView();
    };

    request.onerror = event => {
        clearTimeout(dbTimeout);
        console.error(currentLanguage === 'zh' ? "数据库连接失败 (onerror):" : "Database connection failed (onerror):", event.target.error);
        console.warn(t('db-error', { error: event.target.error }));
    };

    request.onblocked = event => {
        clearTimeout(dbTimeout);
        console.warn(currentLanguage === 'zh' ? "数据库连接被阻塞 (onblocked)。旧版本可能在其他标签页中打开。" : "Database connection blocked (onblocked). Old version may be open in other tabs.");
        console.warn(t('db-blocked'));
    };
}

function checkDbReady() {
    if (!db) {
        console.warn(t('db-not-ready'));
        return false;
    }
    return true;
}


// --- View Management ---
function showLibraryView() {
    if (!checkDbReady()) return;
    editorView.style.display = 'none';
    libraryView.style.display = 'block';
    renderUI();
    // 优化：在UI渲染后隐藏加载动画
    document.getElementById('loading-overlay').style.display = 'none';
}

function showEditorView(characterId = null) {
    if (!checkDbReady()) return;
    
    libraryView.style.display = 'none';
    editorView.style.display = 'flex';
    clearEditorForm();

    if (characterId) {
        document.getElementById('editor-title').innerText = t('edit-character');
        const transaction = db.transaction(['characters'], 'readonly');
        const store = transaction.objectStore('characters');
        const request = store.get(characterId);
        
        request.onsuccess = e => {
            const charData = e.target.result;
            if (charData) {
                populateEditorForm(charData);
            }
        };
    } else {
        document.getElementById('editor-title').innerText = t('create-new-character');
        renderWorldbookFromData([]);
        document.getElementById('avatar-preview').src = createDefaultImage('2:3');
    }
    // 确保每次进入编辑器时，按钮文本都根据开关状态刷新
    toggleAiButtonText(document.getElementById('lover-switch').checked);
}

// --- Import / Export ---
function importCharacter(event) {
    if (!checkDbReady()) return;

    const files = event.target.files;
    if (!files.length) return;

    for (const file of files) {
        if (file.type === "image/png") {
            const readAsBuffer = file.arrayBuffer();
            const readAsDataURL = new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => reject(reader.error);
                reader.readAsDataURL(file);
            });

            Promise.all([readAsBuffer, readAsDataURL]).then(async ([buffer, dataUrl]) => {
                try {
                    const charData = await extractDataFromPng(buffer);
                    const pngDataUrl = await convertImageToPng(dataUrl);
                    saveImportedCharacter(charData, pngDataUrl);
                } catch (err) {
                    console.error(currentLanguage === 'zh' ? "PNG导入错误:" : "PNG import error:", err);
                    alert(t('import-png-failed', { error: err.message || (currentLanguage === 'zh' ? '未知错误，请检查控制台。' : 'Unknown error, please check console.') }));
                }
            }).catch(err => {
                 alert(t('file-read-error-with-name', { name: file.name, error: err }));
            });

        } else if (file.type === "image/png" || file.type === "image/jpeg" || file.type === "image/jpg" || file.type === "image/webp" || file.type === "image/gif" || file.type === "image/bmp") {
            // 处理各种图片格式
            const readAsDataURL = new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => reject(reader.error);
                reader.readAsDataURL(file);
            });

            readAsDataURL.then(async (dataUrl) => {
                try {
                    // 将任何格式的图片转换为PNG格式
                    const pngDataUrl = await convertImageToPng(dataUrl);
                    // 创建一个模拟的角色数据对象
                    const charData = {
                        spec: 'chara_card_v3',
                        data: {
                            name: file.name.replace(/\.[^/.]+$/, ""), // 使用文件名作为角色名
                            description: t('imported-character'),
                            personality: '',
                            scenario: '',
                            first_mes: '',
                            mes_example: '',
                            system_prompt: '',
                            post_history_instructions: '',
                            creator_notes: '',
                            character_version: '1.0',
                            tags: [],
                            character_book: { entries: [] }
                        }
                    };
                    saveImportedCharacter(charData, pngDataUrl);
                } catch (err) {
                    console.error(currentLanguage === 'zh' ? "图片导入错误:" : "Image import error:", err);
                    alert(t('import-image-failed', { error: err.message || (currentLanguage === 'zh' ? '未知错误，请检查控制台。' : 'Unknown error, please check console.') }));
                }
            }).catch(err => {
                alert(t('file-read-error-with-name', { name: file.name, error: err }));
            });

        } else if (file.type === "application/json") {
            const reader = new FileReader();
            reader.onload = e => {
                try {
                    const charData = JSON.parse(e.target.result);
                    saveImportedCharacter(charData, null);
                } catch (err) {
                    console.error(currentLanguage === 'zh' ? "JSON导入错误:" : "JSON import error:", err);
                    alert(t('import-json-failed'));
                }
            };
            reader.readAsText(file);
        }
    }
    event.target.value = '';
}

/**
 * [MODIFIED] Saves an imported character card or lorebook to the database.
 * @param {object} originalCard - The parsed data from the imported file.
 * @param {string|null} avatarBase64 - The base64-encoded avatar image, if any.
 */
function saveImportedCharacter(originalCard, avatarBase64 = null) {
    if (!checkDbReady()) return;
    
    let charDataForDb;

    const isTavernLorebook = (originalCard.entries && typeof originalCard.entries === 'object' && !Array.isArray(originalCard.entries)) ||
                             (originalCard.extensions && originalCard.extensions.entries && typeof originalCard.extensions.entries === 'object' && !Array.isArray(originalCard.extensions.entries));

    if (originalCard.spec === 'chara_card_v3' && originalCard.data) {
        const data = originalCard.data;
        const extensions = data.extensions || {};
        const book = data.character_book || {};
        
        function convertV3EntryToInternal(entry) {
            const entryExt = entry.extensions || {};
            const internalEntry = {
                id: entry.id,
                keys: entry.keys || [],
                secondary_keys: entry.secondary_keys || [],
                secondary_keys_logic: entryExt.secondary_keys_logic || 'any',
                comment: entry.comment || '',
                content: entry.content || '',
                priority: entry.insertion_order || 100,
                enabled: entry.enabled,
                position: entry.position || 'before_char',
                constant: entry.constant || false,
                selective: entry.selective === undefined ? true : entry.selective,
                use_regex: entry.use_regex || false,
                prevent_recursion: entryExt.prevent_recursion || false,
                group: entryExt.group || '',
                scope: 'chat',
                display_index: entryExt.display_index || 0,
                depth: entryExt.depth || 0,
                wb_depth: entryExt.depth || 4,
                probability: entryExt.probability === undefined ? 100 : entryExt.probability,
                match_whole_words: entryExt.match_whole_words || false,
                case_sensitive: entryExt.case_sensitive || false,
                children: []
            };
            
            if (entry.children && entry.children.length > 0) {
                internalEntry.children = entry.children.map(child => convertV3EntryToInternal(child));
            }
            
            return internalEntry;
        }
        
        const internalBookEntries = (book.entries || []).map(entry => convertV3EntryToInternal(entry));

        charDataForDb = {
            name: data.name || '',
            gender: data.gender || '',
            topic: extensions.world || '',
            description: data.description || '',
            personality: data.personality || '',
            tags: data.tags || [],
            system_prompt: data.system_prompt || '',
            scenario: data.scenario || '',
            first_mes: data.first_mes || '',
            mes_example: data.mes_example || '',
            post_history_instructions: data.post_history_instructions || '',
            creator_notes: data.creator_notes || '',
            character_version: data.character_version || '',
            worldbook: internalBookEntries,
            isFavorite: extensions.fav || false,
        };

    } else if (originalCard.spec === 'chara_card_v2' && originalCard.data) {
        const data = originalCard.data;
        charDataForDb = {
            name: data.name || '',
            gender: data.gender || '',
            topic: data.topic || '',
            description: data.description || '',
            personality: data.personality || '',
            tags: Array.isArray(data.tags) ? data.tags : (typeof data.tags === 'string' ? data.tags.split(/[,、，\s]+/).map(t => t.trim()).filter(Boolean) : []),
            system_prompt: data.system_prompt || '',
            scenario: data.scenario || '',
            first_mes: data.first_mes || '',
            mes_example: data.mes_example || '',
            post_history_instructions: data.post_history_instructions || '',
            creator_notes: data.creatorcomment || '',
            character_version: '', // v2 doesn't have this field
            worldbook: (data.character_book && Array.isArray(data.character_book.entries)) ? data.character_book.entries : [],
        };
    } else if (isTavernLorebook) {
        // Handle SillyTavern Lorebook JSON
        console.log("Detected SillyTavern Lorebook format. Converting...");
        const internalBookEntries = convertTavernLorebookToInternal(originalCard);

        charDataForDb = {
            name: originalCard.name || t('imported-lorebook'),
            description: originalCard.description || t('lorebook-description'),
            gender: '',
            topic: '',
            personality: '',
            tags: [t('lorebook-tag')],
            system_prompt: '',
            scenario: '',
            first_mes: '',
            mes_example: '',
            post_history_instructions: '',
            creator_notes: '',
            character_version: '',
            worldbook: internalBookEntries,
            isFavorite: false,
        };
        console.log("Conversion complete. Processed entries:", internalBookEntries.length);
    } else {
        charDataForDb = JSON.parse(JSON.stringify(originalCard));
        charDataForDb.tags = Array.isArray(charDataForDb.tags) ? charDataForDb.tags : (typeof charDataForDb.tags === 'string' ? charDataForDb.tags.split(/[,、，\s]+/).map(t => t.trim()).filter(Boolean) : []);
        charDataForDb.personality = charDataForDb.personality || '';
        charDataForDb.creator_notes = charDataForDb.creator_notes || '';
        charDataForDb.character_version = charDataForDb.character_version || '';
        charDataForDb.worldbook = charDataForDb.worldbook || [];
    }

    charDataForDb.avatar = avatarBase64 || originalCard.avatar || null;
    charDataForDb.internalTags = charDataForDb.internalTags || [];
    charDataForDb.isFavorite = charDataForDb.isFavorite || false;
    charDataForDb.lastUsed = Date.now();

    const transaction = db.transaction(['characters'], 'readwrite');
    const store = transaction.objectStore('characters');
    const addRequest = store.add(charDataForDb);
    
    addRequest.onsuccess = () => {
        if (document.getElementById('library-view').style.display !== 'none') {
            renderUI();
        }
    };
    addRequest.onerror = (e) => {
        console.error(currentLanguage === 'zh' ? "保存导入角色失败:" : "Failed to save imported character:", e.target.error);
        alert(t('save-import-failed'));
    }
}


function downloadCharacter() {
    if (!checkDbReady()) return;
    const v3Card = buildLiveExportCard();
    const blob = new Blob([JSON.stringify(v3Card, null, 2)], { type: 'application/json' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = (v3Card.data && v3Card.data.name ? v3Card.data.name : 'character') + '.json';
    a.click();
    URL.revokeObjectURL(a.href);
}

async function downloadCharacterAsPng() {
    if (!checkDbReady()) return;
    const v3Card = buildLiveExportCard();
    const cardData = buildCardObject();
    if (!v3Card.data || !v3Card.data.name) {
        alert("请输入角色名以生成PNG角色卡。");
        return;
    }
    const base64Data = btoa(unescape(encodeURIComponent(JSON.stringify(v3Card))));
    const imageToUse = cardData.avatar || document.getElementById('avatar-preview').src || createDefaultImage('2:3');
    const finalPngBlob = await embedDataInPng(imageToUse, base64Data);
    const a = document.createElement('a');
    a.href = URL.createObjectURL(finalPngBlob);
    a.download = (v3Card.data.name || 'character') + '.png';
    a.click();
    URL.revokeObjectURL(a.href);
}

function downloadAsWorldbookFile() {
    if (!checkDbReady()) return;
    const lorebookData = buildWorldbookExportObject();
    const blob = new Blob([JSON.stringify(lorebookData, null, 2)], { type: 'application/json' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    let filename = 'lorebook';
    if (lorebookData.originalData && lorebookData.originalData.name) {
        filename = lorebookData.originalData.name.replace(`(${t('world-knowledge-book')}) `, '');
    }
    a.download = filename + '.json';
    a.click();
    URL.revokeObjectURL(a.href);
}

// --- CRUD Operations ---
function saveCharacter() {
    if (!checkDbReady()) return;

    const card = buildCardObject();
    if (!card.name) {
        alert("请输入角色名称。");
        return;
    }

    card.internalTags = card.internalTags.filter(internalTag => card.tags.includes(internalTag));

    // --- 开始修复 ---
    // 创建一个专门用于存储的"干净"版本的卡片数据对象
    const cardForDb = { ...card };
    // 使用新函数清理世界书数据，移除所有对DOM元素的引用
    cardForDb.worldbook = cleanWorldbookForStorage(card.worldbook);
    // --- 修复结束 ---

    const transaction = db.transaction(['characters'], 'readwrite');
    const store = transaction.objectStore('characters');
    
    cardForDb.lastUsed = Date.now(); // 确保更新的是干净对象的时间戳
    
    // 将清理过的、不含DOM元素的对象存入数据库
    const request = store.put(cardForDb);

    request.onsuccess = () => {
        alert(t('character-saved', { name: card.name }));
        // 强制刷新UI以确保头像正确显示
        setTimeout(() => {
            showLibraryView();
        }, 100);
    };
            request.onerror = (e) => {
            alert(t('save-failed'));
            console.error(currentLanguage === 'zh' ? "保存失败:" : "Save failed:", e.target.error);
        };
}

function isPureLorebook(char) {
    // It must have a worldbook to be considered a lorebook.
    if (!char.worldbook || char.worldbook.length === 0) {
        return false;
    }

    // List of fields that MUST be empty for it to be a "pure" lorebook.
    const mustBeEmptyFields = [
        'gender', 
        'topic', 
        'description', 
        'personality', 
        'system_prompt', 
        'scenario', 
        'first_mes', 
        'mes_example', 
        'post_history_instructions'
    ];

    for (const field of mustBeEmptyFields) {
        const value = char[field];
        if (value && typeof value === 'string' && value.trim() !== '') {
            return false; // If any of these string fields have content, it's not a pure lorebook.
        }
    }

    // The 'tags' field must also be empty, but we can allow the default 'lorebook' tag.
    if (char.tags && Array.isArray(char.tags) && char.tags.length > 0) {
        const filteredTags = char.tags.filter(tag => tag !== t('lorebook-tag'));
        if (filteredTags.length > 0) {
            return false;
        }
    }

    return true;
}

function buildWorldbookExportObjectFromData(cardData) {
    const v3Card = buildV3Card(cardData);

    // This is the format SillyTavern uses for its lorebooks.
    const lorebookEntries = {};
    if (v3Card.data.character_book && v3Card.data.character_book.entries) {
        v3Card.data.character_book.entries.forEach((entry, index) => {
            const tavernEntry = {
                uid: entry.id,
                key: entry.keys,
                keysecondary: entry.secondary_keys,
                comment: entry.comment,
                content: entry.content,
                constant: entry.constant,
                selective: entry.selective,
                selectiveLogic: 0,
                addMemo: true,
                order: entry.insertion_order,
                position: 0,
                disable: !entry.enabled,
                excludeRecursion: entry.extensions.prevent_recursion,
                preventRecursion: entry.extensions.prevent_recursion,
                probability: entry.extensions.probability,
                useProbability: true,
                depth: entry.extensions.depth,
                displayIndex: index,
            };
            lorebookEntries[index] = tavernEntry;
        });
    }

    return {
        entries: lorebookEntries,
        originalData: v3Card.data.character_book || {
             name: `(${t('world-knowledge-book')}) ${cardData.name || 'Character Book'}`,
             description: cardData.creator_notes || `Character book for ${cardData.name}.`,
             scan_depth: 10,
             token_budget: 2048,
             recursive_scanning: false,
             entries: []
        }
    };
}

async function exportCharacter(id) {
    if (!checkDbReady()) return;
    const transaction = db.transaction(['characters'], 'readonly');
    const store = transaction.objectStore('characters');
    const request = store.get(id);

    request.onsuccess = async (e) => {
        const charData = e.target.result;
        if (!charData) {
            alert('未找到角色!');
            return;
        }

        if (isPureLorebook(charData)) {
            const lorebookData = buildWorldbookExportObjectFromData(charData);
            const blob = new Blob([JSON.stringify(lorebookData, null, 2)], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = (charData.name || 'lorebook') + '.json';
            a.click();
            URL.revokeObjectURL(a.href);
        } else {
            const v3Card = buildV3Card(charData);
            if (charData.avatar) {
                const base64Data = btoa(unescape(encodeURIComponent(JSON.stringify(v3Card))));
                const finalPngBlob = await embedDataInPng(charData.avatar, base64Data);
                const a = document.createElement('a');
                a.href = URL.createObjectURL(finalPngBlob);
                a.download = (v3Card.data.name || 'character') + '.png';
                a.click();
                URL.revokeObjectURL(a.href);
            } else {
                const blob = new Blob([JSON.stringify(v3Card, null, 2)], { type: 'application/json' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = (v3Card.data && v3Card.data.name ? v3Card.data.name : 'character') + '.json';
                a.click();
                URL.revokeObjectURL(a.href);
            }
        }
    };

    request.onerror = (e) => {
        alert('检索角色以供导出失败。');
        console.error("Export failed:", e.target.error);
    };
}

function deleteCharacter(id) {
    if (!checkDbReady()) return;
    if (confirm("确定要删除这个角色吗？")) {
        const transaction = db.transaction(['characters'], 'readwrite');
        transaction.objectStore('characters').delete(id);
        transaction.oncomplete = () => {
            renderUI();
        };
    }
}

function toggleFavorite(id, event) {
    if (!checkDbReady()) return;
    event.stopPropagation();
    const transaction = db.transaction(['characters'], 'readwrite');
    const store = transaction.objectStore('characters');
    const request = store.get(id);
    request.onsuccess = e => {
        const charData = e.target.result;
        charData.isFavorite = !charData.isFavorite;
        store.put(charData);
    };
    event.target.classList.toggle('favorited');
}


// --- UI Rendering ---
async function renderUI() {
    if (!checkDbReady()) return;
    
    const transaction = db.transaction(['characters'], 'readonly');
    const allChars = await new Promise((resolve, reject) => {
        const req = transaction.objectStore('characters').getAll();
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
    });
    allChars.sort((a,b) => (b.isFavorite - a.isFavorite) || (b.lastUsed || 0) - (a.lastUsed || 0));

    renderTags(allChars);
    renderCharacters(allChars);
}

function renderTags(characters) {
    const tagContainer = document.getElementById('tag-container');
    const internalTags = new Set();
    const extraTags = new Set(); 

    characters.forEach(char => {
        (char.internalTags || []).forEach(tag => { if (tag) internalTags.add(tag.trim()); });
        const tags = Array.isArray(char.tags) ? char.tags : (typeof char.tags === 'string' ? char.tags.split(/[,、，\s]+/) : []);
        tags.forEach(tag => { if (tag) extraTags.add(tag.trim()); });
    });

    let tagsHtml = `<div class="tag type-special ${activeFilters.has('FAVORITE') ? 'active' : ''}" onclick="toggleFilter('FAVORITE', event)">⭐ 收藏</div>`;
    [...extraTags].sort().forEach(tag => { tagsHtml += `<div class="tag type-personality ${activeFilters.has(tag) ? 'active' : ''}" onclick="toggleFilter('${tag}', event)">${tag}</div>`; });
    [...internalTags].sort().forEach(tag => { tagsHtml += `<div class="tag type-internal ${activeFilters.has(tag) ? 'active' : ''}" onclick="toggleFilter('${tag}', event)">${tag}</div>`; });

    tagContainer.innerHTML = tagsHtml;
}

function renderCharacters(characters) {
    const grid = document.getElementById('character-grid');
    grid.innerHTML = '';

    // 优化：实现图片懒加载
    const lazyImageObserver = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                const card = entry.target;
                const imageUrl = card.dataset.bgImage;
                card.style.backgroundImage = `var(--card-overlay), url('${imageUrl}')`;
                observer.unobserve(card); // 停止观察已加载的图片
            }
        });
    });

    let filteredChars = characters;
    if (activeFilters.size > 0) {
        filteredChars = characters.filter(char => {
            if (activeFilters.has('FAVORITE') && !char.isFavorite) return false;
            
            const regularFilters = [...activeFilters].filter(f => f !== 'FAVORITE');
            if (regularFilters.length > 0) {
                const tagSet = new Set([
                    ...(Array.isArray(char.tags) ? char.tags : (typeof char.tags === 'string' ? char.tags.split(/[,、，\s]+/) : [])),
                    ...(char.internalTags || [])
                ].map(t => t.trim()));
                return regularFilters.every(filter => tagSet.has(filter));
            }
            return true;
        });
    }

    if (filteredChars.length === 0) {
        grid.innerHTML = `<p style="grid-column: 1 / -1; text-align: center;">${t('no-characters-found')}</p>`;
        return;
    }

    filteredChars.forEach(char => {
        const card = document.createElement('div');
        card.className = 'character-card';
        
        // 优化：为懒加载准备图片URL
        let imageToDisplay;
        if (char.avatar && char.avatar.trim() !== '') {
            imageToDisplay = char.avatar;
        } else {
            imageToDisplay = createDefaultImage('2:3');
        }
        card.dataset.bgImage = imageToDisplay;
        
        // 初始时可以设置一个占位符背景
        card.style.backgroundImage = `var(--default-card-bg)`;

        const headerDiv = document.createElement('div');
        const cardHeader = document.createElement('div');
        cardHeader.className = 'card-header';
        
        const h2 = document.createElement('h2');
        h2.textContent = char.name || '无名角色';
        
        const favButton = document.createElement('button');
        favButton.className = `favorite-btn ${char.isFavorite ? 'favorited' : ''}`;
        favButton.innerHTML = '★';
        favButton.onclick = (event) => toggleFavorite(char.id, event);
        
        cardHeader.appendChild(h2);
        cardHeader.appendChild(favButton);
        
        const descriptionP = document.createElement('p');
        descriptionP.className = 'card-description';
        descriptionP.textContent = char.description || t('no-description');
        
        const tagsDiv = document.createElement('div');
        tagsDiv.className = 'card-tags tag-group';
        const tagsArray = Array.isArray(char.tags) ? char.tags : (typeof char.tags === 'string' ? char.tags.split(/[,、，\s]+/) : []);
        const personalityTagsHtml = tagsArray.filter(t => t).map(tag => `<span class="tag type-personality">${tag.trim()}</span>`).join(' ');
        const internalTagsHtml = (char.internalTags || []).filter(t => t).map(tag => `<span class="tag type-internal">${tag.trim()}</span>`).join(' ');
        tagsDiv.innerHTML = personalityTagsHtml + ' ' + internalTagsHtml;
        
        headerDiv.appendChild(cardHeader);
        headerDiv.appendChild(descriptionP);
        headerDiv.appendChild(tagsDiv);

        const footerDiv = document.createElement('div');
        footerDiv.className = 'card-footer';
        footerDiv.innerHTML = `
            <button onclick="showEditorView(${char.id})">✏️ ${t('edit')}</button>
            <button onclick="exportCharacter(${char.id})">📤 ${t('export')}</button>
            <button onclick="deleteCharacter(${char.id})">🗑️ ${t('delete')}</button>
        `;
        
        card.appendChild(headerDiv);
        card.appendChild(footerDiv);
        grid.appendChild(card);
        
        // 优化：观察新创建的卡片
        lazyImageObserver.observe(card);
    });
}


function toggleFilter(filterName, event) {
    event.stopPropagation();
    const button = event.currentTarget;
    button.classList.toggle('active');
    activeFilters.has(filterName) ? activeFilters.delete(filterName) : activeFilters.add(filterName);
    renderUI();
}

// --- Editor Form Management ---
function clearEditorForm() {
    const fields = ['charId', 'name', 'description', 'personality', 'system_prompt', 'scenario', 'first_mes', 'mes_example', 'internalTags', 'isFavorite', 'originalCardData', 'topic', 'gender', 'tags', 'post_history_instructions', 'creator_notes', 'character_version'];
    fields.forEach(id => { 
        const el = document.getElementById(id);
        if (el) el.value = ''; 
    });
    document.querySelectorAll('.ai-undo-button').forEach(btn => btn.style.display = 'none');
    document.getElementById('worldbook-entries-container').innerHTML = '';
    document.getElementById('avatar-input').value = '';
    document.getElementById('avatar-preview').src = createDefaultImage('2:3');
    avatarImageBase64 = null;
    document.querySelector('#editor-view .editor-body').scrollTop = 0;
}

function populateEditorForm(charData) {
    document.getElementById('charId').value = charData.id || '';
    document.getElementById('name').value = charData.name || '';
    document.getElementById('gender').value = charData.gender || '';
    document.getElementById('topic').value = charData.topic || '';
    document.getElementById('description').value = charData.description || '';
    document.getElementById('tags').value = Array.isArray(charData.tags) ? charData.tags.join(', ') : (typeof charData.tags === 'string' ? charData.tags : '');
    document.getElementById('personality').value = charData.personality || '';
    document.getElementById('system_prompt').value = charData.system_prompt || '';
    document.getElementById('scenario').value = charData.scenario || '';
    document.getElementById('first_mes').value = charData.first_mes || '';
    document.getElementById('mes_example').value = charData.mes_example || '';
    document.getElementById('post_history_instructions').value = charData.post_history_instructions || '';
    document.getElementById('creator_notes').value = charData.creator_notes || '';
    document.getElementById('character_version').value = charData.character_version || '';
    document.getElementById('internalTags').value = JSON.stringify(charData.internalTags || []);
    document.getElementById('isFavorite').value = charData.isFavorite || false;
    
    renderWorldbookFromData(charData.worldbook || []);

    // 新增: 角色加载后，自动调整所有文本框大小以适应内容，改善移动端编辑体验
    document.querySelectorAll('#editor-view textarea').forEach(autoResizeTextarea);

    if (charData.avatar) {
        // 强制显示任何图片格式
        if (charData.avatar.startsWith('data:image/')) {
            document.getElementById('avatar-preview').src = charData.avatar;
            avatarImageBase64 = charData.avatar;
        } else if (charData.avatar.startsWith('http://') || charData.avatar.startsWith('https://')) {
            document.getElementById('avatar-preview').src = charData.avatar;
            avatarImageBase64 = charData.avatar;
        } else if (charData.avatar.trim() !== '') {
            document.getElementById('avatar-preview').src = charData.avatar;
            avatarImageBase64 = charData.avatar;
        } else {
            document.getElementById('avatar-preview').src = createDefaultImage('2:3');
            avatarImageBase64 = null;
        }
    } else {
        document.getElementById('avatar-preview').src = createDefaultImage('2:3');
        avatarImageBase64 = null;
    }
    document.querySelectorAll('.ai-undo-button').forEach(btn => btn.style.display = 'none');
    document.querySelector('#editor-view .editor-body').scrollTop = 0;
}

document.getElementById('avatar-input').addEventListener('change', function(event) {
    const file = event.target.files[0];
    if (!file) return;

    if (!file.type.startsWith("image/")) {
        alert(t('upload-image-only'));
        event.target.value = '';
        return;
    }

    const reader = new FileReader();
    reader.onload = async function(e) {
        try {
            // 将任何格式的图片转换为PNG格式
            const pngDataUrl = await convertImageToPng(e.target.result);
            avatarImageBase64 = pngDataUrl;
            document.getElementById('avatar-preview').src = pngDataUrl;
            console.log(currentLanguage === 'zh' ? '头像已转换为PNG格式:' : 'Avatar converted to PNG format:', pngDataUrl.substring(0, 50) + '...');
        } catch (error) {
            console.error(currentLanguage === 'zh' ? '图片转换失败:' : 'Image conversion failed:', error);
            alert(t('image-process-failed', { error: error.message }));
            event.target.value = '';
        }
    };
    reader.onerror = function() {
        alert(t('file-read-error'));
        event.target.value = '';
    };
    reader.readAsDataURL(file);
});

// 用于在保存到数据库前，清理世界书数据中的DOM元素引用
function cleanWorldbookForStorage(entries) {
    if (!entries) return [];
    return entries.map(entry => {
        // 创建一个不包含 'element' 属性的新对象
        const { element, ...cleanedEntry } = entry;

        // 对子条目进行递归清理
        if (entry.children && entry.children.length > 0) {
            cleanedEntry.children = cleanWorldbookForStorage(entry.children);
        }
        return cleanedEntry;
    });
}

// --- Object Building ---
function buildCardObject() {
    const worldbookData = buildWorldbookDataFromDOM();
    
    const card = {
        name: document.getElementById('name').value.trim(),
        gender: document.getElementById('gender').value.trim(),
        topic: document.getElementById('topic').value.trim(),
        description: document.getElementById('description').value.trim(),
        personality: document.getElementById('personality').value.trim(),
        tags: document.getElementById('tags').value.trim().split(/[,、，\s]+/).map(t => t.trim()).filter(Boolean),
        system_prompt: document.getElementById('system_prompt').value.trim(),
        scenario: document.getElementById('scenario').value.trim(),
        first_mes: document.getElementById('first_mes').value.trim(),
        mes_example: document.getElementById('mes_example').value.trim(),
        post_history_instructions: document.getElementById('post_history_instructions').value.trim(),
        creator_notes: document.getElementById('creator_notes').value.trim(),
        character_version: document.getElementById('character_version').value.trim(),
        internalTags: JSON.parse(document.getElementById('internalTags').value || '[]'),
        isFavorite: (document.getElementById('isFavorite').value === 'true'),
        avatar: avatarImageBase64,
        worldbook: worldbookData
    };
    const charId = parseInt(document.getElementById('charId').value, 10);
    if (!isNaN(charId)) card.id = charId;
    
    return card;
}


function buildLiveExportCard() {
    const currentCardState = buildCardObject();
    return buildV3Card(currentCardState);
}

function hasWorldbookContent(entries) {
    if (!entries || entries.length === 0) {
        return false;
    }
    for (const entry of entries) {
        if (entry.content && entry.content.trim() !== '') {
            return true;
        }
        if (entry.children && entry.children.length > 0) {
            if (hasWorldbookContent(entry.children)) {
                return true;
            }
        }
    }
    return false;
}

function buildV3Card(cardData) {
    // 递归函数：将条目及其子条目转换为V3格式
    function convertEntryToV3(entry) {
        const v3Entry = {
            id: entry.id,
            keys: entry.keys || [],
            secondary_keys: entry.secondary_keys || [],
            comment: entry.comment || '',
            content: entry.content || '',
            constant: entry.constant || false,
            selective: entry.selective === undefined ? true : entry.selective,
            insertion_order: entry.priority || 100,
            enabled: entry.enabled === undefined ? true : entry.enabled,
            position: entry.position || 'before_char',
            use_regex: entry.use_regex || false,
            extensions: {
                position: 0,
                exclude_recursion: false,
                display_index: entry.display_index,
                probability: entry.probability === undefined ? 100 : entry.probability,
                useProbability: true,
                depth: entry.wb_depth || 4,
                selectiveLogic: 0,
                group: entry.group || "",
                group_override: false,
                group_weight: 100,
                prevent_recursion: entry.prevent_recursion || false,
                delay_until_recursion: false,
                scan_depth: null,
                match_whole_words: entry.match_whole_words || null,
                use_group_scoring: false,
                case_sensitive: entry.case_sensitive || null,
                automation_id: "",
                role: 0,
                vectorized: false,
                sticky: 0,
                cooldown: 0,
                delay: 0,
                secondary_keys_logic: entry.secondary_keys_logic || 'any'
            }
        };
        
        // 递归处理子条目
        if (entry.children && entry.children.length > 0) {
            v3Entry.children = entry.children.map(child => convertEntryToV3(child));
        }
        
        return v3Entry;
    }
    
    const v3BookEntries = (cardData.worldbook || []).map(entry => convertEntryToV3(entry));
    const worldbookHasContent = hasWorldbookContent(cardData.worldbook);

    const dataObject = {
        name: cardData.name || '',
        description: cardData.description || '',
        personality: cardData.personality || '',
        scenario: cardData.scenario || '',
        first_mes: cardData.first_mes || '',
        mes_example: cardData.mes_example || '',
        creator_notes: cardData.creator_notes || 'Created with Nika Character Studio',
        system_prompt: cardData.system_prompt || '',
        post_history_instructions: cardData.post_history_instructions || '',
        tags: cardData.tags || [],
        creator: 'Nika Studio User',
        character_version: cardData.character_version || '1.0',
        alternate_greetings: [],
        group_only_greetings: [],
        extensions: {
            talkativeness: "0.5",
            fav: cardData.isFavorite || false,
            world: cardData.topic || '',
            depth_prompt: { prompt: "", depth: 4, role: "system" }
        },
        character_book: worldbookHasContent ? {
            name: `(${t('world-knowledge-book')}) ${cardData.name || 'Character Book'}`,
            description: cardData.creator_notes || `Character book for ${cardData.name}.`,
            scan_depth: 10,
            token_budget: 2048,
            recursive_scanning: false,
            entries: v3BookEntries,
        } : undefined,
    };

    return {
        spec: 'chara_card_v3',
        spec_version: '3.0',
        name: dataObject.name,
        description: dataObject.description,
        personality: dataObject.personality,
        scenario: dataObject.scenario,
        first_mes: dataObject.first_mes,
        mes_example: dataObject.mes_example,
        creatorcomment: dataObject.creator_notes,
        tags: dataObject.tags,
        create_date: new Date().toISOString(),
        avatar: "none",
        talkativeness: "0.5",
        fav: dataObject.extensions.fav,
        data: dataObject,
    };
}

function buildWorldbookExportObject() {
    const cardData = buildCardObject();
    return buildWorldbookExportObjectFromData(cardData);
}

function injectEntry(entry) {
  const userPromptTextarea = document.getElementById('user_prompt');
  const comment = entry.comment;
  const content = entry.content;
  let newText;

  if (content.trim().length > 0) {
    newText = `[${comment}：${content}]`;
  } else {
    newText = `[${comment}]`;
  }

  // 获取光标位置
  const startPos = userPromptTextarea.selectionStart;
  const endPos = userPromptTextarea.selectionEnd;

  // 插入文本
  const textBefore = userPromptTextarea.value.substring(0, startPos);
  const textAfter = userPromptTextarea.value.substring(endPos, userPromptTextarea.value.length);
  userPromptTextarea.value = textBefore + newText + textAfter;

  // 恢复光标位置
  userPromptTextarea.selectionStart = startPos + newText.length;
  userPromptTextarea.selectionEnd = startPos + newText.length;

  // 聚焦到文本框
  userPromptTextarea.focus();
}

// ====================================================================================
// --- AI HELPER FUNCTIONS ---
// ====================================================================================

function initializeLoverSwitch() {
    const loverSwitch = document.getElementById('lover-switch');
    if (loverSwitch) {
        loverSwitch.addEventListener('change', (event) => {
            toggleAiButtonText(event.target.checked);
        });
    }
}

function toggleAiButtonText(isLover) {
    const aiButtons = document.querySelectorAll('.ai-button');
    const newText = isLover ? t('generate-companion') : t('ai-help-write');
    aiButtons.forEach(button => {
        button.textContent = newText;
    });
}

function getLoverPromptPrefix() {
    return `重要指令：你是一个小说角色创作家，你要生成的角色把读者当恋人或者密友，并且读者的代词为"{{user}}"，角色的代词为"{{char}}，生成相关角色的信息\n\n`;
}

// 新增: 撤销AI补全的功能
function undoAiCompletion(undoButton) {
    const container = undoButton.closest('.field-group, .entry-grid');
    if (!container) return;
    
    const targetElement = container.querySelector('textarea, input:not([type=file]):not([type=checkbox])');
    if (targetElement && targetElement.dataset.aiBackup !== undefined) {
        targetElement.value = targetElement.dataset.aiBackup;
        delete targetElement.dataset.aiBackup; // 清除备份
        undoButton.style.display = 'none'; // 隐藏自己
    }
}


async function callApi(prompt, button) {
    const apiSettings = loadApiSettings();
    const provider = apiSettings.provider;

    const isLover = document.getElementById('lover-switch').checked;
    const finalPrompt = isLover ? getLoverPromptPrefix() + prompt : prompt;

    console.log(`Using API provider: ${provider}`);
    console.log("Final prompt being sent to API:", finalPrompt);

    const originalText = button.textContent;
    button.disabled = true;
    button.textContent = t('generating');

    const undoButton = button.nextElementSibling;
    if (undoButton && undoButton.classList.contains('ai-undo-button')) {
        undoButton.style.display = 'none';
    }

    let requestUrl, requestOptions;

    try {
    const geminiBody = {
        contents: [{ parts: [{ text: finalPrompt }] }],
        generationConfig: { temperature: 0.7, topK: 1, topP: 1, maxOutputTokens: 8192 }
    };

        switch (provider) {
            case 'deepseek':
                if (!apiSettings.deepseek.apiKey) throw new Error('DeepSeek API Key is missing.');
                requestUrl = "https://api.deepseek.com/chat/completions";
                requestOptions = {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiSettings.deepseek.apiKey}` },
                    body: JSON.stringify({ model: "deepseek-chat", messages: [{ "role": "user", "content": finalPrompt }] })
                };
                break;

            case 'gemini':
                if (!apiSettings.gemini.apiKey) throw new Error('Gemini API Key is missing.');
                const geminiModel = apiSettings.gemini.model || 'gemini-2.5-flash';
                requestUrl = `https://generativelanguage.googleapis.com/v1beta/models/${geminiModel}:generateContent?key=${apiSettings.gemini.apiKey}`;
                requestOptions = {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(geminiBody)
                };
                break;
            
            case 'gemini-proxy':
                if (!apiSettings['gemini-proxy'].endpoint) throw new Error('Gemini Proxy Endpoint is missing.');
                if (!apiSettings['gemini-proxy'].apiKey) throw new Error('Gemini API Key for proxy is missing.');
                
                let proxyBaseUrl = apiSettings['gemini-proxy'].endpoint;
                if (!proxyBaseUrl.startsWith('http')) proxyBaseUrl = 'https://' + proxyBaseUrl;
                // remove trailing slash if present
                if (proxyBaseUrl.endsWith('/')) {
                    proxyBaseUrl = proxyBaseUrl.slice(0, -1);
                }

                const geminiProxyModel = apiSettings['gemini-proxy'].model || 'gemini-2.5-flash';
                requestUrl = `${proxyBaseUrl}/${geminiProxyModel}:generateContent?key=${apiSettings['gemini-proxy'].apiKey}`;
                requestOptions = {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }, // No Authorization header
                    body: JSON.stringify(geminiBody)
                };
                break;

        case 'local':
        case 'tavern':
            const isLocal = provider === 'local';
            const providerSettings = apiSettings[provider];
            const endpoint = providerSettings.endpoint;

            if (!endpoint) throw new Error(`API Endpoint for ${provider} is missing.`);

            let finalEndpoint = endpoint;
            if (finalEndpoint.endsWith('/v1')) {
                finalEndpoint += '/chat/completions';
            }
            if (!finalEndpoint.startsWith('http')) {
                // Local endpoints are http, not https
                finalEndpoint = (isLocal ? 'http://' : 'https://') + finalEndpoint;
            }
            requestUrl = finalEndpoint;

            const headers = { 'Content-Type': 'application/json' };
            // Only add auth header for tavern if key exists
            if (!isLocal && providerSettings.apiKey) {
                headers['Authorization'] = `Bearer ${providerSettings.apiKey}`;
            }

            requestOptions = {
                method: 'POST',
                headers: headers,
                body: JSON.stringify({
                    model: providerSettings.model || 'local-model', // For local, model name is often ignored
                    messages: [{ "role": "user", "content": finalPrompt }],
                    stream: false
                })
            };
            break;

            default:
                throw new Error(`Unknown API provider: ${provider}`);
        }

        const response = await fetch(requestUrl, requestOptions);

        if (!response.ok) {
            const errorBody = await response.text();
            let errorMessage = errorBody;
            try {
                const errorJson = JSON.parse(errorBody);
                errorMessage = errorJson.error?.message || JSON.stringify(errorJson);
            } catch (e) { /* Ignore if not JSON */ }
            throw new Error(t('api-request-failed', { status: response.statusText, message: errorMessage }));
        }

        const data = await response.json();
        
        // Handle different response structures
        if (provider === 'gemini' || provider === 'gemini-proxy') {
            if (data.candidates && data.candidates.length > 0) {
                return data.candidates[0].content.parts[0].text;
            }
            // Handle error response from Gemini
            if (data.error) {
                throw new Error(`Gemini API Error: ${data.error.message}`);
            }
        }
        // For DeepSeek and Tavern (assuming OpenAI compatible)
        if (data.choices && data.choices.length > 0) {
            return data.choices[0].message.content;
        }
        
        // Fallback for unexpected response structures
        throw new Error('Unexpected API response structure. Check console for details.');

    } catch (error) {
        console.error(`API error with provider ${provider}:`, error);
        alert(`${t('ai-completion-failed')}\nError: ${error.message}`);
        return null;
    } finally {
        button.disabled = false;
        button.textContent = originalText;
    }
}

async function callDeepSeek(fieldId) {
    const button = event.target;
    const targetElement = document.getElementById(fieldId);
    if (!targetElement) return;

    targetElement.dataset.aiBackup = targetElement.value;
    
    const labelText = document.querySelector(`label[for='${fieldId}']`).innerText.replace(' (逗号分隔)','');

    getAiGuidance(t('ai-guidance-title') + `: ${labelText}`, async (userGuidance) => {
        const currentCard = buildCardObject();
        const existingEntries = buildWorldbookDataFromDOM();
        const existingEntriesText = existingEntries.map(e => `- ${e.comment}: ${e.content.substring(0, 100)}...`).join('\n');

        let prompt = `你是一位专业的角色设定师。请根据以下已经提供的角色信息，为我生成或补全【${labelText}】这一项。
请直接返回最适合填入该项的内容，语言风格要自然，不要包含任何额外解释、标题或标签。

已提供信息:
- 主题/世界观: ${currentCard.topic || '未指定'}
- 角色名: ${currentCard.name || '未指定'}
- 性别: ${currentCard.gender || '未指定'}
- 角色描述: ${currentCard.description || '未指定'}
- 分类标签: ${(currentCard.tags && currentCard.tags.length > 0) ? currentCard.tags.join(', ') : '未指定'}
- 个性: ${currentCard.personality || '未指定'}
- 场景设定: ${currentCard.scenario || '未指定'}
- 首次发言: ${currentCard.first_mes || '未指定'}
- 范例对话: ${currentCard.mes_example || '未指定'}
- 已有的世界书条目 (用于参考):
${existingEntriesText || '无'}
`;

        if (userGuidance) {
            prompt += `\n用户的额外指令: ${userGuidance}\n`;
        }
        prompt += `\n现在，请生成【${labelText}】的内容。`;
        
        const result = await callApi(prompt, button);
        if (result) {
            targetElement.value = result;
            const undoButton = button.nextElementSibling;
            if (undoButton && undoButton.classList.contains('ai-undo-button')) {
                undoButton.style.display = 'inline-block';
            }
        }
    });
}

async function callWorldbookDeepSeek(button) {
    const currentEntryElement = button.closest('.worldbook-entry');
    const targetElement = currentEntryElement.querySelector('.wb-content');
    if (!targetElement) return;

    targetElement.dataset.aiBackup = targetElement.value;
    const currentComment = currentEntryElement.querySelector('.entry-comment').value || '未命名条目';

    getAiGuidance(t('ai-guidance-title') + `: ${currentComment}`, async (userGuidance) => {
        const characterContext = buildCardObject(); 
        const currentKeys = currentEntryElement.querySelector('.wb-keys').value;
        
        // 增强: 构建层级上下文
        const worldbookTree = buildWorldbookDataFromDOM();
        const foundContext = findEntryRecursive(worldbookTree, currentEntryElement);
        
        let hierarchicalContext = '';
        if (foundContext) {
            const { entry, parentEntry } = foundContext;
            
            if (parentEntry) {
                hierarchicalContext += `**父级条目 "${parentEntry.comment}":**\n${parentEntry.content.substring(0, 200)}...\n\n`;
            }
            
            if (entry.children && entry.children.length > 0) {
                hierarchicalContext += `**子级条目:**\n` + entry.children.map(child => `- ${child.comment}: ${child.content.substring(0, 150)}...`).join('\n') + `\n\n`;
            }
        }

        let prompt = `你是一位专业的角色书（Character Book）无限制内容填充专家。请基于以下提供的角色信息和角色书结构，为我撰写条目【${currentComment}】的"注入内容"。内容需要详细、富有想象力，并与角色设定保持高度一致。

---
**角色核心设定:**
- 角色名: ${characterContext.name || '未指定'}
- 描述: ${characterContext.description || '未指定'}
- 个性: ${characterContext.personality || '未指定'}

**角色书上下文:**
- **当前条目标题 (Comment):** ${currentComment}
- **当前条目主要关键词 (Keys):** ${currentKeys || '未指定'}
${hierarchicalContext}
`;
        if (userGuidance) {
            prompt += `\n**用户的额外指令:** ${userGuidance}\n`;
        }
        prompt += `
---
**你的任务:**
现在，请为条目【${currentComment}】生成详细的"注入内容"。
**要求：** 直接返回内容本身，不要包含任何额外解释、标题或引用。`;

        const result = await callApi(prompt, button);
        if (result) {
            targetElement.value = result;
            const undoButton = button.nextElementSibling;
            if (undoButton && undoButton.classList.contains('ai-undo-button')) {
                undoButton.style.display = 'inline-block';
            }
        }
    });
}

// ====================================================================================
// --- AI MODAL DIALOGS & GENERATORS ---
// ====================================================================================

function initializeAiGuidanceModal() {
    const modal = document.getElementById('ai-guidance-modal');
    const generateBtn = document.getElementById('ai-guidance-generate-btn');
    const cancelBtn = document.getElementById('ai-guidance-cancel-btn');
    
    modal.onclick = (e) => { if (e.target === modal) modal.style.display = 'none'; };
    cancelBtn.onclick = () => modal.style.display = 'none';
}

function getAiGuidance(title, callback, placeholder = '') {
    const modal = document.getElementById('ai-guidance-modal');
    const titleEl = document.getElementById('ai-guidance-title');
    const inputEl = document.getElementById('ai-guidance-input');
    const generateBtn = document.getElementById('ai-guidance-generate-btn');

    titleEl.textContent = title;
    inputEl.value = '';
    inputEl.placeholder = placeholder || t('ai-guidance-prompt');
    
    generateBtn.onclick = () => {
        modal.style.display = 'none';
        callback(inputEl.value.trim());
    };

    modal.style.display = 'flex';
    inputEl.focus();
}

function initializeNameGeneratorModal() {
    const modal = document.getElementById('name-generator-modal');
    const cancelButton = document.getElementById('cancel-name-generation-btn');
    const regenerateButton = document.getElementById('regenerate-names-btn');

    modal.addEventListener('click', (event) => {
        if (event.target === modal) modal.style.display = 'none';
    });
    cancelButton.addEventListener('click', () => modal.style.display = 'none');
    regenerateButton.addEventListener('click', () => {
        const generatorButton = document.querySelector('.name-generator-btn');
        generateAiNames(generatorButton);
    });
}

async function generateAiNames(button) {
    const modal = document.getElementById('name-generator-modal');
    const optionsContainer = document.getElementById('name-options-container');
    const regenerateButton = document.getElementById('regenerate-names-btn');
    
    optionsContainer.innerHTML = `<div class="loading-spinner" style="margin: 20px auto;"></div>`;
    modal.style.display = 'flex';

    const currentCard = buildCardObject();
    const prompt = `你是一位富有创造力的命名大师。请根据以下角色设定，为角色生成5个好听、贴切的名字。
请严格按照JSON数组的格式返回，例如：["名字A", "名字B", "名字C", "名字D", "名字E"]。不要包含任何额外的解释或文本。

角色设定:
- 主题/世界观: ${currentCard.topic || '未指定'}
- 性别: ${currentCard.gender || '未指定'}
- 角色描述: ${currentCard.description || '未指定'}
- 个性: ${currentCard.personality || '未指定'}`;

    const originalRegenerateText = regenerateButton.textContent;
    regenerateButton.disabled = true;
    regenerateButton.textContent = t('generating');

    try {
        const result = await callApi(prompt, button);
        if (result) {
            const cleanedResult = result.replace(/^```json\s*|```$/g, '').trim();
            const names = JSON.parse(cleanedResult);

            if (Array.isArray(names) && names.length > 0) {
                optionsContainer.innerHTML = '';
                names.forEach(name => {
                    const nameButton = document.createElement('button');
                    nameButton.textContent = name;
                    nameButton.onclick = () => {
                        document.getElementById('name').value = name;
                        modal.style.display = 'none';
                    };
                    optionsContainer.appendChild(nameButton);
                });
            } else {
                throw new Error("AI did not return a valid array of names.");
            }
        } else {
            optionsContainer.innerHTML = `<p>${t('name-generation-failed')}</p>`;
        }
    } catch (e) {
        console.error("Failed to parse AI-generated names:", e);
        console.error("Raw response:", result);
        optionsContainer.innerHTML = `<p>${t('name-generation-failed')}</p>`;
    } finally {
        regenerateButton.disabled = false;
        regenerateButton.textContent = originalRegenerateText;
    }
}


function initializeWorldbookAiModal() {
    const modal = document.getElementById('worldbook-ai-generator-modal');
    const injectBtn = document.getElementById('wb-ai-inject-btn');
    const regenerateBtn = document.getElementById('wb-ai-regenerate-btn');
    const cancelBtn = document.getElementById('wb-ai-cancel-btn');
    const genTypeButtons = modal.querySelectorAll('.generation-type-selector button');

    cancelBtn.onclick = () => modal.style.display = 'none';
    modal.onclick = (e) => { if (e.target === modal) modal.style.display = 'none'; };
    
    genTypeButtons.forEach(button => {
        button.onclick = () => {
            const genType = button.dataset.type;
            modal.dataset.lastGenType = genType; // Store for regeneration
            const generatorButton = document.getElementById('ai-lorebook-generator-btn');
            fetchWorldbookStoryNodes(generatorButton, genType);
        };
    });

    regenerateBtn.onclick = () => {
        const genType = modal.dataset.lastGenType;
        if (genType) {
            const generatorButton = document.getElementById('ai-lorebook-generator-btn');
            fetchWorldbookStoryNodes(generatorButton, genType);
        }
    };

    injectBtn.onclick = () => {
        const container = document.getElementById('wb-ai-options-container');
        const checked = container.querySelectorAll('input[type="checkbox"][data-entry]:checked');
        const existingEntries = buildWorldbookDataFromDOM();
        let maxId = existingEntries.length > 0 ? Math.max(...existingEntries.map(e => e.id)) : -1;

        const newEntries = Array.from(checked).map(checkbox => {
            const entryData = JSON.parse(checkbox.dataset.entry);
            maxId++;
            return {
                ...entryData,
                id: maxId,
                children: [] 
            };
        });

        if (newEntries.length > 0) {
            renderWorldbookFromData(existingEntries.concat(newEntries));
            alert(t('lorebook-injected-success', {count: newEntries.length}));
        }
        modal.style.display = 'none';
    };
}

function openWorldbookAiModal(button) {
    const modal = document.getElementById('worldbook-ai-generator-modal');
    const desc = document.getElementById('wb-ai-modal-desc');
    const optionsContainer = document.getElementById('wb-ai-options-container');
    const injectBtn = document.getElementById('wb-ai-inject-btn');
    const regenerateBtn = document.getElementById('wb-ai-regenerate-btn');
    
    // Reset modal state
    desc.textContent = t('wb-ai-modal-desc');
    optionsContainer.innerHTML = '';
    injectBtn.style.display = 'none';
    regenerateBtn.style.display = 'none';
    
    modal.style.display = 'flex';
}

async function fetchWorldbookStoryNodes(button, generationType) {
    const modal = document.getElementById('worldbook-ai-generator-modal');
    const container = document.getElementById('wb-ai-options-container');
    const desc = document.getElementById('wb-ai-modal-desc');
    const injectBtn = document.getElementById('wb-ai-inject-btn');
    const regenerateBtn = document.getElementById('wb-ai-regenerate-btn');

    const typeName = t(`wb-ai-type-${generationType}`);
    desc.textContent = t('wb-ai-modal-desc-generating', {type: typeName});
    container.innerHTML = `<div class="loading-spinner" style="margin: 20px auto;"></div>`;
    injectBtn.style.display = 'none';
    regenerateBtn.style.display = 'none';
    
    const characterContext = buildCardObject();
    const existingEntries = buildWorldbookDataFromDOM(); // 获取现有条目
    
    // DeepSeek 限制逻辑
    const apiSettings = loadApiSettings();
    const isDeepSeek = apiSettings.provider === 'deepseek';
    const totalEntries = countAllEntries(existingEntries);
    const truncationLength = isDeepSeek && totalEntries > 0 ? Math.floor(40000 / totalEntries) : Infinity;

    const existingEntriesText = existingEntries.map(entry => {
        const truncatedContent = entry.content.substring(0, truncationLength);
        return `条目注释: ${entry.comment}\n关键词: ${entry.keys.join(', ')}\n内容: ${truncatedContent}${entry.content.length > truncationLength ? '...' : ''}\n`;
    }).join('\n---\n');

    let prompt;
    switch (generationType) {
        case 'worldview':
            prompt = `你是一位世界构建专家。请分析以下角色设定和【已有的世界书条目】，并为该角色创建3-5个【新的、不重复的】核心【世界观】条目。这些条目应该描述重要的地点、组织、概念或技术。`;
            break;
        case 'main_plot':
            prompt = `你是一位剧情设计师。请分析以下角色设定和【已有的世界书条目】，并为该角色创建一套包含1个主线目标和2-3个步骤的【新的、不重复的】【主线剧情】条目。`;
            break;
        case 'side_plot':
            prompt = `你是一位故事创作者。请分析以下角色设定和【已有的世界书条目】，并为该角色创建一套包含2-3个相关条目的【新的、不重复的】【支线剧情】。`;
            break;
    }

    prompt += `
**角色设定:**
- 角色名: ${characterContext.name || '未指定'}
- 主题/世界观: ${characterContext.topic || '未指定'}
- 角色描述: ${characterContext.description || '未指定'}

**已有的世界书条目 (用于参考，请勿重复):**
${existingEntriesText || '无'}

**你的任务:**
**严格按照以下JSON格式返回你的答案，不要包含任何JSON格式之外的额外文字、解释或Markdown标记。**
返回一个JSON数组，其中每个对象代表一个条目，且必须包含以下键:
- "comment": (字符串) 条目注释/标题。
- "keys": (字符串数组) 相关的触发关键词。
- "content": (字符串) 条目的详细内容。
- "priority": (数字) 优先级，越大越重要 (普通=100, 重要=200, 核心=1000)。
- "constant": (布尔值) 是否为恒定注入。对于基础世界观、角色核心设定等应为 true，对于具体事件或地点等应为 false。
`;

    getAiGuidance(t('ai-guidance-title'), async (userGuidance) => {
        let finalPrompt = prompt;
        if (userGuidance) {
            finalPrompt += `\n**用户的额外指令:** ${userGuidance}\n`;
        }

        const result = await callApi(finalPrompt, button);
        try {
            if (result) {
                const cleanedResult = result.replace(/^```json\s*|```$/g, '');
                const generatedEntries = JSON.parse(cleanedResult);

                if (Array.isArray(generatedEntries)) {
                    desc.textContent = t('wb-ai-modal-desc-generated', {type: typeName});
                    container.innerHTML = ''; // Clear spinner
                    injectBtn.style.display = 'inline-block';
                    regenerateBtn.style.display = 'inline-block';

                    generatedEntries.forEach((entry) => {
                        const entryData = {
                            comment: entry.comment || '无题',
                            keys: entry.keys || [],
                            content: entry.content || '无内容',
                            priority: entry.priority || 100,
                            constant: entry.constant || false, // Capture the new field
                            enabled: true, 
                            selective: true, 
                            position: 'before_char', 
                            wb_depth: 4,
                        };

                        const entryDiv = document.createElement('div');
                        entryDiv.className = 'generated-entry';
                        
                        // Main selection checkbox
                        // ================== BUG FIX START ==================
                        const mainCheckboxId = `main-check-id-${Math.random().toString(36).slice(2)}`;
                        // =================== BUG FIX END ===================

                        entryDiv.innerHTML = `
                            <label for="${mainCheckboxId}">
                                <input type="checkbox" id="${mainCheckboxId}" checked data-entry='${JSON.stringify(entryData)}'>
                                <div class="entry-details">
                                    <h4>${entry.comment || '无题'}</h4>
                                    <p><strong>触发词:</strong> ${(entry.keys || []).join(', ')}</p>
                                    <p><strong>内容:</strong> ${entry.content || '无内容'}</p>
                                    <div class="ai-entry-controls">
                                        <span><strong>建议优先级:</strong> ${entry.priority || 100}</span>
                                        <label>
                                            <input type="checkbox" class="wb-ai-constant-toggle" ${entry.constant ? 'checked' : ''}>
                                            ${t('entry-constant')}
                                        </label>
                                    </div>
                                </div>
                            </label>
                        `;
                        container.appendChild(entryDiv);
                        
                        // Add event listener to the new constant toggle
                        const constantToggle = entryDiv.querySelector('.wb-ai-constant-toggle');
                        const mainCheckbox = entryDiv.querySelector(`#${mainCheckboxId}`);
                        
                        constantToggle.addEventListener('change', (e) => {
                            const currentData = JSON.parse(mainCheckbox.dataset.entry);
                            currentData.constant = e.target.checked;
                            mainCheckbox.dataset.entry = JSON.stringify(currentData);
                        });
                    });
                } else { throw new Error(t('ai-return-not-array')); }
            }
        } catch (e) {
            console.error("解析AI返回的JSON失败:", e, "收到的原始数据:", result);
            container.innerHTML = `<p>${t('ai-parse-failed')}</p>`;
            alert(t('ai-parse-failed'));
        }
    });
}


async function aiCompleteAllFields(button) {
    const currentCard = buildCardObject();
    const allFields = ["name", "topic", "gender", "description", "personality", "tags", "system_prompt", "scenario", "first_mes", "mes_example"];
    const filledFields = {};
    const emptyFields = [];

    allFields.forEach(id => {
        const el = document.getElementById(id);
        if (el) {
            if (el.value.trim()) {
                filledFields[id] = el.value.trim();
            } else {
                emptyFields.push(id);
            }
        }
    });

    const isAnythingFilled = Object.keys(filledFields).length > 0;
    const existingEntries = buildWorldbookDataFromDOM();
    
    // DeepSeek 限制逻辑
    const apiSettings = loadApiSettings();
    const isDeepSeek = apiSettings.provider === 'deepseek';
    const totalEntries = countAllEntries(existingEntries);
    const truncationLength = isDeepSeek && totalEntries > 0 ? Math.floor(40000 / totalEntries) : Infinity;

    const existingEntriesText = existingEntries.map(entry => {
        const truncatedContent = entry.content.substring(0, truncationLength);
        return `- ${entry.comment}: ${truncatedContent}${entry.content.length > truncationLength ? '...' : ''}`;
    }).join('\n');

    const worldbookContextPrompt = `
---
**已有的世界书条目 (用于参考):**
${existingEntriesText || '无'}
---`;

    if (isAnythingFilled) {
        // 方案1：有内容，补全其他
        if (emptyFields.length === 0) {
            alert("所有字段都已填写！");
            return;
        }
        
        getAiGuidance(t('ai-guidance-title'), async (userGuidance) => {
            emptyFields.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.dataset.aiBackup = el.value;
            });

            let prompt = `你是一位顶级的角色设计师。请根据以下已经提供的角色信息，为角色补全剩余的空白字段。
---
**已提供的信息:**
${Object.entries(filledFields).map(([key, value]) => `- ${t(key)}: ${value}`).join('\n')}
${worldbookContextPrompt}
---
**需要你补全的字段:**
"${emptyFields.join('", "')}"
---
`;
            if (userGuidance) {
                prompt += `**用户的额外指令:** ${userGuidance}\n---`;
            }
            prompt += `**你的任务:**
请为需要补全的字段生成内容，并**严格以一个单一的JSON对象格式返回**，只包含你需要补全的字段的键和值。不要包含任何解释或Markdown标记。
- 对于 "tags" 和 "personality" 字段, 请返回一个由逗号分隔的字符串。
- 对于 "mes_example", 请生成一段包含{{user}}和{{char}}的对话示例，对话开始另起一行以<START>开头。例如：
<START>（每次对话的开头都需要这样标记）

{{user}}: 你好。
{{char}}: (微笑着向你点头) 你好，{{user}}。找我有什么事吗？

`;
            const result = await callApi(prompt, button);
            if (result) {
                try {
                    const cleanedResult = result.replace(/^```json\s*|```$/g, '');
                    const data = JSON.parse(cleanedResult);

                    emptyFields.forEach(id => {
                        if (data[id]) {
                            const el = document.getElementById(id);
                            if (el) {
                                el.value = data[id];
                                const undoBtn = el.closest('.field-group').querySelector('.ai-undo-button');
                                if (undoBtn) {
                                    undoBtn.style.display = 'inline-block';
                                }
                            }
                        }
                    });
                    alert(t('all-fields-completed'));
                } catch (e) {
                    console.error("解析AI返回的JSON失败:", e, "收到的原始数据:", result);
                    alert(t('ai-parse-failed'));
                }
            }
        }, t('ai-guidance-prompt'));

    } else {
        // 方案2：全空，按原逻辑执行
        getAiGuidance(t('ai-complete-all-guidance-title'), async (userGuidance) => {
            if (!userGuidance) {
                alert(t('ai-complete-all-guidance-placeholder'));
                return;
            }

            const fieldsToComplete = ["description", "personality", "tags", "system_prompt", "scenario", "first_mes", "mes_example", "name", "topic", "gender"];
            fieldsToComplete.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.dataset.aiBackup = el.value;
            });

            const prompt = `你是一位顶级的角色设计师。根据用户提供的核心概念，为角色生成一个完整的设定档案。
---
**用户核心概念:** ${userGuidance}
${worldbookContextPrompt}
---
**你的任务:**
请为以下所有字段生成内容，并**严格以一个单一的JSON对象格式返回**，不要包含任何解释或Markdown标记。
字段包括: "${fieldsToComplete.join('", "')}"
- 对于 "tags" 和 "personality" 字段, 请返回一个由逗号分隔的字符串。
- 对于 "mes_example", 请生成一段包含{{user}}和{{char}}的对话示例，对话开始另起一行以<START>开头。例如：
<START>（每次对话的开头都需要这样标记）

{{user}}: 你好。
{{char}}: (微笑着向你点头) 你好，{{user}}。找我有什么事吗？
`;
            const result = await callApi(prompt, button);
            if (result) {
                try {
                    const cleanedResult = result.replace(/^```json\s*|```$/g, '');
                    const data = JSON.parse(cleanedResult);

                    fieldsToComplete.forEach(id => {
                        if (data[id]) {
                            const el = document.getElementById(id);
                            if (el) {
                                el.value = data[id];
                                const undoBtn = el.closest('.field-group').querySelector('.ai-undo-button');
                                if (undoBtn) {
                                    undoBtn.style.display = 'inline-block';
                                }
                            }
                        }
                    });
                    alert(t('all-fields-completed'));
                } catch (e) {
                    console.error("解析AI返回的JSON失败:", e, "收到的原始数据:", result);
                    alert(t('ai-parse-failed'));
                }
            }
        }, t('ai-complete-all-guidance-placeholder'));
    }
}

// ====================================================================================
// --- LORE BOOK MANAGEMENT (DATA-DRIVEN) ---
// ====================================================================================

function findEntryRecursive(list, elementToFind, parent = null) {
    for (let i = 0; i < list.length; i++) {
        const item = list[i];
        if (item.element === elementToFind) {
            return {
                entry: item,
                parentList: list,
                index: i,
                parentEntry: parent
            };
        }
        if (item.children && item.children.length > 0) {
            const found = findEntryRecursive(item.children, elementToFind, item);
            if (found) {
                return found;
            }
        }
    }
    return null;
}

function parseEntryFromElement(element) {
    return {
        id: parseInt(element.querySelector('.wb-sort-id').value, 10) || 0,
        keys: element.querySelector('.wb-keys').value.split(/[,、，\s]+/).map(k => k.trim()).filter(Boolean),
        secondary_keys: element.querySelector('.wb-secondary-keys').value.split(/[,、，\s]+/).map(k => k.trim()).filter(Boolean),
        secondary_keys_logic: element.querySelector('.wb-secondary-keys-logic').value,
        comment: element.querySelector('.entry-comment').value,
        content: element.querySelector('.wb-content').value,
        priority: parseInt(element.querySelector('.wb-priority').value, 10) || 100,
        enabled: element.querySelector('.wb-enabled').checked,
        prevent_recursion: element.querySelector('.wb-prevent-recursion').checked,
        group: element.querySelector('.wb-group').value.trim(),
        position: element.querySelector('.wb-position').value,
        scope: element.querySelector('.wb-scope').value,
        constant: element.querySelector('.wb-constant').checked,
        selective: element.querySelector('.wb-selective').checked,
        use_regex: element.querySelector('.wb-use-regex').checked,
        match_whole_words: element.querySelector('.wb-match-whole-words').checked,
        case_sensitive: element.querySelector('.wb-case-sensitive').checked,
        probability: parseInt(element.querySelector('.wb-probability').value, 10),
        wb_depth: parseInt(element.querySelector('.wb-depth').value, 10) || 4,
        element: element,
        children: []
    };
}

function buildWorldbookDataFromDOM(parentElement = document.getElementById('worldbook-entries-container')) {
    const entries = [];
    const childElements = Array.from(parentElement.children);

    for (const el of childElements) {
        if (el.matches('li.worldbook-entry')) {
            const entryData = parseEntryFromElement(el);
            const childContainer = el.querySelector('.child-entries');
            if (childContainer && childContainer.children.length > 0) {
                entryData.children = buildWorldbookDataFromDOM(childContainer);
            }
            entries.push(entryData);
        }
    }
    return entries;
}

function renderWorldbookFromData(data) {
    const container = document.getElementById('worldbook-entries-container');
    container.innerHTML = ''; 

    function renderLevel(entries, parentElement) {
        entries.forEach(entryData => {
            const entryElement = createWorldbookEntryElement(entryData);
            parentElement.appendChild(entryElement);
            if (entryData.children && entryData.children.length > 0) {
                const childContainer = entryElement.querySelector('.child-entries');
                renderLevel(entryData.children, childContainer);
            }
        });
    }
    
    renderLevel(data, container);
    updateAllEntryAttributes();
}

function countAllEntries(entries) {
    let count = 0;
    if (!entries) return 0;
    
    for (const entry of entries) {
        count++; // Count the entry itself
        if (entry.children && entry.children.length > 0) {
            count += countAllEntries(entry.children); // Add count of children
        }
    }
    return count;
}

function sortDataTree(data) {
    data.sort((a, b) => (a.id || 0) - (b.id || 0));
    data.forEach(entry => {
        if (entry.children && entry.children.length > 0) {
            sortDataTree(entry.children);
        }
    });
}

function sortWorldbookEntries() {
    const worldbookData = buildWorldbookDataFromDOM();
    sortDataTree(worldbookData);
    renderWorldbookFromData(worldbookData);
    alert('条目已按ID重新排列！');
}

function airdropEntry(button) {
    const currentEntryElement = button.closest('.worldbook-entry');
    if (!currentEntryElement) return;

    const idInput = currentEntryElement.querySelector('.wb-sort-id');
    if (!idInput) return;

    const targetId = parseInt(idInput.value, 10);
    if (isNaN(targetId)) {
        alert("请输入一个有效的数字ID。");
        return;
    }
    const worldbookData = buildWorldbookDataFromDOM();
    let entryToMove = null;
    let parentList = null;

    function findEntryAndParent(data, parent) {
        for (const entry of data) {
            if (entry.element === currentEntryElement) {
                entryToMove = entry;
                parentList = parent;
                return;
            }
            if (entry.children.length > 0) {
                findEntryAndParent(entry.children, entry.children);
            }
        }
    }
    findEntryAndParent(worldbookData, worldbookData);
    if (!entryToMove || !parentList) return;
    parentList.forEach(sibling => {
        if (sibling !== entryToMove && sibling.id >= targetId) {
            sibling.id += 1;
        }
    });
    entryToMove.id = targetId;
    sortDataTree(worldbookData);
    renderWorldbookFromData(worldbookData);
    alert(`操作完成！列表已根据新ID排列。`);
}

function createDefaultImage(ratio = '2:3') {
    const canvas = document.createElement('canvas');
    const [width, height] = ratio === '2:3' ? [512, 768] : [768, 512];
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');
    const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
    gradient.addColorStop(0, '#2d2d2d');
    gradient.addColorStop(1, '#1c1c1c');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    return canvas.toDataURL('image/png');
}

function addWorldbookEntry() {
    const worldbookData = buildWorldbookDataFromDOM();
    const newId = (worldbookData.length > 0) ? Math.max(...worldbookData.map(e => e.id)) + 1 : 0;
    worldbookData.push({ id: newId, comment: '新条目', keys: [], content: '', children: [] });
    renderWorldbookFromData(worldbookData);
}

// 新增：设置优先级的辅助函数
function setPriority(button, value) {
    const priorityInput = button.closest('.field-group').querySelector('.wb-priority');
    if (priorityInput) {
        priorityInput.value = value;
    }
}

function createWorldbookEntryElement(entryData = {}) {
    const entryLi = document.createElement('li');
    entryLi.className = 'worldbook-entry';
    const uniqueId = `wb-entry-${Date.now()}-${Math.random()}`;
    entryLi.dataset.uniqueId = uniqueId;
    
    const defaultEntry = {
        comment: '新条目', keys: [], secondary_keys: [], content: '',
        secondary_keys_logic: 'any',
        priority: 100, enabled: true, prevent_recursion: false,
        group: '', position: 'before_char', scope: 'chat',
        id: 0,
        constant: false, selective: true, use_regex: false,
        match_whole_words: true, case_sensitive: false, probability: 100,
        wb_depth: 4,
        ...entryData
    };
    
    entryLi.innerHTML = `
        <div class="entry-content-wrapper">
            <div class="entry-header">
                <div class="entry-title-group">
                    <div style="display: flex; align-items: center; gap: 5px;">
                        <input type="number" class="wb-sort-id" title="${t('help-entry-id')}" placeholder="${t('entry-id')}" value="${defaultEntry.id}" style="width: 65px; flex-shrink: 0;">
                        <button title="将此条目插入到左侧框中指定的ID位置，并顺延后续条目" onclick="airdropEntry(this)" style="padding: 5px 8px; font-size: 14px; background-color: #6c757d; color: white;">➡️</button>
                    </div>
                    <input type="text" class="entry-comment" placeholder="${t('entry-comment-placeholder')}" value="${defaultEntry.comment}">
                    <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-id-drop'))">?</span>
                </div>
                <div class="entry-actions">
                    <button title="添加子条目" onclick="addChildEntry(this)">➕</button>
                    <button title="将此条目移出父条目" onclick="indentEntry(this, -1)">↓退出</button>
                    <button title="将此条目设为上方同级条目的子条目" onclick="indentEntry(this, 1)">↑加入</button>
                    <button class="delete-entry-btn" onclick="this.closest('.worldbook-entry').remove();">${t('delete')}</button>
                </div>
            </div>
            <div class="entry-grid">
                <div class="field-group full-width">
                    <label>${t('main-keys')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-main-keys'))">?</span></label>
                    <input type="text" class="wb-keys" placeholder="${t('main-keys-placeholder')}" value="${(defaultEntry.keys || []).join(', ')}">
                </div>
                <div class="field-group full-width">
                    <label>${t('injection-content')} <button class="ai-button" onclick="callWorldbookDeepSeek(this)" style="padding: 2px 8px; font-size: 12px; width: auto; margin-left: 10px;">${t('ai-help-write')}</button><button class="ai-undo-button" onclick="undoAiCompletion(this)">${t('undo')}</button></label>
                    <textarea class="wb-content" rows="3" placeholder="${t('injection-content-placeholder')}">${defaultEntry.content}</textarea>
                </div>

                <div class="field-group full-width">
                    <details>
                        <summary id="advanced-settings-summary">${t('advanced-settings')} <span style="font-weight: normal; font-size: 14px; color: #aaa;">(关键词匹配、注入逻辑等)</span></summary>
                        <div class="advanced-grid">
                            <div class="field-group full-width">
                                <label>关键字过滤器 
                                    <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-secondary-keys'))">?</span>
                                </label>
                                <div style="display: flex; gap: 10px; align-items: center;">
                                    <select class="wb-secondary-keys-logic" style="flex: 1; padding: 12px;">
                                        <option value="any" ${defaultEntry.secondary_keys_logic === 'any' ? 'selected' : ''}>与任意</option>
                                        <option value="none" ${defaultEntry.secondary_keys_logic === 'none' ? 'selected' : ''}>非任意</option>
                                        <option value="all" ${defaultEntry.secondary_keys_logic === 'all' ? 'selected' : ''}>与所有</option>
                                        <option value="not_all" ${defaultEntry.secondary_keys_logic === 'not_all' ? 'selected' : ''}>非所有</option>
                                    </select>
                                    <input type="text" class="wb-secondary-keys" placeholder="${t('secondary-keys-placeholder')}" value="${(defaultEntry.secondary_keys || []).join(', ')}" style="flex: 3;">
                                </div>
                            </div>
                            <div class="field-group">
                                <label>${t('entry-position')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-entry-position'))">?</span></label>
                                <select class="wb-position">
                                    <option value="before_char" ${defaultEntry.position === 'before_char' ? 'selected' : ''}>角色定义前</option>
                                    <option value="after_char" ${defaultEntry.position === 'after_char' ? 'selected' : ''}>角色定义后</option>
                                    <option value="before_prompt" ${defaultEntry.position === 'before_prompt' ? 'selected' : ''}>最开头</option>
                                </select>
                            </div>
                            <div class="field-group">
                                <label>${t('entry-scope')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-entry-scope'))">?</span></label>
                                <select class="wb-scope">
                                    <option value="chat" ${defaultEntry.scope === 'chat' ? 'selected' : ''}>聊天中</option>
                                    <option value="summary" ${defaultEntry.scope === 'summary' ? 'selected' : ''}>记忆摘要中</option>
                                    <option value="discovery" ${defaultEntry.scope === 'discovery' ? 'selected' : ''}>每次进入聊天时</option>
                                </select>
                            </div>
                            <div class="field-group" style="display: flex; flex-direction: column; align-items: flex-start;">
                                <label style="margin-bottom: 8px;">${t('entry-priority')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-entry-priority'))">?</span></label>
                                <div style="display: flex; align-items: center; width: 100%;">
                                    <input type="number" class="wb-priority" value="${defaultEntry.priority}" step="100" style="flex-grow: 1;">
                                    <div class="priority-buttons">
                                        <button onclick="setPriority(this, 1000)" title="1000">${t('priority-preset-prereq')}</button>
                                        <button onclick="setPriority(this, 200)" title="200">${t('priority-preset-important')}</button>
                                        <button onclick="setPriority(this, 100)" title="100">${t('priority-preset-normal')}</button>
                                    </div>
                                </div>
                            </div>
                            <div class="field-group"><label>${t('entry-group')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-entry-group'))">?</span></label><input type="text" class="wb-group" value="${defaultEntry.group}" placeholder="${t('entry-group-placeholder')}"></div>
                            <div class="field-group"><label>${t('entry-probability')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-entry-probability'))">?</span></label><input type="number" class="wb-probability" value="${defaultEntry.probability}" min="0" max="100"></div>
                            <div class="field-group"><label>${t('entry-depth')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-entry-depth'))">?</span></label><input type="number" class="wb-depth" value="${defaultEntry.wb_depth}"></div>
                            <div class="field-group logic-group full-width">
                                <label><input type="checkbox" class="wb-enabled" ${defaultEntry.enabled ? 'checked' : ''}>${t('entry-enabled')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-entry-enabled'))">?</span></label>
                                <label><input type="checkbox" class="wb-constant" ${defaultEntry.constant ? 'checked' : ''}>${t('entry-constant')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-entry-constant'))">?</span></label>
                                <label><input type="checkbox" class="wb-selective" ${defaultEntry.selective ? 'checked' : ''}>${t('entry-selective')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-entry-selective'))">?</span></label>
                                <label><input type="checkbox" class="wb-prevent-recursion" ${defaultEntry.prevent_recursion ? 'checked' : ''}>${t('entry-prevent-recursion')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-entry-prevent-recursion'))">?</span></label>
                                <label><input type="checkbox" class="wb-use-regex" ${defaultEntry.use_regex ? 'checked' : ''}>${t('entry-use-regex')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-entry-use-regex'))">?</span></label>
                                <label><input type="checkbox" class="wb-match-whole-words" ${defaultEntry.match_whole_words ? 'checked' : ''}>${t('match-whole-words')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-match-whole-words'))">?</span></label>
                                <label><input type="checkbox" class="wb-case-sensitive" ${defaultEntry.case_sensitive ? 'checked' : ''}>${t('case-sensitive')} <span class="help-icon" onclick="event.preventDefault(); event.stopPropagation(); showHelp(t('help-case-sensitive'))">?</span></label>
                            </div>
                        </div>
                    </details>
                </div>
            </div>
        </div>
        <ul class="child-entries"></ul>
    `;
    return entryLi;
}

function addChildEntry(button) {
    const worldbookData = buildWorldbookDataFromDOM();
    const parentEntryElement = button.closest('.worldbook-entry');
    
    function findAndAdd(data) {
        for (const entry of data) {
            if (entry.element === parentEntryElement) {
                const newId = (entry.children.length > 0) ? Math.max(...entry.children.map(e => e.id)) + 1 : 0;
                entry.children.push({ id: newId, comment: '新子条目', keys: [], content: '', children: [] });
                return true;
            }
            if (entry.children.length > 0) {
                if(findAndAdd(entry.children)) return true;
            }
        }
        return false;
    }

    findAndAdd(worldbookData);
    renderWorldbookFromData(worldbookData);
}

function indentEntry(button, direction) {
    const worldbookData = buildWorldbookDataFromDOM();
    const currentEntryElement = button.closest('.worldbook-entry');
    if (!currentEntryElement) return;

    const found = findEntryRecursive(worldbookData, currentEntryElement);

    if (!found) {
        console.error(currentLanguage === 'zh' ? "无法在数据结构中找到对应的条目。" : "Unable to find corresponding entry in data structure.");
        return;
    }

    const { entry, parentList, index, parentEntry } = found;

    if (direction > 0) { // Indent (↑加入): 将条目设为上方同级条目的子条目
        if (index > 0) {
            const newParent = parentList[index - 1];
            parentList.splice(index, 1); // 从当前列表中移除
            newParent.children.push(entry); // 添加到新父级的 children 数组中
        } else {
            alert('已经是同级中的第一个条目，无法加入（缩进）。');
            return;
        }
    } else { // Un-indent (↓退出): 将子条目移出，成为父条目的同级
        if (parentEntry) {
            const parentFound = findEntryRecursive(worldbookData, parentEntry.element);
            if (parentFound) {
                const grandParentList = parentFound.parentList;
                const parentIndex = parentFound.index;

                parentList.splice(index, 1); // 从当前父级的 children 数组中移除
                grandParentList.splice(parentIndex + 1, 0, entry); // 添加到祖父级列表，紧跟在原父级之后
            }
        } else {
            alert(t('already-root-entry'));
            return;
        }
    }

    renderWorldbookFromData(worldbookData);
}

function updateAllEntryAttributes() {
    const container = document.getElementById('worldbook-entries-container');
    
    function traverse(element, depth, indexRef) {
        if (element.matches('li.worldbook-entry')) {
            element.dataset.depth = depth;
            element.dataset.displayIndex = indexRef.index++;
            const childContainer = element.querySelector('.child-entries');
            if (childContainer) {
                Array.from(childContainer.children).forEach(child => traverse(child, depth + 1, indexRef));
            }
        } else if (element.children) {
             Array.from(element.children).forEach(child => traverse(child, 0, indexRef));
        }
    }
    
    let indexCounter = { index: 0 };
    traverse(container, -1, indexCounter);
}

// --- PNG EMBEDDING FUNCTIONS ---
async function cleanImageAndGetDataURL(base64Str) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            resolve(canvas.toDataURL('image/png'));
        };
        img.onerror = () => reject(new Error('无法加载图片，可能不是有效的图片格式。'));
        img.src = base64Str;
    });
}

// 新增：将任何格式的图片转换为PNG格式
async function convertImageToPng(imageDataUrl) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = 'anonymous'; // 允许跨域图片
        
        img.onload = () => {
            try {
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                
                // 绘制图片到canvas
                ctx.drawImage(img, 0, 0);
                
                // 转换为PNG格式
                const pngDataUrl = canvas.toDataURL('image/png', 0.9);
                resolve(pngDataUrl);
            } catch (error) {
                reject(new Error(`图片转换失败: ${error.message}`));
            }
        };
        
        img.onerror = () => {
            reject(new Error('无法加载图片，可能不是有效的图片格式。'));
        };
        
        img.src = imageDataUrl;
    });
}
async function embedDataInPng(imageBase64, textData) {
    const response = await fetch(imageBase64);
    const imageBuffer = await response.arrayBuffer();
    const imageData = new Uint8Array(imageBuffer);
    
    const textEncoder = new TextEncoder();
    const encodedText = textEncoder.encode("chara\x00" + textData);

    const chunk = createTextChunk('tEXt', encodedText);
    
    const iendPosition = findIend(imageData);
    if (iendPosition === -1) throw new Error("Invalid PNG: IEND chunk not found.");
    
    const newPngData = new Uint8Array(imageData.length + chunk.length);
    newPngData.set(imageData.slice(0, iendPosition));
    newPngData.set(chunk, iendPosition);
    newPngData.set(imageData.slice(iendPosition), iendPosition + chunk.length);
    
    return new Blob([newPngData], { type: 'image/png' });
}

function createTextChunk(type, data) {
    const chunkType = new TextEncoder().encode(type);
    const chunkData = data;
    const chunkLength = new Uint8Array(4);
    new DataView(chunkLength.buffer).setUint32(0, chunkData.length);

    const toCrc = new Uint8Array(chunkType.length + chunkData.length);
    toCrc.set(chunkType);
    toCrc.set(chunkData, chunkType.length);
    const crcValue = crc32(toCrc);
    const crc = new Uint8Array(4);
    new DataView(crc.buffer).setUint32(0, crcValue);

    const chunk = new Uint8Array(12 + chunkData.length);
    chunk.set(chunkLength);
    chunk.set(chunkType, 4);
    chunk.set(chunkData, 8);
    chunk.set(crc, 8 + chunkData.length);

    return chunk;
}

function findIend(imageData) {
    const IEND_SIGNATURE = [0x49, 0x45, 0x4E, 0x44];
    for (let i = imageData.length - 12; i >= 8; i--) {
        if (imageData[i+4] === IEND_SIGNATURE[0] && imageData[i+5] === IEND_SIGNATURE[1] && imageData[i+6] === IEND_SIGNATURE[2] && imageData[i+7] === IEND_SIGNATURE[3]) {
           return i;
        }
    }
    return -1;
}

const crc32 = (function() {
    const table = new Uint32Array(256);
    for (let i = 0; i < 256; i++) {
        let c = i;
        for (let j = 0; j < 8; j++) {
            c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
        }
        table[i] = c;
    }
    return function(bytes) {
        let crc = -1;
        for (let i = 0; i < bytes.length; i++) {
            crc = (crc >>> 8) ^ table[(crc ^ bytes[i]) & 0xFF];
        }
        return (crc ^ -1) >>> 0;
    };
})();

async function extractDataFromPng(arrayBuffer) {
    const bytes = new Uint8Array(arrayBuffer);
    const keyword = 'chara';
    
    let i = 8;
    while(i < bytes.length) {
        const view = new DataView(bytes.buffer, i);
        const length = view.getUint32(0);
        const type = new TextDecoder().decode(bytes.slice(i + 4, i + 8));

        if (type === 'tEXt' || type === 'iTXt') {
            const data_start = i + 8;
            let currentKeyword = '';
            let k_end = data_start;
            while(k_end < data_start + length && bytes[k_end] !== 0) {
              currentKeyword += String.fromCharCode(bytes[k_end]);
              k_end++;
            }
            
            if (currentKeyword === keyword) {
                const dataBytes = bytes.slice(k_end + 1, data_start + length);
                const base64String = new TextDecoder("utf-8").decode(dataBytes);
                const jsonString = decodeURIComponent(escape(atob(base64String)));
                return JSON.parse(jsonString);
            }
        }
        i += 12 + length;
    }
    throw new Error('在PNG中未找到角色数据。');
}

</script>

</body>
</html>
